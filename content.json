{"meta":{"title":"Sheep's Blog","subtitle":"","description":"","author":"Yang","url":"https://n1vk.github.io","root":"/"},"pages":[{"title":"","date":"2022-03-28T12:17:05.975Z","updated":"2022-03-28T12:17:05.975Z","comments":true,"path":"404.html","permalink":"https://n1vk.github.io/404.html","excerpt":"","text":"404 您来到了无人之境 再试试别的吧..."},{"title":"","date":"2022-04-27T05:44:21.233Z","updated":"2022-04-27T05:44:21.233Z","comments":true,"path":"googlea872b2bca8f19498.html","permalink":"https://n1vk.github.io/googlea872b2bca8f19498.html","excerpt":"","text":"google-site-verification: googlea872b2bca8f19498.html"},{"title":"","date":"2022-03-29T07:59:39.039Z","updated":"2022-03-29T07:59:39.039Z","comments":false,"path":"EasterEgg/index.html","permalink":"https://n1vk.github.io/EasterEgg/index.html","excerpt":"","text":"Easter Egg 恭喜您找到了本站的彩蛋！ 快去跟朋友炫耀一下吧！ 当然也可能是看到了 Repo 的源码..."},{"title":"关于本站","date":"2020-10-19T14:58:27.000Z","updated":"2022-04-05T02:13:31.221Z","comments":true,"path":"about/index.html","permalink":"https://n1vk.github.io/about/index.html","excerpt":"","text":"站长邮箱：&#x76;&#x61;&#108;&#x6c;&#x68;&#97;&#x6c;&#108;&#x61;&#x40;&#102;&#111;&#120;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109; 本站由 Github Pages 托管，使用 Hexo 模版建立，主题是 Volantis。 没有人为本站提供域名服务。 本站素材来自 Flaticon 的 Freepik，推特开源项目 Twemoji，博客模版 Volantis 和我的猫猫。"},{"title":"按分类查看文章","date":"2020-10-20T09:27:11.075Z","updated":"2020-10-20T09:27:11.075Z","comments":false,"path":"categories/index.html","permalink":"https://n1vk.github.io/categories/index.html","excerpt":"","text":""},{"title":"按标签查看文章","date":"2020-10-20T09:27:33.650Z","updated":"2020-10-20T09:27:33.650Z","comments":false,"path":"tags/index.html","permalink":"https://n1vk.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"查看 Git 存储库中代码提交行数","slug":"git-check-workload","date":"2024-07-18T14:54:53.000Z","updated":"2024-07-18T16:16:26.610Z","comments":true,"path":"Note/git-check-workload/","link":"","permalink":"https://n1vk.github.io/Note/git-check-workload/","excerpt":"好奇你写了多少代码？利用 Git Log 的信息，根据 Commit 记录查看代码行数的编辑量。","text":"发现在某厂实习的同学有一个码力统计平台，可以看到写了多少代码。由此联想到，我们每次执行 Commit 的时候都可以看到控制台输出的文件行数增加减少的提示。因此此信息是被 Git 统计了的，那么当然可以在本地获取到，只不过获取的是单个存储库的内容。 我更好奇为啥 Gitlab 等 Git 端没有集成这个功能，是觉得意义不大吗 首先，我们来用 git log 获取当前存储库所有贡献者，并用 sort -u 去重。此处获得的名字是 gitconfig 设置的名字。 1authors=$(git log --format=&#x27;%aN&#x27; | sort -u) 接下来，我们来遍历这些名字，并根据作者名字获取numstat。 其中，--pretty:tformat:是一个空的自定义格式，表示我们将会忽略所有提交信息，这样我们的输出结果里只有numstat了。 最后，使用awk来统计数量即可。 12345678910111213141516# 一行一行读取名字echo &quot;$authors&quot; | while read name; do # 输出一个定宽名字 do printf &#x27;%-20s&#x27; &quot;[$name]&quot; git log --author=&quot;$name&quot; --pretty=tformat: --numstat | awk &#x27; &#123; add += $1 # 累加添加的行数 subs += $2 # 累加删除的行数 loc += $1 - $2 # 计算总的代码行数变化 &#125; END &#123; # 输出统计结果 printf &quot;[Add] %-6d [Removed] %-6d [Total] %-6d\\n&quot;, add, subs, loc &#125;&#x27;done 最终，我们可以把代码写成一行并用管道连接。可以写成一个alias，如果你想的话。 1git log --format=&#x27;%aN&#x27; | sort -u | while read name; do printf &#x27;%-20s&#x27; &quot;[$name]&quot;; git log --author=&quot;$name&quot; --pretty=tformat: --numstat | awk &#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;[Add] %-6d [Removed] %-6d [Total] %-6d\\n&quot;, add, subs, loc &#125;&#x27;; done 这样就可以看到你写了多少行代码了。哇，好有用的功能啊。 1[Nivek] [Add] 114514 [Removed] 1919 [Total] 112595","categories":[{"name":"Note","slug":"Note","permalink":"https://n1vk.github.io/categories/Note/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://n1vk.github.io/tags/Git/"}],"author":"cat"},{"title":"尝试在一台搭载 Ascend GPU 服务器上进行大模型推理","slug":"inference-on-ascend-server","date":"2024-05-13T10:34:52.000Z","updated":"2024-07-18T15:51:01.994Z","comments":true,"path":"Note/inference-on-ascend-server/","link":"","permalink":"https://n1vk.github.io/Note/inference-on-ascend-server/","excerpt":"作为英伟达 GPU 的国替，华为 Ascend GPU 服务器能安装依赖并提供大语言模型服务吗？记录一下个人尝试流程 (已失败) 。","text":"真难搞，已老实。好想要A100喔 昇腾简介华为设计发布了AI处理器（NPU），采用达芬奇架构，全面对标英伟达GPU并为人工智能提供全流程支持。我们平时也许对英伟达架构和其他开源AI框架比较熟悉，那么这里给出几个关键词的大概对应来更好地理解昇腾软硬件平台。 首先是硬件层： Atlas 硬件 (基于 Huawei Ascend 核心) &gt; Nvidia GPU (A100, H800..) 其次是计算架构： CANN &gt; CUDA 华为同样也有自己的深度学习框架，但也对第三方框架做出了适配： MindSpore 晟思 &gt; Tensorflow / Pytorch 服务器现状现有 Atlas 800 训练服务器，其拥有 8个 Atlas 300T（即 Ascend 910）。 服务器本身并不是华为，而是来自烽火超微/长江计算的FitServer G420X V5，在网络上鲜有资料。 服务器运行 BigCloud Enterprise Linux For Euler 21.10系统（应该就是openEuler，在中移官网上也显示出其本质是openEuler）。 安装 CANNCANN 分为几个版本，Toolkit是最全量的，其支持训练、推理、模型转换及其他应用开发。我们下载 Ascend-cann-toolkit_8.0.RC2.alpha001_linux-x86_64.run 并用 SFTP 上传到服务器。 [已失败] 离线安装依赖根据手册，我们需要为系统安装第三方依赖，但服务器并无互联网连接。我们在本地启动一个Docker，并利用本地Docker下载包，上传到服务器安装： 12docker pull centosdocker run -d -i -t --name bclinux centos /bin/bash Docker 命令行知识 -d以后台模式运行容器 -p 宿主机端口:容器端口 将宿主机的端口映射到容器的某个端口 -i 提供交互式bash（即使没有连接也保持STDIN开启） -t分配一个伪TTY 这里回顾发现装错了，应该装 openEuler 的镜像的。不过这玩意真的有 Docker Image 吗？ BigCloud Enterprise Linux是中移基于CentOS自己包装的系统。因此我们装个CentOS8即可。这里记录一下CentOS出现的一些yum问题，由于CentOS已经停止更新，我们可以通过以下方式将其镜像设置为阿里云： 12345minorver=8.5.2111sed -e &quot;s|^mirrorlist=|#mirrorlist=|g&quot; \\ -e &quot;s|^#baseurl=http://mirror.centos.org/\\$contentdir/\\$releasever|baseurl=https://mirrors.aliyun.com/centos-vault/$minorver|g&quot; \\ -i.bak \\ /etc/yum.repos.d/CentOS-*.repo 接下来我们使用: 1yum install --downloadonly XXX --downloaddir=&quot;./pkgs&quot; 就可以仅下载不安装rpm包了。 将安装好的rpm包拷贝到宿主机： 1docker cp centos:/root/pkgs pkgs/ 并使用rpm -ivh/-Uvh安装。 完全失败了。因为系统已经安装了很多包，同时需要安装的包也很多，相互间产生了循环依赖，手动解决的代价很大。 访问校园镜像说服了服务器管理员允许集群访问校园镜像站。 还是社工好用啊.jpg 另：学校镜像站的IP地址是一个公网IP，在唐仲英楼。 选择推理框架已经有了算子，现在只需要推理框架就可以部署模型了。考虑以下几个备选： FastChat 只支持使用单个 Ascend NPU 进行推理，能跑但效率感人，失败 MindIE 没想到华为自己的框架都不支持这款服务器，失败 vLLM 不支持 CANN 暂时没有发现其他的框架。搁置。","categories":[{"name":"Note","slug":"Note","permalink":"https://n1vk.github.io/categories/Note/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://n1vk.github.io/tags/Linux/"},{"name":"LLM","slug":"LLM","permalink":"https://n1vk.github.io/tags/LLM/"},{"name":"昇腾","slug":"昇腾","permalink":"https://n1vk.github.io/tags/%E6%98%87%E8%85%BE/"}]},{"title":"记录 Vue 亲子组件遇到的坑和解决办法","slug":"vue-component-control","date":"2024-04-11T09:05:35.000Z","updated":"2024-04-11T09:28:00.792Z","comments":true,"path":"Note/vue-component-control/","link":"","permalink":"https://n1vk.github.io/Note/vue-component-control/","excerpt":"需要将一个el-dialog抽象为一个子组件，如何控制其显示/隐藏和传递数据。","text":"当有一个el-dialog在很多组件中都有用到，并且其逻辑一致，这个时候可以考虑把它抽象为一个单独的.vue文件。但此时组件和组件间无法传递ref类型，应该如何绑定v-model来控制组件的开启和关闭呢？使用什么办法给组件传递值呢？ 模版引用如果我们直接使用el-dialog，一般都是这样： 12345678910111213&lt;script setup lang&#x3D;&quot;ts&quot;&gt; const dialogVisible &#x3D; ref(false) func openLogic() &#123; dialogVisible.value &#x3D; true &#125;&lt;&#x2F;script&gt;&lt;template&gt; &lt;el-dialog v-model&#x3D;&quot;dialogVisible&quot;&gt; &lt;!-- 逻辑 --&gt; &lt;&#x2F;el-dialog&gt;&lt;&#x2F;template&gt; 我们可以直接操作是否显示。这是因为我们能够合理的使用 openLogic()。但如果这个组件内部只有一个el-dialog，即他被整体抽象出来了，我们就没地方执行openLogic()了。 这个时候就在亲组件里使用模版引用吧。以下是componentDialog.vue的核心部分： 1234567891011121314151617&lt;script setup lang&#x3D;&quot;ts&quot;&gt; const dialogVisible &#x3D; ref(false) function open() &#123; dialogVisible.value &#x3D; true &#125; defineExpose(&#123; open &#125;)&lt;&#x2F;script&gt;&lt;template&gt; &lt;el-dialog v-model&#x3D;&quot;dialogVisible&quot;&gt; &lt;!-- 逻辑 --&gt; &lt;&#x2F;el-dialog&gt;&lt;&#x2F;template&gt; 向外界暴露了一个open方法。这个时候，在亲组件parent.vue里： 1234567891011&lt;script setup lang&#x3D;&quot;ts&quot;&gt; const dialogRef &#x3D; ref(null) function openLogic() &#123; dialogRef.value.open() &#125;&lt;&#x2F;script&gt;&lt;template&gt; &lt;componentDialog ref&#x3D;&quot;dialogRef&quot;&#x2F;&gt;&lt;&#x2F;template&gt; 我们通过Vue的模版引用拿到了这个组件的引用。这样就可以执行组件暴露出的方法并完成openLogic()了。至于关闭，直接在子组件内定义即可。 问题 - ref的时机假设我的componentDialog.vue需要一些值，我们一般会想到使用props传递数据。那么当DOM被渲染的时候，组件就会试图拿到parent.vue中的数据，而这些数据可能在parent.vue执行一些逻辑后的后续的操作中才被初始化。 我遇到了这个问题，每次我打开parent.vue，子组件就会立刻被初始化，并且通过未初始化的值向后端发送请求，这导致了一些错误。我下意识的想法是使用v-if。 然而，模版引用并不是响应式的！ref只在DOM渲染的时候去获取对应的组件，然而最开始v-if是false，这就导致引用类型没有正常初始化，因为DOM也没有被渲染。当把v-if设定为true之后就去使用引用类型，则会报错。因为此时引用类型是undefined。这个坑对于v-for也是存在的。 我的解决方案是，仍然沿用问题一的逻辑，子组件暴露的函数需要一些参数，而亲代将需要的数据作为函数参数进行传递，这就推迟了子组件向后端索要数据的时机，从而避免错误。这样就弃用了亲传子常用的props属性。 组件事件子组件如何通知亲代组件关于某件事情的行为？使用组件事件即可。 子组件可以自定义一些事件，并在合适的时机触发这些事件。亲组件可以自定义一些函数和子组件的事件绑定。当子组件的事件被触发，亲组件相应绑定的函数就会被执行。 举例如下， componentDialog.vue： 1234567&lt;script&gt; const emit &#x3D; defineEmits([&#39;operationFinish&#39;]) func emitLogic() &#123; emit(&quot;operationFinish&quot;, ...) &#x2F;&#x2F; 可选参数 &#125;&lt;&#x2F;script&gt; parent.vue 1234567891011&lt;script setup lang&#x3D;&quot;ts&quot;&gt; &#x2F;&#x2F; 同样可选参数 function handleLogic(...) &#123; &#x2F;&#x2F; do sth &#125;&lt;&#x2F;script&gt;&lt;template&gt; &lt;componentDialog @operation-finish&#x3D;&quot;handleLogic&quot;&#x2F;&gt;&lt;&#x2F;template&gt; 你可以定义很多emit。这就完成了子传亲的行为。","categories":[{"name":"Note","slug":"Note","permalink":"https://n1vk.github.io/categories/Note/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://n1vk.github.io/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://n1vk.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Go 标准库分析 - net/http (部分)","slug":"go-http","date":"2024-04-11T05:20:59.000Z","updated":"2024-04-11T05:41:48.112Z","comments":true,"path":"Programming/go-http/","link":"","permalink":"https://n1vk.github.io/Programming/go-http/","excerpt":"分析Go标准库中提供HTTP客户端和服务端实现的包。这个包比较复杂，因此只会关心一些感兴趣的部分。","text":"还没有写，哈哈 应用例按执行顺序分析服务端客户端","categories":[{"name":"Programming","slug":"Programming","permalink":"https://n1vk.github.io/categories/Programming/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://n1vk.github.io/tags/Golang/"}]},{"title":"Go 标准库分析 - sync","slug":"go-sync","date":"2024-04-11T05:20:52.000Z","updated":"2024-04-15T09:49:31.215Z","comments":true,"path":"Programming/go-sync/","link":"","permalink":"https://n1vk.github.io/Programming/go-sync/","excerpt":"分析Go标准库中提供的同步控制包sync，这个包提供了各种同步原语，主要用于各种协程间管理，互斥锁，并发安全的结构等等。","text":"挖坑慢填，尚未完工 键入go doc sync你可以获得以下文档内容： 123456789101112131415package sync // import &quot;sync&quot;Package sync provides basic synchronization primitives such as mutual exclusion locks. Other than the Once and WaitGroup types, most are intended for use by low-level library routines. Higher-level synchronization is better done via channels and communication.Values containing the types defined in this package should not be copied.type Cond struct&#123; ... &#125; func NewCond(l Locker) *Condtype Locker interface&#123; ... &#125;type Map struct&#123; ... &#125;type Mutex struct&#123; ... &#125;type Once struct&#123; ... &#125;type Pool struct&#123; ... &#125;type RWMutex struct&#123; ... &#125;type WaitGroup struct&#123; ... &#125; 我们针对每个类型进行分析吧（顺序不按照上面给出）。 sync.Locker这个接口定义了锁结构必须实现的方法，也就是加锁和解锁，没有什么特别值得注意的。 1234type Locker interface &#123; Lock() Unlock()&#125; 后面我们将看到很多原语都实现了这个接口。 sync.Mutex / sync.RWMutex顾名思义，这两个原语实现了互斥锁/读写互斥锁。 sync.Once该原语能够确保某个函数只被执行一次。 sync.WaitGroup该源于用于在一个 goroutine 中等待其他一组 goroutine 执行完毕。 sync.Pool这是一个并发池，用来安全地保存一组对象。当我们必须重用共享的和长期存在的对象（例如，数据库连接）时，或者需要优化内存分配时（使用sync.Pool可以防止GC后再分配）。 sync.Map这是一个并发安全的map。当我们对map有频繁的读取和不频繁的写入，或者多个 goroutine 读取/写入/覆盖不相交的 key 时，我们使用 sync.Map 而不是普通的map配合sync.Mutex。 注：Any race is a bug. 即使多个 goroutine 写入不相交map键，也会导致程序崩溃（fatal error: concurrent map read and map write），因为map的底层实现逻辑。关于底层逻辑之后再谈。 sync.Cond很不常用地，这个原语用于发出一对一信号或广播信号。创建这个原语需要一个sync.Locker作为参数。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://n1vk.github.io/categories/Programming/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://n1vk.github.io/tags/Golang/"}]},{"title":"Golang 包名的良好命名规范","slug":"go-package-names","date":"2024-04-11T03:39:35.000Z","updated":"2024-04-18T13:08:21.382Z","comments":true,"path":"Note/go-package-names/","link":"","permalink":"https://n1vk.github.io/Note/go-package-names/","excerpt":"Go 包的命名方式和其他语言不太相同，同时 Go 包实际上没有 subpackage （子包）这样的设定。包和包之间是独立的，路径只是用来组织他们。对此感到有些困惑，因此去官方博客阅读一番，并记录下博客的翻译。","text":"全文翻译自go.dev官方博客。其中穿插着一些自己的笔记。 介绍Go代码是以包进行组织的。在包内，代码可以引用其中定义的任何标识符。而包的客户（即import该包的代码）只能引用包的导出类型、函数、常量和变量（以大写字符开头的）。这类引用始终包含了包名作为其前缀：foo.Bar引用foo包中的导出名Bar 好的包命名可以让代码更好。包名为其内容提供了上下文（语义），使客户更容易理解包的用途。同时其也能帮助包自身的维护者确定在扩展功能时，哪些内容仍然改属于这个包，哪些内容不该属于这个包。良好的包命名可以帮助你轻松找到所需代码。 Effective Go提供了包、类型、函数和变量的命名指南。本文则扩展包命名的讨论，并调查在标准库中发现的名称。并且，我们将讨论一些错误的包名和修复他们的方法。 包名好的包名是简短清晰的。小写，无下划线和驼峰。通常是简单名词，举例来说： time (提供了测量和显示时间功能的包) list (实现了双向链表的包) http (提供HTTP客户端/服务端实现的包) 以下是两个名称示例，遵循了另一些语言的典型命名风格。这些名称在其他语言中可能很好，但在 Go 中不太适合： computeServiceClient priority_queue 一个 Go 包可以导出很多类型和函数。举例来说，compute包可以导出一个Client类型，其中包含使用服务的方法，以及跨越多个客户端划分计算任务的函数。 审慎地缩写。当缩写对程序员很熟悉时，包名才可以缩写。常用的包有这些缩写了的名字： strconv -&gt; string conversion syscall -&gt; system call fmt -&gt; formatted I/O 如果缩写会让包名含糊不清，那不如不要缩写。 不要从用户手中偷取好名字。避免给包使用一个客户常用的命名。比如说，缓冲I/O包叫做bufio而不是buf，因为客户经常用buf来命名缓冲区。 命名包内容考虑的客户会同时使用包和其内容，这两者的命名应是耦合的。设计包时应该站在客户的角度。 避免重复。由于客户代码在引用包内容时使用包名称作为前缀，因此这些内容的名称不需要重复包名称。 http 包提供的 HTTP 服务器称为 Server ，而不是 HTTPServer 。客户端代码将此类型称为 http.Server ，因此没有歧义，不需要再重复一遍。 简化函数名。当包pkg中的函数返回一个pkg.Pkg（或*pkg.Pkg）类型的值时，函数名称可以省略类型名称而不会造成混淆，比如： 1234start := time.Now() // start is a time.Timet, err := time.Parse(time.Kitchen, &quot;6:06PM&quot;) // t is a time.Timectx = context.WithTimeout(ctx, 10*time.Millisecond) // ctx is a context.Contextip, ok := userip.FromContext(ctx) // ip is a net.IP 在包中，一个名字为New的函数返回一个pkg.Pkg类型。这是使用该类型的客户代码的标准进入点： 1q := list.New() // q is a *list.List 当函数返回 pkg.T 类型的值时，其中 T 不是 Pkg ，函数名称可以包含 T 以生成客户端代码更容易理解。常见的情况是一个包有多个类似 New 的函数： 1234d, err := time.ParseDuration(&quot;10s&quot;) // d is a time.Durationelapsed := time.Since(start) // elapsed is a time.Durationticker := time.NewTicker(d) // ticker is a *time.Tickertimer := time.NewTimer(d) // timer is a *time.Timer 不同包中的类型可以具有相同的名称，因为从客户端的角度来看，这些名称是通过包名称来区分的。例如，标准库包含多种名为 Reader 的类型，包括 jpeg.Reader 、 bufio.Reader 和 csv.Reader 。每个包名称都适合 Reader 以产生良好的类型名称。 如果你想不出一个对于包内容来说有意义的包名前缀，那么包的抽象边界可能是有错误的。在编写代码时，考虑客户会如何使用这个包，如果考虑的结果很差就要及时重构。这种方法将产生更容易让客户理解、更容易让开发人员维护的包。 包路径Go包同时拥有名字和路径。名字是在其源代码的package语句中指定的，同时客户代码会用它作为包名导出的前缀。客户端代码导入包时，则使用包的路径。按照约定，包路径的最后一个元素就是包名。 123456import ( &quot;context&quot; // package context &quot;fmt&quot; // package fmt &quot;golang.org/x/time/rate&quot; // package rate &quot;os/exec&quot; // package exec) 构建工具会将包路径映射到目录上（这一段是关于Go老版本GOPATH的东西，略过）。 目录。标准库使用 crypto 、 container 、 encoding 和 image 等目录，对相关协议和算法的包进行分组。在这些目录中的包没有什么实际的关系。目录只是提供一种排列文件的方法。在不创建循环依赖的情况下，任何包都可以导入其他包。 此处我可以给出个人测试的案例。假设有这样一个路径和这样一段代码（这个包是go init demo）： .├── go.mod├── main.go└── abcdefg └── code.go 其中，code.go的定义是： 12345package afunc A() &#123; //do something&#125; 当你试图在main.go中使用这个包，你需要： 123456789package mainimport ( a &quot;demo/abcdefg&quot;)func main() &#123; a.A()&#125; 也就是说import使用的是路径，而package声明则代表了客户使用包的名字。约定中包名应该和路径最后的名字保持一致。如果没有，go fmt会自动在import语句前给你添上那个包名。 另外，一个目录里不能有多个不同的package声明。 另另外，package main是一个特殊的包名，标识程序入口点。如果没有package main，那么go run .无法运行，func main()也不会被识别。 正如不同包中的类型可以具有相同的名称而不会产生歧义一样，不同目录中的包也可以具有相同的名称。例如，runtime/pprof 以 pprof 分析工具期望的格式提供分析数据，而 net/http/pprof 则提供 HTTP 端点来以这种格式呈现分析数据。客户端代码使用包路径来导入包，因此不会出现混乱。如果源文件需要导入两个 pprof 包，它可以在本地重命名一个或两个包。重命名导入的包时，本地名称应遵循与包名称相同的准则（小写，没有下划线或驼峰 ）。 错误的包名错误的包名称会使代码更难导航和维护。以下是一些识别和修复不良名称的指南。 避免无意义的包名称。名为 util 、 common 或 misc 的包让客户端不知道包包含什么内容（天呐，这简直就是我）。这使得客户更难使用该包，也使得维护人员更难保持该包的重点。随着时间的推移，它们会积累依赖关系，从而使编译速度明显变慢，尤其是在大型程序中。由于此类包名称是通用的，因此它们更有可能与客户端代码导入的其他包发生冲突，从而迫使客户端发明名称来区分它们。 分解通用包。要修复此类包，请查找具有通用名称元素的类型和函数，并将它们拉入自己的包中。例如，如果有 123package utilfunc NewStringSet(...string) map[string]bool &#123;...&#125;func SortStringSet(map[string]bool) []string &#123;...&#125; 那么客户的代码就会看起来像 12set := util.NewStringSet(&quot;c&quot;, &quot;a&quot;, &quot;b&quot;)fmt.Println(util.SortStringSet(set)) 我们将这些函数从util提取到一个新的包并想一个合适的名字： 123package stringsetfunc New(...string) map[string]bool &#123;...&#125;func Sort(map[string]bool) []string &#123;...&#125; 这样客户端代码就会变成： 12set := stringset.New(&quot;c&quot;, &quot;a&quot;, &quot;b&quot;)fmt.Println(stringset.Sort(set)) 进行此更改后，可以更轻松地了解如何扩展增强这个新包： 1234package stringsettype Set map[string]boolfunc New(...string) Set &#123;...&#125;func (s Set) Sort() []string &#123;...&#125; 这样客户的代码就会更加简单： 12set := stringset.New(&quot;c&quot;, &quot;a&quot;, &quot;b&quot;)fmt.Println(set.Sort()) 包的名称是其设计的关键部分。应当努力从项目中消除无意义的包名称。 不要对你的所有API使用一个单独的包。许多善意的程序员将他们的程序公开的所有接口放入一个名为 api 、 types 或 interfaces 的包中，认为这样更容易找到入口点指向他们的代码库。这是个错误。此类包与那些名为 util 或 common 的包存在相同的问题，无限制地增长、不向用户提供指导、累积依赖项以及与其他导入发生冲突。将它们分解，也许使用目录将公共包与实现分开。 避免不必要的包名冲突。虽然不同目录中的包可能具有相同的名称，但经常一起使用的包应该具有不同的名称。这减少了混乱以及客户端代码中本地重命名的需要。出于同样的原因，请避免使用与 io 或 http 等流行标准包相同的名称。 结论包名称是 Go 程序中良好命名的核心。花时间选择好的包名称并组织好您的代码。这有助于客户理解和使用您的包，并帮助维护人员优雅地扩展它们。","categories":[{"name":"Note","slug":"Note","permalink":"https://n1vk.github.io/categories/Note/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://n1vk.github.io/tags/Golang/"}]},{"title":"Goroutines 的调度与并发控制","slug":"controlling-goroutines","date":"2024-04-08T14:38:56.000Z","updated":"2024-04-08T15:23:23.018Z","comments":true,"path":"Programming/controlling-goroutines/","link":"","permalink":"https://n1vk.github.io/Programming/controlling-goroutines/","excerpt":"Goroutine是如何调度的，如何在代码中操作其执行的顺序？","text":"GMP 模型GMP模型的原理不再多讲，处理器（P）通过维护自己的队列拿到需要执行的协程（G）并绑定到线程（M）。常见的GMP知识点不外乎全局队列，M0G0的知识，工作偷取和P遇到自旋M就解绑定并寻找新的M。 需要注意的一点是G，M与P的数量。G的数量理论上是无限的，但与程序自身的内存有关；P的数量是runtime.GOMAXPROCS控制的，注意这里是运行时宏；而M的数量就是操作系统相关的知识了，也同样受到资源的限制（题外话，进程数量受什么控制？）。 main, 等等我的 Goroutine我们知道 Go 的一切都是 Goroutine 在跑，那么我们的主函数实际上也是跑在一个 Goroutine 里的，只不过这个Goroutine比较特殊，被标记为main Goroutine（废话）。那么我们用户创建这些 Goroutine 何时退出呢？ 进程被 Kill / 进程崩溃 显然这个时候所有的 G 都会退出，毕竟系统资源都没了。 main函数结束 这个时候所有的 G 的资源也会被收回。 主动退出 正常执行完毕 / return / 使用 Context, 这个比较复杂之后特地讲 / panic（不要用） 然而main Goroutine 可不会在乎你创建的 G 是否执行完了。怎么确保我们创建的G能够执行完再让 main G退出呢？ channel对于一个比较简单的G，我们直接创建一个无缓冲区管道阻塞一下即可。 12345678910func main() &#123; ch := make(chan interface&#123;&#125;) go func() &#123; time.Sleep(5 * time.Second) ch &lt;- &quot;Done&quot; &#125;() data := &lt;-ch&#125; 显然这种办法比较低级，如果我需要开启不定数量的 G，这种办法就不好用了（吗？实际上开一个有缓冲区的channel也可以，而且能控制同时运行的 G 的数量）。 sync.Waitgroup这是官方给我们用来控制并发流程的。 12345678910111213141516171819import &quot;sync&quot;func main() &#123; var wg sync.WaitGroup // 声明这个结构, 如果要传到函数里记得指针 // wg.Add(100) Add其实就是要执行的任务数量，直接在这加也行 for i := 0; i &lt; 100; i++ &#123; wg.Add(1) go func() &#123; // [注意] wg.Add(1) 不能写在这，写了 linter 也会报错的 // 因为可能当前还没有 wg.Add(1), wg.Wait() 的逻辑已经通过了 // 函数逻辑 wg.Done() // 做好了 &#125;() &#125; wg.Wait() // 等待结束&#125; Goroutine 更详细的顺序运行一下这段代码： 123456789101112func main() &#123; runtime.GOMAXPROCS(1) for i := 0; i &lt; 10; i++ &#123; i := i go func() &#123; fmt.Println(i) &#125;() &#125; var ch = make(chan int) &lt;- ch // 这里阻塞会 fatal error, 因为死锁了&#125; 我们控制P的数量是1，并看似从0到9创建了一堆G。但实际上，程序的输出是： 123456789109012345678 哇，太棒了。为什么会这样？这就必须讲一下 GMP 模型中的三个队列了。 三个队列每个P所拥有的队列大概是这样：runnext，local。以及程序本身有一个global。 每次创建G的时候，G会首先抢占 runnext。这确保了如果有很多P的话，G会被优先执行，不会有空闲的P，这太浪费资源了。runnext只有一个空位，从名字也能看懂这是P要绑定给M的那个G。但如果有一个新来的G呢？old G就会被new G挤走，到local队列的末尾，下一个调用。这也是为了每个G都能被执行。 local队列最长256，是一个环形队列，头尾指针控制。如果这玩意也满了G就会去global。当然如果空了就会偷取，不再多谈。 因此这样输出什么情况就很明显了，因为IO操作很慢，因此最后出现的G也就是9抢占了runnext进行执行，而剩下的G则以0～8的方式从local中取出来执行，就有了上面的输出。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://n1vk.github.io/categories/Programming/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://n1vk.github.io/tags/Golang/"},{"name":"后端","slug":"后端","permalink":"https://n1vk.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Goroutine","slug":"Goroutine","permalink":"https://n1vk.github.io/tags/Goroutine/"}]},{"title":"基于Golang的后端高性能框架 —— Gin","slug":"learn-gin","date":"2023-02-27T12:28:19.000Z","updated":"2024-04-09T03:02:43.365Z","comments":true,"path":"Programming/learn-gin/","link":"","permalink":"https://n1vk.github.io/Programming/learn-gin/","excerpt":"Gin的基本用法和值得记录的原理。","text":"使用 Gin使用 Gin 框架的基本方法可以展示为下面这段代码： 1234567891011121314func main() &#123; r := gin.Default() serveRoute := func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;hello world&quot; &#125;) &#125; r.GET(&quot;/hi&quot;, serveRoute) r.Run()&#125; r是一个使用默认值实例化了的gin.Engine。该引擎用于管理所有HTTP请求，接受路由注册等。serveRoute是一个用于处理路由的函数，其参数必须为一个*gin.Context。接下来向引擎的特定请求和路由路径注册这个处理函数。最终，我们让引擎进行默认监听（局域网地址，8080端口）。这就启动了一个Web服务。 在内部，引擎对于每一个到来的请求分配一个对应的gin.Context，将这个上下文传入我们的自定义函数。在原理部分再详细展开相关内容。 路由组和动态路由（还没写） Middleware（还没写） Gin 原理 - Engine 部分gin.Default()做了什么？我们参考一下Gin的源代码中的gin.go： （有句吐槽不说不快，感觉这源代码目录结构也太随意了。而且同一个包下的不同文件实际上都是共享上下文的，导致某个文件里声明的类型大概率是另一个文件里的某处冒出来的，如果不用IDE看源代码真是头大） 1234567// Default returns an Engine instance with the Logger and Recovery middleware already attached.func Default() *Engine &#123; debugPrintWARNINGDefault() engine := New() engine.Use(Logger(), Recovery()) return engine&#125; 实际上其使用了New()，并默认使用了两个中间件Logger(), Recovery()。那我们紧接着去看New()的实现： 123456789101112131415161718192021222324252627func New() *Engine &#123; debugPrintWARNINGNew() engine := &amp;Engine&#123; RouterGroup: RouterGroup&#123; Handlers: nil, basePath: &quot;/&quot;, root: true, &#125;, FuncMap: template.FuncMap&#123;&#125;, RedirectTrailingSlash: true, RedirectFixedPath: false, HandleMethodNotAllowed: false, ForwardedByClientIP: true, AppEngine: defaultAppEngine, UseRawPath: false, UnescapePathValues: true, MaxMultipartMemory: defaultMultipartMemory, trees: make(methodTrees, 0, 9), delims: render.Delims&#123;Left: &quot;&#123;&#123;&quot;, Right: &quot;&#125;&#125;&quot;&#125;, secureJsonPrefix: &quot;while(1);&quot;, &#125; engine.RouterGroup.engine = engine engine.pool.New = func() interface&#123;&#125; &#123; return engine.allocateContext() &#125; return engine&#125; 我们先不考虑默认引擎使用的中间件，而研究一下Run()方法是如何实现的： 12345678func (engine *Engine) Run(addr ...string) (err error) &#123; defer func() &#123; debugPrintError(err) &#125;() address := resolveAddress(addr) debugPrint(&quot;Listening and serving HTTP on %s\\n&quot;, address) err = http.ListenAndServe(address, engine) return&#125; 使用了 net/http 的 ListenAndServe()。那么引擎必须实现 net/http 的接口 ServeHTTP。我们再回到源码里寻找一下： 12345678910func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123; c := engine.pool.Get().(*Context) c.writermem.reset(w) c.Request = req c.reset() engine.handleHTTPRequest(c) engine.pool.Put(c)&#125; 这个处理流程很明确了，首先从pool中获得一个gin.Context，给这个上下文赋值我们后面再看，放到handleHTTPRequest()里面，处理完毕之后再放回池子回收。那这个方法又具体做了些什么？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950func (engine *Engine) handleHTTPRequest(c *Context) &#123; httpMethod := c.Request.Method path := c.Request.URL.Path unescape := false if engine.UseRawPath &amp;&amp; len(c.Request.URL.RawPath) &gt; 0 &#123; path = c.Request.URL.RawPath unescape = engine.UnescapePathValues &#125; // Find root of the tree for the given HTTP method t := engine.trees for i, tl := 0, len(t); i &lt; tl; i++ &#123; if t[i].method == httpMethod &#123; root := t[i].root // Find route in tree handlers, params, tsr := root.getValue(path, c.Params, unescape) if handlers != nil &#123; c.handlers = handlers c.Params = params c.Next() c.writermem.WriteHeaderNow() return &#125; if httpMethod != &quot;CONNECT&quot; &amp;&amp; path != &quot;/&quot; &#123; if tsr &amp;&amp; engine.RedirectTrailingSlash &#123; redirectTrailingSlash(c) return &#125; if engine.RedirectFixedPath &amp;&amp; redirectFixedPath(c, root, engine.RedirectFixedPath) &#123; return &#125; &#125; break &#125; &#125; if engine.HandleMethodNotAllowed &#123; for _, tree := range engine.trees &#123; if tree.method != httpMethod &#123; if handlers, _, _ := tree.root.getValue(path, nil, unescape); handlers != nil &#123; c.handlers = engine.allNoMethod serveError(c, 405, default405Body) return &#125; &#125; &#125; &#125; c.handlers = engine.allNoRoute serveError(c, 404, default404Body)&#125; 使用语法树进行匹配。核心逻辑是如果成功，那么去c.Next()。我们接下来有必要看看上下文的源代码了。 但在这之前，引擎结构体的成员还有些值得注意的点，我们浅浅分开看一看。 RouterGroup显然这个是用来处理路由的，可以看到RouterGroup结构中存在着Handlers，这些应该就是中间件和处理方法存放的地方。看看routergroup.go中的定义： 12345678// RouterGroup is used internally to configure router, a RouterGroup is associated with// a prefix and an array of handlers (middleware).type RouterGroup struct &#123; Handlers HandlersChain basePath string engine *Engine root bool&#125; 上面的注释已经讲很清楚了，HandlersChain就是一个放着中间件的数组。basePath则是代表这个路由组的基础地址。在注册路由时，我们会传入新的相对地址。路由的实际地址是根据这两个地址的结合算出来的。 为什么要持有对引擎的引用？Use(),GET()等方法都调用了handle()这个没有暴露的方法，我们看一下这个方法的实现： 123456func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes &#123; absolutePath := group.calculateAbsolutePath(relativePath) handlers = group.combineHandlers(handlers) group.engine.addRoute(httpMethod, absolutePath, handlers) return group.returnObj()&#125; 也就是说我们在当前路由组中注册了中间件，并引擎中注册了路径。非常合理。请注意注册路径的时候传递的参数，也就是http方法 / 绝对路径 / HandlersChain的值类型。那么我们可以猜到语法树存放的K-V逻辑是路径-方法列表。 关于返回值类型IRoutes我觉得也有必要看一看。 1234567891011121314151617181920212223242526// IRouter defines all router handle interface includes single and group router.type IRouter interface &#123; IRoutes Group(string, ...HandlerFunc) *RouterGroup&#125;// IRoutes defines all router handle interface.type IRoutes interface &#123; Use(...HandlerFunc) IRoutes Handle(string, string, ...HandlerFunc) IRoutes Any(string, ...HandlerFunc) IRoutes GET(string, ...HandlerFunc) IRoutes POST(string, ...HandlerFunc) IRoutes DELETE(string, ...HandlerFunc) IRoutes PATCH(string, ...HandlerFunc) IRoutes PUT(string, ...HandlerFunc) IRoutes OPTIONS(string, ...HandlerFunc) IRoutes HEAD(string, ...HandlerFunc) IRoutes Match([]string, string, ...HandlerFunc) IRoutes StaticFile(string, string) IRoutes StaticFileFS(string, string, http.FileSystem) IRoutes Static(string, string) IRoutes StaticFS(string, http.FileSystem) IRoutes&#125; 没什么特别的，就是路由类型的接口。 trees字典树，路由的处理就放在这里了。它的类型是methodTrees。我们转去tree.go看他的实现。 123456type methodTree struct &#123; method string root *node&#125;type methodTrees []methodTree 结合之前引擎匹配路径的原理不难猜出，引擎实际上为每种不同的HTTP请求方式维护了一个Trie树。接下来就是这个数据结构的具体实现了。 (有空再写) pool此处使用了 Go 包 sync/pool实现了上下文池。这是一个为了减少GC而设计的对象池，其是可伸缩、线程安全的。它的目的是存放分配但暂时不用的对象，在需要的时候直接拿出来。我们现在只需要知道这些，具体的原理感觉之后需要详细了解一下sync包。 Gin 原理 - Context 部分Context是Gin中的重要的一部分，它承担了在中间件间传递信息，控制流，验证JSON和快速返回请求的一些功能。这种设计方法也就是责任链模式的体现。 12345678910111213141516171819202122232425262728293031323334353637type Context struct &#123; writermem responseWriter Request *http.Request Writer ResponseWriter Params Params handlers HandlersChain index int8 fullPath string engine *Engine params *Params skippedNodes *[]skippedNode // This mutex protects Keys map. mu sync.RWMutex // Keys is a key/value pair exclusively for the context of each request. Keys map[string]any // Errors is a list of errors attached to all the handlers/middlewares who used this context. Errors errorMsgs // Accepted defines a list of manually accepted formats for content negotiation. Accepted []string // queryCache caches the query result from c.Request.URL.Query(). queryCache url.Values // formCache caches c.Request.PostForm, which contains the parsed form data from POST, PATCH, // or PUT body parameters. formCache url.Values // SameSite allows a server to define a cookie attribute making it impossible for // the browser to send this cookie along with cross-site requests. sameSite http.SameSite&#125; 其中的index和handlers就是Next()方法执行的关键。这个方法的实现很简单： 1234567func (c *Context) Next() &#123; c.index++ for c.index &lt; int8(len(c.handlers)) &#123; c.handlers[c.index](c) c.index++ &#125;&#125; 让index在所有方法上不停的移动，并将自身传入对应的方法中进行执行。我们方法中常用的一些Context提供的功能可以浅浅看一看。 Set 和 Get使用到了Context的RWMutex和Keys这两个参数。很简单地对map进行上锁，读取再解锁。可以预料到如果用这个的话应该会影响性能。但Golang的map实现要求必须上锁，否则必定fatal error。 BindXX 和 ShouldBindXX（Gin终于舍得给binding单独写个Package了，但是代码好多，有空再看） AbortAbort的操作把index设置为abortIndex。这个行为一般在某个Handler末尾前执行，并让Context不执行接下来的handlers。也就是说你可以在某个中间件截断这次请求。那么abortIndex是啥呢？ 12// abortIndex represents a typical value used in abort functions.const abortIndex int8 = math.MaxInt8 &gt;&gt; 1 再浅说一下怎么简单记忆位移运算符： 12n &lt;&lt; m (n times 2 for m times)y &gt;&gt; x (y divided by 2 for x times)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://n1vk.github.io/categories/Programming/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://n1vk.github.io/tags/Golang/"},{"name":"后端","slug":"后端","permalink":"https://n1vk.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Gin","slug":"Gin","permalink":"https://n1vk.github.io/tags/Gin/"}]},{"title":"浅浅区分一下分类网和网络地址转换","slug":"subnets-and-nat","date":"2022-05-25T13:05:25.000Z","updated":"2024-04-08T15:33:19.752Z","comments":true,"path":"Note/subnets-and-nat/","link":"","permalink":"https://n1vk.github.io/Note/subnets-and-nat/","excerpt":"打开我自己购买的路由器，连接我的设备。我所在的这个网络应该叫子网，还是私网（专用网）？如果已经有子网掩码来为网络分类，我们为什么还需要网络类型转换（NAT）？一番调查之后，我想梳理清楚这个小问题。","text":"在最初学习计算机网络的时候，我首先学习了IPv4编址方式，紧接着学习了子网，CIDR，路由聚合，IP地址获取与NAT。但在思考和与朋友讨论的过程中，我发现我混淆了一些概念。因此我做了一些调查，在这篇笔记中按顺序梳理这几个概念，这个顺序也是互联网IP协议发展所采取的顺序。 路由器和网关首先我们明确，这些设备全部都是用来调控网络流量的。那么，简单一点来说： 路由器在相同的网络中转发数据。路由器本身将会存储一个查找表。对于接受的数据包，路由器检查数据包内的数据是发给谁的，根据自己的查找表传递给下一台路由器/主机。网络中的数据包就是这样，经过多次跳跃，从一个主机到达另一个主机的。 网关在不同的网络中传递数据。如果两个网络使用了不同的网络协议，那么我们就需要网关为我们做协议转换。最常见的就是我们接下来要讲的NAT。 路由器和网关是可以重叠的。一个设备，可以既做数据包在同协议网络间的转发，又为网络间通信转换网络协议，此时他就是一个路由器和一个网关。 除此之外，还有一些互联网设备的概念，诸如交换机，接入点（AP），调制解调器（MODEM）等，因为对于理解本篇文章不重要，就不展开讲了。 子网与子网掩码教科书上说，网络被分配到的一个IP地址由网络地址和子网掩码组成。IP地址由四段八比特二进制数组成，也可以写成点分的十进位形式。而子网掩码，其高比特位标志了该子网的地址，而低比特位标志了主机在子网中的地址。IP地址后用一个斜杠加一个数字，表示其前多少位是网络地址。我们举个例子。 IP地址12345十进制网络地址 192.168.1.100/24二进制网络地址 11000000 10101000 00000001 01100100十进制子网掩码 255.255.255.0二进制子网掩码 11111111 11111111 11111111 00000000 IPv4协议是在1982年提出的，最开始的32位IPv4只用前8位确定网络地址，即主机连接到哪个网络，以及剩下的部分作为主机地址。这样的分类方式不能允许太多的独立网络。 为什么需要区分一个网络地址和一个主机地址？我的理解是，这实际上是为了控制网络的边界，方便管理与路由器寻址。假设不区分子网，那么路由器需要维护的查找表将会非常庞大，需要将IP地址的每一位都记录下来，并且计算保存最近距离的路由器。如果区分了子网，那么路由器只需要存储以哪些字段开头的数据发给某个路由器即可。 而伴随其提出的是如何为子网划分地址的模式。最开始，人们选择了比较简单的分级式寻址。网络被分为ABCDE五个类，不同的类使用他们的前三位来识别： A类地址，第一位是0，使用前8位作为网络位，剩下的作为主机位，A类地址可以构建出 128 个网络，每个网络容纳 16,777,214 个主机。 B类地址，前两位是10，使用前16位作为网络位，剩下的作为主机位，B类地址可以构建出 16,384 个网络，每个网络容纳 65,534 个主机。 C类地址，前三位是110，使用前24位作为网络位，剩下的作为主机位，B类地址可以构建出 2,097,152 个网络，每个网络容纳 254 个主机。 D类群播地址，前四位是1110；和E类保留地址，前四位是1111。 实际上，这种分类模式就没有必要说明子网掩码，因为你总是可以从前n位推断出其子网掩码应该是多少。这种分类模式现在已经被废止，因为其立刻展现出了问题：对于一个小型网，C类地址的主机容量太小，B类地址又太大。 无类别区域间路由（CIDR）和路由聚合为了解决刚刚提到的问题，我们使用CIDR。原理很简单，我们将IP地址重新设定为 a.b.c.d/x，x代表了IP地址的网络号，可以为任意值。这样我们就可以在灵活分配子网大小的同时，简化我们路由保存的转发表。 在实践中，我们就得到了路由聚合的概念。我们的路由器只需要保存开头x位的某个IP地址应当转发给哪个子网，而不需要关心子网内数据包是如何传递的。可能在子网内存在其他子网，但是发包的路由器并不关心。这种情况我们就称作路由聚合。 顺便一提，某些IP地址是协议规定的保留地址。比如127.0.0.1 (01111111 00000000 00000000 00000001) 是环回地址，也就是当前所在的主机，也叫做 localhost，实际上环回地址有 1,600,000 以上个，从127.0.0.1到127.255.255.255均为环回地址。 255.255.255.255是广播地址，向广播地址交付报文会让该报文被发送到该子网内的每个主机。当然，这是路由器的转发表保存的数据决定的，路由器在收到目的地是255.255.255.255地址的数据包之后，它会向它子网内的所有主机发该数据包。 IP地址获取我们已经做好了如何给IP地址分类，接下来简单讲一下IP地址是如何获取的。最简单的是由你的互联网服务提供商（ISP）提供，ISP自己有一个地址段，而后他可以将地址段划分为子网并交付给用户。如下例子（尖括号的部分是主机号，而中括号的部分是子组织相较于ISP地址增加的网络号）： ISP分配1234567ISP得到的地址 200.23.16.0/20 11001000 00010111 0001&lt;0000 00000000&gt;组织A 200.23.16.0/23 11001000 00010111 0001[000]&lt;0 00000000&gt;组织B 200.23.18.0/23 11001000 00010111 0001[001]&lt;0 00000000&gt;...组织G 200.23.30.0/23 11001000 00010111 0001[111]&lt;0 00000000&gt; 那么ISP的地址从哪儿来？答案是因特网名字和编号分配机构（ICANN）。ICANN是非营利组织，其不仅分配IP地址，也管理DNS根服务器，分配域名。 当然，还有一种方法，通常用于比较小的子网，就是动态主机配置协议（DHCP）。主机每次连接到配置了DHCP的网络，都会获得一个临时的IP地址。除此之外，主机还可以得到当前子网的子网掩码，第一跳路由地址（我们现在一般叫做默认网关），本地DNS服务器地址。现在打开你的手机，进入网络设置并查看连接的无线局域网信息，你就可以看到这些内容。连接学校的局域网，学校也会提前告知你要使用DHCP。 网络地址转换（NAT）需要意识到的是，以上我们所有的工作都不过是在给我们的 4,294,967,296 个IP地址做分类，这也是我错误思想的来源。 子网并不代表整个网络中的某两台主机可以分配相同的IP地址。想象一个身份证号或者手机号，其内容是不能重复的，对其不同段做分类只是为了方便罢了。即使是划分了子网，不同子网间的IP地址也必须是不同的。这实际上很好理解，如果他们相同，那路由算法将会被破坏。路由器不知道应该向谁发包，或者总有一个主机收不到包，因为路由表在较短的网络号处截断并转发（想象路由器发送所有212.144.*.*到路由器A，路由器A是212.144.1.1/12，而路由器B是212.144.1.1/16）。 为了解决IP枯竭问题，人们从1993年开始使用了NAT技术，并通过RFC 1918协议定义了一部分IP地址使其专门用于NAT网络内部地址分配。这样的网络叫做专用网或者私有网。以下是RFC 1918规定的IP块： RFC 19181234规定区块名 IP地址区块 IP数量 24位区块 10.0.0.0 – 10.255.255.255 16,777,216 20位区块 172.16.0.0 – 172.31.255.255 1,048,576 16位区块 192.168.0.0 – 192.168.255.255 65,536 专用网通过网关来完成地址转换。我们现在自己使用的，提供无线局域网连接服务的路由器都做了NAT地址转换，因此提供WiFi的路由器也就是该私有网的网关。拿我自己的路由器为例，在私有网，其IP地址是192.168.1.1，访问该地址也会进入路由器的管理界面。我的所有设备的网关都是192.168.1.1，每个设备通过DHCP获得自己在私有网络的地址，将数据包交给网关做转发。而查看路由器自己的设置，可以看到路由器在外部网络的地址是172.26.55.113，也是通过DHCP获得IP地址。根据RFC 1918，这个地址仍然是一个私有地址。实际上，这是大学校园私有网络的地址。并且，路由器的网关是172.26.0.1，这就是大学校园私有网络的流量出口。在此处，校园网私网地址被翻译成更高一级的公网地址进行通信。 私有网络必须要有不同于公网的IP，因为如果出现了公网IP，那么当一个主机要发给此IP时，网关的路由就不确定这个数据包到底是要给私网内的主机，还是转发出去。 那么，通信是如何完成的？以网络地址端口转换（NAPT）为例，假设现在的网络是我的路由器创建的私有网，从我的手机(192.168.1.101)发送的数据，到达网关(192.168.1.1)后，网关会将其转为(172.26.55.113:Port)，再发往下一级路由。这样一层一层包裹，数据包能够最终到达公网。同样的，接收的数据会被网关根据端口号一层一层地解开，到学校局域网的一层时，学校网关(172.26.0.1)将会收到一个发往172.26.55.113:Port的包，那么学校网关将会把包路由到172.26.55.113，我的路由器则会根据Port将数据包路由回我的手机。 当然，如果私网内的某个IP用了两个端口，那么网关也会为其映射两个到外部的端口，以便进行通信。 NAT的好处在于，私网内的用户非常安全。如果不主动发送信息，那么公网将无法与其进行通信。而坏处是，NAT下的主机实际上没有真正的IP地址，不能参与某些网络协议，比如某些必须从外部建立的UDP协议。举例来说，任天堂说我的NAT类型是D不让我玩联机游戏。 结论子网和私网不是一个概念。不过，路由器创建的网络仍然可以被称作一个子网，只不过这个子网并不属于一个大的互联网。如果要谈论获取公网IP，实际上我们谈论的是一个跳出NAT的过程。比较常用的是端口映射，也就是说我将私网内的IP固定映射到网关的公网地址的某个端口上去，这样其他用户就可以通过访问网关公网IP:Port来进行通信。当然，这样的方法似乎只能跳出一层NAT。","categories":[{"name":"Note","slug":"Note","permalink":"https://n1vk.github.io/categories/Note/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://n1vk.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"cat"},{"title":"构造玩具版 Java 虚拟机 - 软件工程课程作业 Lab1","slug":"vjvm-lab1","date":"2022-05-10T06:02:27.000Z","updated":"2024-04-08T14:46:25.742Z","comments":true,"path":"Programming/vjvm-lab1/","link":"","permalink":"https://n1vk.github.io/Programming/vjvm-lab1/","excerpt":"本文章系列介绍软件工程与计算一(SEC-I)课程大作业，其最终目标是实现一个可以运行Java程序的JVM。在第一个Lab中，我们将会阅读框架代码，了解Java字节码并将数据读入我们的程序。","text":"Java 代码以类为基础。在编译时，每个类都会生成一个.class文件，其中用16进制字节码保存了JVM运行程序需要的各种信息。虚拟机读取信息，就可以执行程序。根据这个原理，我们可以用 Java 写一个 Java 虚拟机，这真是太有趣了（棒读）。 本程序使用 OpenJDK 1.8，使用 Gradle 构建并使用了 lombok 插件。如果使用IDEA，请在手动在项目设置里修改为 OpenJDK 1.8；提到的 lombok 插件非常便利，在自己编写程序时也有多次用到，比如最简单的应用是可以在抛出异常的地方写一个 @SneakyThrow，这样程序员就不用麻烦的为一个自己无法处理的异常写一个 try-catch 包裹了。 Java 字节码在一切开始之前，我们需要先了解 Java 字节码的结构。你可以用任何16进制编辑器查看.class文件，或者你可以使用javap $&#123;target&#125; -verbose来用人类可以读懂的方式查看其内容。下图展示了.class文件顺序排列的结构。一个固定长度的小块块代表了一个 Byte。 字节码结构示意图 魔数和版本号最开始的魔数 0xCAFEBABE，或者 3405691582 (int)，标志着这是一个 Java 虚拟机可运行的字节码文件，真是独特（Cafe Babe = 看板娘？）。接下来两个 short 存储了编译的副、主版本号。JVM在执行的时候也会检查自己能否运行该版本号的字节码。 常量池首先，常量池计数器占用一个 short。它记录了 cp_info 即常量池项的个数，注意到常量池计数器是从1开始的，所以常量池项将会有constant_pool_count - 1个，因为偶尔会需要有一个引用“不指向任何常量”，即索引0。又注意到计数器因为是16比特存储，因此常量个数不能超过65534个（如果你在一个类里面写了这么多常量，那你应该思考一下设计模式）。 随其后的是不定长度的常量池数据区。如果它不定长度，那么我们如何读取呢？请打开我们的手册并翻到4.4节常量池（在78页）。我们可以看到，每个 cp_info 的结构是： cp_info1234cp_info &#123; u1 tag; u1 info[];&#125; 根据一个字节的类型标记，我们可以info[]到底是什么。比如，一个CONSTANT_Utf8_info结构，即字面常量结构在4.4.7被介绍，其结构如下： CONSTANT_Utf8_info12345CONSTANT_Utf8_info &#123; u1 tag; u2 length; u1 bytes[length];&#125; 根据这个原理，我们每次首先判断其是什么类型，再按照类型读取数据。建议随便写一个程序，然后利用javap观察一下，看看它存放了什么字面数据，别的数据又是如何被存放的。 访问标志访问标志就是你在程序里写的public, private, final, abstract等等。其具有两个字节，并且其是一个掩码结构。我们暂且不需要知道所有的访问标志都是什么，只需要知道计算这块区域的方式是将所有的访问标志求和即可，举例来说，假如有一个公开接口，其具有的访问标志有PUBLIC的值是0x0001，INTERFACE的值是0x0200，那么访问标志就是0x0201。 类索引与父类索引这里的类索引和父类索引都分别占有两个字节，存储一个指向常量池中CONSTANT_Class_info的索引。 接口首先具有接口数量信息，接着有该数量个接口数据信息。注意接口数据信息只是一个两字节的，指向常量池中CONSTANT_Class_info的索引。 字段与方法字段和方法相当类似，其开头都会有一个计数器，而后跟随一串数据，这些数据拥有这样的结构： field_info1234567field_info &#123; u2 access_flags; u2 name_index; u2 descriptor_index; u2 attributes_count; attribute_info attributes[attributes_count];&#125; method_info也是一模一样的。我们可以看到一个字段或方法拥有访问标志，具有其名字和描述符索引，属性计数器和属性等。 我们必须注意到的是，这个结构中也具有“属性”这个结构，即attribute_info的数组。也就是说字段、方法和类文件都具有属性。实际上，方法是如何被执行的，即JVM的字节操作码就记录在method_info里的attribute_info的数组内，并且其具体的attribute_info类型是Code。 属性我们暂时不需要关心属性(attribute)的部分，但是我还是把其结构表示出来： attribute_info12345attribute_info &#123; u2 attribute_name_index; u4 attribute_length; u1 info[attribute_length];&#125; 在写代码的时候会用到，并且之后实现真正运行程序的时候也是必要的。除了上面提到的Code属性以外，还存在常量ConstantValue，异常Exception等等。 程序框架在 VJVM 项目的src目录中存放了所有的程序源代码，我们可以先观察一下其结构。不需要关心的部分被我去掉了。 Source File Tree123456789101112131415161718192021222324252627282930src├── main│ └── java│ └── vjvm│ ├── classfiledefs│ │ ├── ...│ ├── classloader│ │ ├── JClassLoader.java│ │ └── searchpath│ │ ├── ClassSearchPath.java│ │ └── ModuleSearchPath.java│ ├── runtime│ │ ├── JClass.java│ │ └── classdata│ │ ├── ConstantPool.java│ │ ├── FieldInfo.java│ │ ├── MethodInfo.java│ │ ├── attribute│ │ │ ├── ...│ │ └── constant│ │ ├── ClassConstant.java│ │ ├── ...│ │ └── UnknownConstant.java│ ├── utils│ │ └── UnimplementedError.java│ └── vm│ ├── Main.java│ └── VMContext.java└── test └── ... 我们首先从目录main/java/vjvm/vm看起。这里有程序的入口，我们可以暂不关心。构造 VJVM 的程序员使用了 lombok 来简化程序的使用，我们可以理解为编译好程序运行后为其提供一些参数，由程序入口来处理。接下来 VMContext 就是接收查找目录并生成类加载器实例。 所以，我们来看main/java/vjvm/classloader，即类加载器。我们可以看到该目录下还有一个searchpath，我们合理的推测其是类加载器的成员。因为我们可能到运行时才知道我们需要从何处，比如文件内或是jar包内，或者是其他情况。因此需要动态绑定，面向接口编程。 JClassLoader 在对应路径加载到编译好的类文件后，其用得到的文件，根据代码实际内容来看是 DataInputStream 类型，即二进制数据流，和其本身创建一个 JClass。这带领我们来到main/java/vjvm/classdata目录。在这里我们需要实现读取一个类的内容。根据之前字节码的介绍，比较棘手的是常量池，字段方法属性信息等等。 其他有省略号的文件均不是本次 Lab 需要考虑的内容。 构造查找类文件的代码如果我们想要读取.class文件内容，首先该找到.class文件在哪里。 类加载类我们首先来阅读一下框架给出的JClassLoader。 JClassLoader.java1234567891011121314151617181920public class JClassLoader implements Closeable &#123; private final JClassLoader parent; private final ClassSearchPath[] searchPaths; private final HashMap&lt;String, JClass&gt; definedClass = new HashMap&lt;&gt;(); // Stores its creator private final VMContext context; // constructor // ... public JClass loadClass(String descriptor) &#123; // 以下的代码在这里 &#125; @Override @SneakyThrows public void close() &#123; // ... &#125; 首先看属性，它具有一个同类型的parent，一个搜索路径列表和一个描述符对应JClass的的哈希表。 我们要知道Java加载类通过使用Parent-First优先策略，一个Loader得到一个路径，首先会交给父Loader查找，如果找不到再自己进行查找。而查找的路径就是ClassSearchPath。接下来完成loadClass()方法。 我们首先对类名字和路径做一下处理。Java类描述符大概长这样：Ljava/lang/Object;。如果换为路径，就是java/lang/Object，再用点更换斜杠，就得到了类名。 12String dir = descriptor.substring(1, descriptor.length() - 1);String name = descriptor.substring(1, descriptor.length() - 1).replace(&quot;/&quot;, &quot;.&quot;); 接下来看一下是否已经加载过，并丢给双亲加载： 12345if (this.definedClass.containsKey(name)) &#123; return this.definedClass.get(name); &#125; else if (this.parent != null) &#123; parentFoundClass = this.parent.loadClass(descriptor); &#125; 如果双亲找到了，就返回双亲的。否则，自己去找。 1234567891011121314if (parentFoundClass == null) &#123; for(ClassSearchPath p : this.searchPaths) &#123; if(p.findClass(dir) != null) &#123; JClass tmp = new JClass(new DataInputStream(p.findClass(dir)), this); this.definedClass.put(name, tmp); return tmp; &#125; &#125; return null;&#125; else &#123; return parentFoundClass;&#125; 这一段代码其实涉及到一个风格问题。几天前看过的一个视频中提到，应该尽量少在代码中使用Else，这样可以减少嵌套。因此，我们这样修改一下： 123456789101112if (parentFoundClass != null) &#123; return parentFoundClass; &#125;for(ClassSearchPath p : this.searchPaths) &#123; // 这里的findClass方法将在后面提到 if(p.findClass(dir) != null) &#123; JClass tmp = new JClass(new DataInputStream(p.findClass(dir)), this); this.definedClass.put(name, tmp); return tmp; &#125;&#125;return null; 通过把最开始的判等换为判不等，我们得到了一个守卫语句（Guard Clause）。这是在代码中减少使用嵌套的好办法。 类加载路径类我们这样并没有完成构造，因为我们没有完成ClassSearchPath。在这里使用多态的原因是，我们的类可能来自于一个路径，也可能来自一个Jar包；在未来，可能有更多不同的路径。 我们在ClassSearchPath中有一个静态方法。通过调用这个静态方法，我们可以在不实例化任何类的时候，根据参数构建多个SearchPath。这是一个工厂模式的设计实例。 ClassSearchPath内部方法123456789101112131415161718192021public static ClassSearchPath[] constructSearchPath(String path) &#123; String sep = System.getProperty(&quot;path.separator&quot;); // Split the path to array String[] pathArray = path.split(sep); ClassSearchPath[] tmp = new ClassSearchPath[pathArray.length]; // Implement different class for different path for(int i = 0; i &lt; pathArray.length; ++i) &#123; if(pathArray[i].endsWith(&quot;.jar&quot;))&#123; tmp[i] = new JarSearchPath(pathArray[i]); &#125; else &#123; tmp[i] = new DirSearchPath(pathArray[i]); &#125; &#125; return tmp;&#125;public abstract InputStream findClass(String name); 而我们每一个具体的SearchPath都要override父类的findClass()方法，拿路径搜索举例： DirSearchPath内部方法1234567891011121314151617private final String searchDir;public DirSearchPath(String dir) &#123; this.searchDir = dir;&#125;@Overridepublic InputStream findClass(String dir) &#123; String fileDir = this.searchDir + System.getProperty(&quot;file.separator&quot;) + dir + &quot;.class&quot;; // Open it directly try &#123; return new FileInputStream(fileDir); &#125; catch (FileNotFoundException e) &#123; return null; &#125;&#125; 构造读取字节码内容的代码待更新。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://n1vk.github.io/categories/Programming/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://n1vk.github.io/tags/Java/"},{"name":"面向对象","slug":"面向对象","permalink":"https://n1vk.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"Java Virtual Machine","slug":"Java-Virtual-Machine","permalink":"https://n1vk.github.io/tags/Java-Virtual-Machine/"}]},{"title":"设计模式：观察者模式与装饰者模式","slug":"design-pattern-1","date":"2022-04-15T09:18:03.000Z","updated":"2024-04-08T14:46:58.594Z","comments":true,"path":"Programming/design-pattern-1/","link":"","permalink":"https://n1vk.github.io/Programming/design-pattern-1/","excerpt":"学习 Head First Design Pattern 的第二部分的内容包括观察者(Observer)模式和装饰者(Decorator)模式。","text":"通过自己举出的一些设计例子，配合代码，学习观察者模式和装饰者模式。这篇文章包含了两个不相关的内容，分别对应书上两个不同的章节。 观察者模式假设目前我们有一位教务处老师，这位老师希望同学们帮他制作一个电子公告栏。亲切的教务处老师送给我们一段源码。 ManagementSys类123456789101112public class ManagementSys &#123; private String courseName; private String courseSchedule; // ... public String getCourseName(); public String getCourseSchedule(); // ... public void setInfo(); public void infoChanged();&#125; 教务处老师给出了获得课程信息，课程时间，授课老师等等一系列的getter方法。而且，每次老师获得新信息之后，都会调用一个infoChanged()方法。我们不需要在意getter的具体实现，只需要根据信息写电子版程序即可。我们很容易得到思路，首先，我定义一个可以显示内容的公告栏类，比如说开课栏目公告栏、开课时间公告栏等等，再为公告栏类增加update()方法来更新内容，因此… infoChanged()方法实现12345678910public void infoChanged() &#123; String courseName = getCourseName(); String courseSchedule = getCourseSchedule(); // ... courseAvailableDisplay.update(courseName, ...); courseScheduleDisplay.update(courseSchedule, ...); // ...&#125; 这应该是大部分人直觉中的方法，至少是我的。但是，这违反了我们曾经学习的设计原则。首先，我们没有封装变化的部分，大家的update()至少在形式上是一致的，应该被封装起来；其次，我们现在面向实现编程，也就是说，我们把infoChanged()将会更新哪些公告板写死在代码中。如果我们未来想要添加新的展板，我们不得不也修改这里的代码，并且我们将无法做到在运行时动态的改变是否更新某个告示板。不太好！ 于是，我自己提出了一个解决方案，我打算让这些公告栏都继承自主公告栏类，这样它们就拥有相同的update()方法，当然我也可以用继承加多态的方式直接遍历所有Display对象，就如同下面这样： ManagementSys类内部12345678910111213//...public ArrayList DisplayList;public ManagementSys() &#123; DisplayList = new ArrayList();&#125;public void infoChanged() &#123; for(int i = 0; i &lt; DisplayList.size(); ++i)&#123; DisplayList.get(i).update(foo, bar, ...); &#125;&#125;//... 将对象添加到数组的过程就相当于同意接受更新，也可以动态去除。我们来看看我们提出的土方法和观察者模式之间有何异同。 定义观察者模式定义了对象之间的一对多依赖，这样一来当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。观察者模式将会设计一个主题(Subject)接口，其方法有添加观察者、去除观察者和通知观察者；以及一个观察者(Observer)接口，拥有更新的方法。具体的主题总是会实现主题接口，而具体的观察者将会实现观察者接口。 观察者模式提供的设计允许主题和观察者之间松耦合。这是什么意思？松耦合意味着两个对象之间可以交互，但是彼此并不明白各自的细节。主题只知道有某个类实现了观察者接口，但对于这个类是什么，将会做什么，主题不知道也不关心。如果我需要在其他地方使用主题或者观察者，那么可以轻易复用。这就带来了我们的第四个设计原则：为了交互对象之间的松耦合设计而努力。 重新设计根据我们已有的信息，我们来重新设计一下我们的系统，首先当然实现我们的主题-观察者接口。 观察者接口123456789public interface Subject &#123; public void registerObserver(Observer o); // 注册 public void removeObserver(Observer o); // 移除 public void notifyObservers(); // 通知，当主题有东西改变&#125;public interface Observer &#123; public void update(argu, ...) //&#125; 有了接口之后，我们可以让ManagementSys实现接口… ManagementSys类1234567891011121314151617181920212223242526272829303132333435public class ManagementSys implements Subject &#123; private ArrayList observers; // ... public ManagementSys() &#123; observers = new ArrayList(); &#125; public void registerObserver(Observer o) &#123; observers.add(o); &#125; public void removeObserver(Observer o) &#123; int i = observers.indexOf(o); if(i &gt;= 0)&#123; observers.remove(i); &#125; &#125; public void notifyObservers() &#123; for(int i = 0; i &lt; observers.size(); ++i)&#123; Observer observer = (Observer)observers.get(i); observer.update(foo, bar, ...); &#125; &#125; public void setInfo() &#123; // this.XX = XX; infoChanged(); &#125; public void infoChanged() &#123; notifyObservers(); &#125;&#125; 不得不说，我们的土方法可以算是和观察者模式非常接近了，但是我们并没有把观察者和主题抽象成接口，也没有把存储观察者的ArrayList封装起来。对于单个项目来说，我想我们已经做的足够好了。不过，如果要讨论到可复用性，还是书上提出的方法更加完善。任何类只要实现了写好的接口就可以达到效果。这样，我们也可以针对性地修改我们的告示牌，只需要实现Observer接口，并在update()方法中选择自己需要的参数进行更新就可以了。 内置的观察者模式Java API中有内置的观察者模式。java.util中包含基本的Observable类和Observer接口。与我们自己实现的观察者模式不同的是，它支持使用“推”和“拉”两种方式传递数据，同时在做之前需要调用setChanged()方法告知程序已经改变。但是，Java提供的“主题”是一个类，意味着你没有办法进行多继承，而且Observable具有Protected方法，这也会阻止你将Observable实例组合到你自己的类中。简直是我们之前所学的设计原则的灾难啊！ 除了java.util.Observable，在其他各种地方也有类似的观察者模式的设计，比如Swing API中的JButton，其超类AbstractButton具有AddListener()的方法，允许你做到：当按钮被按下时，传递消息到所有的ActionListener中。ActionListener接口则有actionPerformed()方法，相当于本例子中的update()。这些会令人想到在 jQuery，MATLAB App Designer 等工具中编写回调函数。许多GUI框架大量使用了这种模式。 思考上文提到的jQuery令我想起了一些事情。想象一下，notifyObservers()方法在循环中对所有观察者调用update()方法时，有一个观察者出现了问题，比如：过长甚至是死循环，抛出异常等等。这样将会打断notifyObservers()方法的整个过程。真不好！所以如果可以，我们应该用异步的办法解决这类问题。当然，成熟的GUI框架也都是如此做的。 装饰者模式还记得上次的游戏公司吗？现在有新的工作了：你需要设计游戏里在NPC处售卖的武器。现在游戏里已经有一个原始的武器实现了。目前为止，每个武器都会有名字和返回价格的方法，其他的部分我们暂时不关心。 Weapon超类及其子类12345678910111213141516171819202122232425// Weapon.javapublic abstract class Weapon &#123; String name; //... public double cost(); public String getName();&#125;// Sword.javapublic class Sword extends Weapon &#123; //... public Sword() &#123; name = &quot;Sword&quot;; &#125; public double cost() &#123; return 20; &#125;&#125;// Axe.java// Bow.java// Spear.java// Wand.java 即所有的武器都继承自一个超类，各自实现自己的cost()方法。但是现在问题来了，如果只有这些单一的武器多没有意思啊，不会有人喜欢玩我们的游戏的。项目经理告诉你，我们打算做一个： [ 稀有的 火焰附加 恶灵退治 吸血 长剑 +3 ] …怎么办？可不要说我们要实现下面的这个类： Can't believe I actually typed these1234567public class RareFlameAspectUndeadSlayerVampireLongSwordPlusThree extends Weapon &#123; // 我不想写他的构造函数了，但是你懂会出现什么的 public double cost() &#123; return 173,423.02; &#125;&#125; 很明显，原始的武器实现严重违反了我们的设计原则：独立变化之处，少用继承。当然你可能想到了另一种思路，毕竟上面的那把炫酷剑，到头来说也是剑嘛。我们可以让剑HAS-A炫酷属性，不就解决问题了吗？ 尝试重设计 Weapon 类1234567public abstract class Weapon &#123; //... public void hasFlameAspect(); public void hasVampire(); //...&#125; 这是书上给出的方案，但我觉得不够好，或者说完全不好，我甚至想不到如何计算价格，难道要遍历这些方法？书上的例子是否有些为了否定而否定呢？HAS-A并不是无法解决这个问题。我想到，此时我们也许应该用到我们之前学习的策略模式，将炫酷属性封装起来，成为一个接口，具体的炫酷属性将会实现这个接口，并且再用一个ArrayList存储它们，现在我们就将变化之处独立出来了。如果游戏多了新的炫酷效果，那么我们只需要实现炫酷效果本身即可。 策略模式的 Weapon 类设计1234567891011121314151617181920212223242526272829303132333435363738394041// Weapon.javapublic abstract class Weapon &#123; //... ArrayList allAbilities; //...&#125;// Sword.javapublic class Sword extends Weapon &#123; //... public Sword() &#123; allAbilities = new ArrayList&lt;WeaponAbility&gt;(); this.name = &quot;Sword&quot;; this.cost = 20; &#125; // ... public void addAbility(WeaponAbility a) &#123; // 加入数组 // 更新价格和名字 &#125;&#125;interface WeaponAbility &#123; public double cost; public String name; // 可能会实现属性的能力&#125;class FlameAspect implements WeaponAbility &#123; public FlameAspect() &#123; this.cost = 109.3; this.name = &quot;Flame Aspect&quot;; &#125; // ...&#125; 看来其他的设计模式并不是不可行，我们也做到了使用组合不使用继承。但是毕竟我们这一节是讲装饰者模式嘛！装饰者模式究竟比我们以上的代码优越在何处？这需要我们理解我们的第五个设计原则：类应该对扩展开放，对修改关闭。可以用任何想要的行为扩展类，但是尽量不要修改类的代码。可能现在代码已经被写好，如果这个时候去修改Weapon类的属性，构造函数等等，就会出一些问题。装饰者模式严格遵守了开放-关闭原则，让我们看看这是怎么做到的。 定义装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的方案。装饰者超类本身将会继承现有的超类。也就是说，在本例子中，装饰者超类和Sword类是同级别的。同时，装饰者的具体实现是继承了装饰者超类的。 等一下？不是不要使用继承要用组合吗？但其实，本处继承的重点是，要求装饰者和被装饰者必须是一样的类型。我们所做的事情是“类型匹配”，而非获得任何行为。当我们把装饰者和组件结合时，才是加入了新的行为。获得行为的方式是组合而来的。 重新设计我们现在可以重新设计我们的武器属性了，首先，Weapon类不需要做任何变化，我们之前写好的Sword类也不需要变化，来看看装饰者的超类如何实现。 WeaponDecorator 类实现123public abstract class WeaponDecorator extends Weapon &#123; public abstract String getName();&#125; 先别急着疑惑，我们再具体实现一个装饰者，这样就能具体看到它的作用了。 Vampire 类实现123456789101112131415public class Vampire extends WeaponDecorator &#123; Weapon weapon; public Vampire(Weapon weapon) &#123; this.weapon = weapon; &#125; public String getName() &#123; return &quot;Vampire &quot; + weapon.getName(); &#125; public double cost() &#123; return 200.3 + weapon.cost(); &#125;&#125; 也就是说，装饰者超类必须实现其父类需要改变的方法，而具体的装饰者将会override这些方法，并进行具体的改动。这样的行为可以让我们得到神奇的效果（我已经在兴奋了）： 1Weapon sellWeapon = new Vampire(new UndeadSlayer(new FlameAspect(new Rare(new Sword())))); 真是美丽又可怕！这立刻让我们想到了别的东西。 真实世界的装饰者装饰者竟在我身边，想想你曾经要做文件流读写的时候写过的代码： 1InputStreamReader iptStrm = new InputStreamReader(new FIleInputStream(arg)); 这样看来，装饰者模式的缺点也非常明显了，因为这样嵌套的小类实在是太多了（比如我的一位朋友对于Java的印象就是：有很多new）。 总结来看看我们新学到的东西： 设计原则四：为了交互对象之间的松耦合设计而努力。 设计原则五：类要对扩展开放，对修改关闭。 观察者模式：定义对象之间的一对多依赖，这样一来当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 装饰者模式：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的方案。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://n1vk.github.io/categories/Programming/"}],"tags":[{"name":"程序设计","slug":"程序设计","permalink":"https://n1vk.github.io/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"Java","slug":"Java","permalink":"https://n1vk.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://n1vk.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"面向对象","slug":"面向对象","permalink":"https://n1vk.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"Solidity 语言的形式化规约","slug":"solidity-formal-specification","date":"2022-03-31T14:19:43.000Z","updated":"2024-04-08T15:33:28.197Z","comments":true,"path":"Programming/solidity-formal-specification/","link":"","permalink":"https://n1vk.github.io/Programming/solidity-formal-specification/","excerpt":"Solidity 语言一旦被部署到区块链就无法更改，这要求程序员在设计程序的时候对于变量的改变更加谨慎。形式化规约应运而生，其以注释的方式储存在代码间以供程序员参阅，在必要的时候也可以使用外部程序根据注释进行验证。","text":"智能合约与其他软件一样容易有错误和漏洞。在以太坊环境下，任何错误都伴随着潜在的对金融的破坏性结果。因此引入了形式化规约来验证操作。形式化规约存在相当多的形式，并拥有严谨的数学证明来描述系统行为，从事件所跟踪的具体的区块链上数据的角度来具体说明智能合约的行为。本文将给出两种不同的形式化规约。 基于事件的形式化规约一篇来自BME的论文介绍了基于事件的形式化规约，并给出了名为 SOLC_VERIFY的 验证程序。但是本文章只关心其提出的形式化规约说明。验证程序基于模块化程序验证，由Mike Barnett在其之前的论文中提出，这与计算科学和程序语义等学科相关，不做讨论。 智能合约事件介绍本文介绍的方法主要用于依靠事件 (Event) 传递消息的 Solidity 程序。 Solidity 是面向合约的智能合约编程语言的代表。而事件代表了与用户相关的、有限的交易执行。合约可以利用事件传递链上数据的状态改变情况。技术上来说，事件可以看做有参数的触发器，其存储位置位于区块链的日志。这些日志是合约无法访问的，而用户却可以轻易的监听这些事件从而获得值。以往，事件往往是被认为是一种日志记录机制，与程序设计的正确性无关。然而，既然事件是DAPP中最主要的为用户设计的状态改变提示机制，确保用户正确理解且信任发送的事件是十分关键的。 Solidity 不为发送事件设置任何限制，因此错误的（或恶意的）合约可以发送与状态改变不一致的事件，或对于某些改变忽略发送事件，潜在的将会误导用户。 语法举例请首先看已经加入形式化规约的 Solidity 演示代码： Solidity1234567891011121314151617181920212223242526272829contract Registry &#123; struct Entry &#123; bool set; int data; &#125; // User-defined type mapping(address=&gt;Entry) entries; // State variable /// @notice tracks-changes-in entries /// @notice precondition !entries[at].set /// @notice postcondition entries[at].set &amp;&amp; entries[at].data == value event new_entry(address at, int value); /// @notice tracks-changes-in entries /// @notice precondition entries[at].set &amp;&amp; entries[at].data &lt; value /// @notice postcondition entries[at].set &amp;&amp; entries[at].data == value event updated_entry(address at, int value); /// @notice emits new_entry function add(int value) public &#123; require(!entries[msg.sender].set); entries[msg.sender].set = true; entries[msg.sender].data = value; emit new_entry(msg.sender, value); &#125; /// @notice emits updated_entry function update(int value) public &#123; require(entries[msg.sender].set &amp;&amp; entries[msg.sender].data &lt; value); entries[msg.sender].data = value; emit updated_entry(msg.sender, value); &#125; &#125; 演示代码非常简单，定义了一个 Entry 结构，和一个地址到 Entry 的映射的变量（在文章中叫做状态变量，state variable)；两个事件，一个代表新加入合约，另一个代表更新加入合约。以及添加和更新的函数。 首先，某个事件都跟随的是 entries 变量的变化，因此我们写出： 1&#x2F;&#x2F;&#x2F; @notice tracks-changes-in entries tracks-changes-in 关键字所说明的事实是：事件被触发当且仅当被跟踪的变量改变。由于数据经常以多步过程的形式改变（如例子中，函数依次更新了 Entry 结构中的两个数据），或者数据更新存在某种条件，因此事件不会总是立刻跟在某个追踪变量的改动后。因此，文章提出了前/后检查点的概念。前检查点是由事件所追踪的变量的第一次改变所动态的定义的。相对的，后检查点是一个静态边界，一般是循环或交易的边缘。说白了就是，你的事件必须要在你跟的变量第一次改变之后，离开程序之前进行一次激发。 在跟随变量以外，事件也可以被用 predicates 来注释，它是用状态变量和事件的参数来定义的，并且有两种，preconditions 和 postconditions。前置条件在前检查点前捕捉状态变量的值，而后置条件对应着事件被发送的时刻。 举例来说，对于 new_entry 事件，其要求用户一开始不处于 entries，即set 布尔类型为假，且事件发出后用户属于entries，data 被赋值。 123&#x2F;&#x2F;&#x2F; @notice precondition !entries[at].set&#x2F;&#x2F;&#x2F; @notice postcondition entries[at].set &amp;&amp; entries[at].data &#x3D;&#x3D; value event new_entry(address at, int value); 最后，发射事件的函数必须被标记处发射了何等事件： 1234&#x2F;&#x2F;&#x2F; @notice emits updated_entryfunction update(int value) public &#123;...&#125; 基于函数的形式化规约基于函数的形式化规约和基于事件的有很多相似之处（并且是南大78004870课程所讲述的模式），只是把修改变量的规约放在函数（与合约、循环）前。并且由于函数可以对值进行修改，而非像事件一样仅展现变化，所以会比基于事件的规约增加其他的东西。请看下例： Solidity123456789101112131415161718192021222324/// @notice invariant x == ycontract Track &#123; int x; int y; /// @notice precondition x == y /// @notice postcondition x == (y + n) /// @notice modifies x function add_to_x(int n) internal &#123; x = x + n; require(x &gt;= y); &#125; /// @notice modifies x if n &gt; 0 /// @notice modifies y if n &gt; 0 function add(int n) public &#123; require(n &gt;= 0); add_to_x(n); /// @notice invariant y&lt;=x while(y &lt; x) &#123; y = y + 1; &#125; &#125;&#125; 由例子，我们可以总结出基本的语句： 如果某变量没有被改变，那么需要注明不变式： 1invariant &lt;EXPRESSION&gt; 注意，不变式出现在循环，合约，函数前。 如果函数开始前/结束后必须满足某条件，那么需要注明前置条件/后置条件，与基于事件的一样。 如果函数执行改变了状态变量，那么需要注明修改规约： 1modifies &lt;TARGET&gt; [if &lt;CONDITION&gt;] 进阶的规约表达课程同时给出了一些进阶的规约表达方式，例如： 聚合计算的表达： 1__verifier_sum_&lt;TYPE&gt;( ... ) 所代表了将 &lt;TYPE&gt; 相加所得到的结果。 复合数据类型判等： 1__verifier_eq(..., ...) 其实就是更加复杂的 x == y。 变量旧值引用: 1__verifier_old_&lt;TYPE&gt; 也许是在循环中引用上一次的值或者引用修改前的值。 谓词逻辑表达： 123forall (&lt;VARS&gt;) &lt;QUANTEXPR&gt;exists (&lt;VARS&gt;) &lt;QUANTEXPR&gt; 举例来说： 1forall (uint λ) !(λ &gt;&#x3D; 0 &amp;&amp; λ &lt; length) 总结形式化规约是一种让程序设计更加严谨的实现，而对于对准确度要求高的智能合约来说更加有用。即使没有检查器，掌握形式化合约也有助于形成良好的变量追踪与查询习惯。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://n1vk.github.io/categories/Programming/"}],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"https://n1vk.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"https://n1vk.github.io/tags/Solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://n1vk.github.io/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"}]},{"title":"简单的以太坊智能合约部署","slug":"smart-contract","date":"2022-03-29T02:49:53.000Z","updated":"2022-04-04T16:04:28.276Z","comments":true,"path":"Programming/smart-contract/","link":"","permalink":"https://n1vk.github.io/Programming/smart-contract/","excerpt":"基于 Solidity 合约语言和本地私有链，部署简易的以太坊智能合约的记录。","text":"可以简单的把以太坊虚拟机理解为一个公开使用的后端服务器，用户在其上拥有有限的操作空间，每次操作以交易的形式产生，并会根据修改数据的大小向用户收费，称为 Gas，以此支持服务器维护人员 (即矿工)。并且，服务器上的数据会被永久记录，操作后端数据的代码 (对于EVM，是 Solidity 代码) 也存放在服务器上不能被修改。 矿工可以根据 Gas 和数据操作量选择将哪一笔交易加入区块。因此 Solidity 编程要求存储尽量少的数据，节省空间和操作量，以此得到更快速的响应。 使用 Remix 和 GanacheRemix 是以太坊官方提供的 Solidity 开发环境。在 Remix 内写好代码后可以编译，编译会得到程序的二进制程序接口，称为 ABI。ABI 会提供给 web3.js 来提供操作接口。在编译后可以部署合约，Remix 本身提供了一些 JavaScript 虚拟机来运行智能合约。为了观察到用户和交易的情况，我们可以部署私有链，利用 Ganache。部署后会得到合约地址，你也可以直接在 Remix 和合约交互。 Ganache 可以在本地设置好私有区块链，即开即用。用户可以自行设置端口号，而网络ID为5777而区块链ID为1337。在本地部署好之后，使用 MetaMask 钱包添加私有链。MetaMask 也可以使用其他测试链，虽然其他测试链可以有更多的用户，但在这些链上我们难以观察交易情况。添加私有链后，也记得添加私有链的账户。 说到账户，对于以太坊地址来说，所有链上的地址格式都完全一致。因此，你的任何一个账户都可以在任何链上使用（当然代币不会跟随）。可以尝试把 Ganache 里生成的账户的钱转入一个你主链的地址，操作将会成功且主链地址在私有链上的 ETH 会增加。注意 Ganache 不会追踪除了它生成的账户以外的账户（因为无穷多），但是你仍然可以看到 TX 信息，就在 Ganache 的操作面板。这到底是怎么做到的？得益于钱包地址的随机和海量，生成的两个地址相同的概率几乎是不可能的。 Solidity 代码设计一个 Solidity 代码，对于每个账户存放一个数据，并且允许用户查看数据。 (很遗憾，Hexo 对于 Solidity 代码暂时没有语法高亮，我也不想使用 hightlight.js，所以我随便选用了一种代码高亮模式。) Solidity123456789101112131415161718192021222324252627282930// 声明 License// SPDX-License-Identifier: GPL-3.0// 声明编译器版本pragma solidity &gt;=0.7.0 &lt;0.9.0;// 合约，就像一个类contract numberHolder &#123; // 映射数据结构 mapping(address =&gt; uint16) userNumbers; // 一个事件 event numberSetted(address addr,uint16 num); // 地址的数据的setter函数 function setNumber(uint16 inputNumber) public&#123; userNumbers[msg.sender] = inputNumber; // 发送事件给前端 emit numberSetted(msg.sender, userNumbers[msg.sender]); &#125; // 两个只读函数获得用户地址和数据 function getNumber() public view returns (uint16) &#123; return userNumbers[msg.sender]; &#125; function getAddress() public view returns (address) &#123; return msg.sender; &#125;&#125; 具体内容可以查看 Solidity 的文档。函数发射的事件需要在前端进行监听。关键字 view 代表了这个函数不会操作数据。全局变量 msg 存储了一些当前合约的信息，例如 msg.sender 就是调用合约的地址。 Web 代码Web 端我们使用以太坊 JavaScript API和后端交互，叫做 web3.js，使用此库类似于使用 jQuery 的 ajax。实际上，包括部署合约在内的操作都可以用 web3.js 完成，但本次我们不这样做。 在网页端，首先用简单 HTML 完成界面，给用户提示信息，显示一个可变文本并设置两个按钮： 12345678910111213141516 &lt;div class=&quot;container&quot;&gt; &lt;h1&gt;数字存放&lt;/h1&gt; 在数据框中输入一个数字并点击上传数据，它将会被存储至区块，请注意这会消耗燃料。&lt;br&gt; 点击获得数据将会显示您已经存储的数据，这不会消耗燃料。 &lt;h2 id=&quot;info&quot;&gt;等待输入&lt;/h2&gt; &lt;label for=&quot;data&quot; class=&quot;col-lg-2 control-label&quot;&gt;您的数据&lt;/label&gt; &lt;input id=&quot;data&quot; type=&quot;text&quot;&gt; &lt;button id=&quot;button_update&quot;&gt;上传数据&lt;/button&gt; &lt;button id=&quot;button_download&quot;&gt;获得数据&lt;/button&gt;&lt;/div&gt; 接下来在 &lt;script&gt; 部分设计网页的逻辑。别忘记把 web3.js 和 jQuery 加入到网页中。首先配置好我们的 web3 库： 123456if (typeof web3 !== &#x27;undefined&#x27;) &#123; web3 = new Web3(web3.currentProvider);&#125;else&#123; web3 = new Web3(new Web3.providers.HttpProvider(&quot;http://localhost:8545&quot;));&#125; 这声明了，我们的 web3 是由 HTTP 在本地8545端口提供，也就是我们的 Ganache。接下来： 12345web3.eth.defaultAccount = web3.eth.accounts[0]; var contractABI = web3.eth.contract(/* ABI Here */)var myContract = contractABI.at(&#x27;0x6f0D3623...&#x27;) 第一行代码说明了我们默认交互账户是 Ganache 里的第一个账户。我们现在还不将 MetaMask 链接功能提供在前端。MetaMask 要求前端网页不能是本地打开的，必须运行在一个服务器上 (Python 搭建的简易 HTTP 服务器就可以)，并且需要更复杂且完善的代码。第二行代码需要我们写入之前在 Remix 得到的 ABI，这是我们交互的基础。第三行就是合约本身，从语义上可以理解为：某个 ABI 位于某个确定的地址上。这个地址可以在 Remix 处看到，或在 Ganache 的 TX 信息里找到。 接下来我们来看一下在前端如何调用 Solidity 函数，并用 jQuery 改变前端显示。首先演示一下按钮如何获得数据： 1234567$(&quot;#button_update&quot;).click(function() &#123; myContract.setNumber($(&quot;#data&quot;).val());&#125;);$(&quot;#button_download&quot;).click(function() &#123; $(&quot;#info&quot;).html(&#x27;您的地址：&#x27; + myContract.getAddress.call() + &#x27;&lt;br&gt;&#x27; + &#x27;您存储的数字：&#x27; + myContract.getNumber.call() + &#x27;&lt;br&gt; 操作：读取数字&#x27;)&#125;); 对于 jQuery，简单的语法是利用 $(&quot;#id&quot;) 选中 HTML 对应 ID 的内容，在此是按钮类型。按钮类型具有 click() 方法，我们在内部写出一个函数，意思是“如果按钮被按下，那么执行这个函数，函数的内容是使用合约内的 setNumber() 函数，函数的参数是 HTML 中 ID 为 data 的元素的值”。对于下面获得值的操作，同理。 再来看看怎么监听我们发出的事件： 1234567891011var eventSet = myContract.numberSetted()eventSet.watch(function(error, result)&#123; if(!error) &#123; $(&quot;#info&quot;).html(&#x27;您的地址：&#x27; + result.args.addr + &#x27;&lt;br&gt;&#x27; + &#x27;您存储的数字：&#x27; + result.args.num + &#x27;&lt;br&gt;&#x27; + &#x27;操作：设置数字&#x27;) console.log(result) &#125; else &#123; console.log(error) &#125;&#125;) 基本原理同以上相同，我们将合约的 numberSetted 事件声明成一个变量，对这个变量进行 watch() 方法。里面的函数和刚才的差不多，它具有了两个参数。因为 web3 要求我们进行异常处理，即需要有 if(!error) &#123;&#125; elese &#123;&#125; 的形式。另一个参数 result 里面包含了我们在 Solidity 中写过的两个返回值。如果不太明白，可以在浏览器打开控制台观察一下 log，会完整展现 result 的结构。 网页的样子 总结目前我们的前端已经可以在本地运行了。不过像这样直接链接私有链，利用索引选择调用合约的用户以及函数的处理方式都非常原始，只能作演示用。之后会尽量设计更完善的代码。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://n1vk.github.io/categories/Programming/"}],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"https://n1vk.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"https://n1vk.github.io/tags/Solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://n1vk.github.io/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"}]},{"title":"算法题记录 - 键盘测试","slug":"algorithm-0","date":"2022-03-29T00:00:00.000Z","updated":"2022-04-04T16:04:38.118Z","comments":true,"path":"Note/algorithm-0/","link":"","permalink":"https://n1vk.github.io/Note/algorithm-0/","excerpt":"正向思考不出来的问题，反过来。","text":"羊羊买了新键盘，并邀请大家来试用键盘，但前提是回答出以下问题。 您将获得两个字符串s和t，两者都由小写的英文字母组成。您将逐个字符地键入字符串s，从第一个字符到最后一个字符。 特别之处在于，键入字符时，您可以按Backspace按钮，而不是按与之对应的按钮。Backspace会删除您刚刚键入的最后一个字符（如果您键入的字符串中没有字符，则不执行任何操作）。例如，如果s是”abcbd”，并且您按Backspace而不是键入第一个和第四个字符，您将获得字符串”bd”（第一次按Backspace不删除任何字符，第二次按删除字符”c”）。另一个例子，如果s是”abcaa”，并且您用Backspace键代替最后两个字母，则得到的文本为”a”。 您的任务是确定是否可以通过以上方式，从字符串s获取字符串t. 测试用例第一行是一个整数 q (1≤q≤10^5），代表测试用例的数量。每个测试用例的第一行是字符串s (1≤s的长度≤10^5)，s中的每个字符是小写的英文字母。每个测试用例的第二行是字符串t (1≤t的长度≤10^5)，t中的每个字符是小写的英文字母。 对于每个测试用例，如果可以按本题的方式从s得到t，请打印”YES“,否则，打印“NO”。 Input1234567894abababaabababbaaaaaaaaababaababa Output1234YESNONOYES 初始想法看到题目首先观察了 s 和 t 的联系。首先的想法如下： 对于 s，首先寻找其中所包含的第一个 t[0]。如果没有 t[0]，那么肯定无法输出。 如果有 t[0]，接着去找 t[1]，看看两个字母之间的字母数是不是偶数个（打出，删除，打出，删除…）。如果不是，那么肯定无法输出。 如果还是，那么继续重复以上的步骤，直到 t 越界。 遇到的问题： aababa 和 ababa 无法处理。说明如果 s 存在 t[0]，但完全无效，则应该去除 s 中 t[0] 即其之前的部分，重新进行测试。但是此方法只适用于 t[0]，因为实际上在符合要求的 t[0] 于 s 中出现之前，用户可以什么都不输入只按退格键。并且，这样的方法对于大数据来说太慢了。 本身的算法就非常难设计，需要三个指针，两个位于 s 标定位置，一个位于 t 指向当前的内容。 解决方案反向思考，如果说开头的东西可以忽视会让人难以处理，那么把开头放在最后就好了。同时，我们知道符合要求的字符串 s 的尾部要么和 t 完全一致，要么最后相差偶数个。所以最终的设计是，从 s 和 t 的尾部开始遍历，如果相同就同时前进 1 个字母，再比较；如果不同，则 s 前进2 个字母，再比较。直到 s 或 t 某个字符串结束。最后再判断 t 有没有结束。如果 t 结束了，那么答案就是 YES，此时 s 最开始的部分就是那些我们可以只按退格键的字符。 Python 代码如下： 12345678910111213141516171819202122def special_typing(): stringNum = eval(input()) while(stringNum != 0): stringS = list(input()) stringT = list(input()) comparePointer = len(stringS) - 1 current = len(stringT) - 1 while(current &gt;= 0) and (comparePointer &gt;= 0): if(stringT[current] == stringS[comparePointer]): current -= 1 comparePointer -= 1 else: comparePointer -= 2 if(current &lt; 0): print(&quot;YES&quot;) else: print(&quot;NO&quot;) stringNum -= 1","categories":[{"name":"Note","slug":"Note","permalink":"https://n1vk.github.io/categories/Note/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://n1vk.github.io/tags/Python/"},{"name":"算法","slug":"算法","permalink":"https://n1vk.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"程序设计","slug":"程序设计","permalink":"https://n1vk.github.io/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式：基本思想与策略模式","slug":"design-pattern-0","date":"2022-03-28T12:21:57.000Z","updated":"2024-04-08T14:47:01.994Z","comments":true,"path":"Programming/design-pattern-0/","link":"","permalink":"https://n1vk.github.io/Programming/design-pattern-0/","excerpt":"学习 Head First Design Pattern，第一部分的内容包括初步认识设计模式，学习基本设计原则以及学习的第一个设计模式：策略(Strategy)模式。","text":"知道继承，接口，多态和虚类不能让你学会面向对象程序设计。理解设计模式，因为设计模式是面向对象开发工程师们多年以来程序设计的经验总结，是为了解决问题而产生的历经验证的工程通用解决方案。良好的设计模式会包含可复用，可扩充，可维护三个特性，而模式可以帮我们做到这点。 首先来举个简单的例子，来展示继承所不能解决的问题。如图，某游戏公司程序员为自己游戏的职业系统设计了一个 Player 超类，所有的职业都会继承这个超类。在继承时，也会继承超类内所有的方法。如果需要新的职业，那么我们就添加一个新的类。完美！ 美丽的UML图 现在公司抛出了新的需求：要求玩家应该会闪避。这很好办，只需要在超类里加入一个 dodge() 方法即可。但是在测试的时候发现了新的问题：牧师会闪避导致了他过于强大的生存能力，以至于不需要队友保护他。这和游戏的设计理念不太符合，公司要求程序员让牧师不再会闪避。这也很简单，把 Priest 的 dodge() 方法的具体实现覆盖成什么都不做就可以了。到目前为止，一切都很好… 直到程序员意识到，公司为了赚钱每个月都会推出一款新职业，他们有的专注攻击不能防御，有的利用防御来攻击，有的……噢还有，公司还会推出氪金装备，使得 Priest 可以有限次的进行闪避动作。天啊，这要怎么办？来看看我们从最初的设计原则可以推出什么。 变与不变应用设计的第一个原则：找出应用中需要变化之处，将其独立，不要和不需要变化的代码写在一起。这样，每次新的需求来到，我们就可以不修改固定的部分，只修改变化的部分。 对于我们的游戏设计来说，我们知道 dodge() 是会随着职业的不同而改变的（当然 attack() 和 defense() 也会变，但是原理是一样的 ）。那么我们把闪避行为拿出来，并为它创建一个类。所有的职业都将 HAS-A 闪避行为。 为谁而写应用设计的第二个原则：针对接口编程，不要针对实现编程。 说真的，我觉得这句话刚一看到非常难理解。 什么是实现？职业类如果实现了 dodge() 接口，那么就意味着所有职业都要实现这个接口，因为他们都继承自原始的超类。我们不要把什么类能实现什么在最开始的时候写死。 怎么针对接口编程？我设计一个 DodgeBehaviour 接口，此接口有 dodge() 方法。现在，我们让具体的类实现这个接口。DodgeNormal 类会正常的躲避，而 DodgeNaught 类什么都不做。现在，闪避行为和 Player 类没有任何关系了。我们可以随意添加闪避行为或者修改行为，比如我们为法师设计一个 DodgeKUXUAN，让闪避的时候会增加粒子效果。 另一个美丽的UML图 完成设计现在事情可能会变得有点奇怪，我们如何让某个职业进行闪避？请看代码： 12345678910public class Player &#123; healthType Health; DodgeBehaviour dodgeBehaviour; //... public void performDodge() &#123; dodgeBehaviour.dodge(); &#125;&#125; 这是我们的超类。看，我们通过让职业 HAS-A 行为的方式成功地托管了闪避行为！这也就引出了我们的第三个设计原则：多用组合，少用继承。HAS-A is better than IS-A! 那么相对应的，子类的代码： 12345public class Priest extends Player &#123; public Priest() &#123; dodgeBehaviour = new DodgeNaught(); &#125;&#125; 在构造函数里面，我们写好 Priest 会使用哪种 实现了 DodgeBahaviour 的类。不仅如此，如果我们对 dodgeBehaviour 设定一个 setter 函数，我们就可以在程序运行时改变牧师躲避的行为，比如牧师装备了氪金道具，那么就将 dodgeBehaviour 设定成可以闪避并计数，结束后改回去。这比写一个 ”可以进行10次闪避” 的 Priest 职业好太多了！ 同理，攻击和防御方法都可以用相同的方式实现。以上的设计模式我们称为策略模式。策略模式定义且封装了独立于使用算法客户的算法族，使他们相互之间能够替换。这也不意味着继承方法真的没用了，比如所有的职业都需要走路，那么 walk() 方法就可以继承。关键点是确立好需求，并选择你需要的设计模式。 （所以，这位程序员该好好跟他的产品经理吵一架 :P ） 总结来看看我们目前学到的东西： 设计原则一：找出应用中需要变化之处，将其独立，不要和不需要变化的代码写在一起。 设计原则二：针对接口编程，不要针对实现编程。 设计原则三：多用组合，少用继承。 策略模式：定义且封装了独立于使用算法客户的算法族，使他们相互之间能够替换。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://n1vk.github.io/categories/Programming/"}],"tags":[{"name":"程序设计","slug":"程序设计","permalink":"https://n1vk.github.io/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"Java","slug":"Java","permalink":"https://n1vk.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://n1vk.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"面向对象","slug":"面向对象","permalink":"https://n1vk.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"重新记录我的博客","slug":"init_post","date":"2022-03-27T15:34:49.000Z","updated":"2024-04-09T02:56:49.731Z","comments":true,"path":"Thoughts/init_post/","link":"","permalink":"https://n1vk.github.io/Thoughts/init_post/","excerpt":"不要再摸了。","text":"两年前，我抱着玩玩的心态在 Github 上部署了一个小博客。然而搜肠刮肚发现自己既没技术，又没文笔，无甚可写，遂作罢。近日和舍友闲谈，偶然间舍友提到了博客。突然想起了自己曾经弄的小站。再联想到自己最近需要学习，记忆力又狠狠衰退，于是打算把博客重拾起来。为了避免自己又忘记什么重要的事，我把操作博客的方法都写下来。 写作与更新在部署时我就选择了 Hexo 托管页面。Hexo 是一个 Node.js 包，它能够自动生成网页，用户所需要做的只是写作。并且，它支持各种插件与主题。 新建文章使用如下代码在 /source/_posts/ 内新建一个文件夹与 markdown 文件，名字为name.md。name也将组成这篇博客的 url 路径： 1hexo new name 生成静态文件使用Generate功能为前端生成静态文件吧。 123456hexo generate -d (在生成后直接部署) -w (查看改变内容) -b (如果生成出错则抛出异常) -f (强行生成) -c (控制并行生成量, 默认无限大) 可以简写为 hexo g。 本地测试1234hexo server -p (复写默认端口4000) -s (只serve静态文件) -l (打印日志) 同理，hexo s for short. 部署到远端待测试没问题后，push 到 Github 吧： 12hexo deploy -g (在部署前生成) 清理生成文件1hexo clean 这个行为在修改了样式后需要被使用一下。 配置和优化关于Hexo的配置，可以在hexo config获取，或者修改_config.yml。 关于样式配置，可以在 Volantis 文档内找到所有需要的内容，包括底栏侧栏导航栏配置等等。对于 Post 的封面，我使用 Canvas 可画来制作，按照微信公众号的标题随便做一个即可。对于在文章内插图，我使用 SM.MS 图床。 承诺即使发一些毫无意义的 shitpost，我也尽量不会让博客停下来。拖延和懒惰的一部分来自于追求完美，会希望把事情做的足够好的想法，会导致人过分注重细枝末节而最后放弃。 （2023年某日：笑死，根本没时间写，我是sb）","categories":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://n1vk.github.io/categories/Thoughts/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://n1vk.github.io/tags/%E6%83%B3%E6%B3%95/"},{"name":"记录","slug":"记录","permalink":"https://n1vk.github.io/tags/%E8%AE%B0%E5%BD%95/"},{"name":"博客","slug":"博客","permalink":"https://n1vk.github.io/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"cat"}],"categories":[{"name":"Note","slug":"Note","permalink":"https://n1vk.github.io/categories/Note/"},{"name":"Programming","slug":"Programming","permalink":"https://n1vk.github.io/categories/Programming/"},{"name":"Thoughts","slug":"Thoughts","permalink":"https://n1vk.github.io/categories/Thoughts/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://n1vk.github.io/tags/Git/"},{"name":"Linux","slug":"Linux","permalink":"https://n1vk.github.io/tags/Linux/"},{"name":"LLM","slug":"LLM","permalink":"https://n1vk.github.io/tags/LLM/"},{"name":"昇腾","slug":"昇腾","permalink":"https://n1vk.github.io/tags/%E6%98%87%E8%85%BE/"},{"name":"Vue","slug":"Vue","permalink":"https://n1vk.github.io/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://n1vk.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Golang","slug":"Golang","permalink":"https://n1vk.github.io/tags/Golang/"},{"name":"后端","slug":"后端","permalink":"https://n1vk.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Goroutine","slug":"Goroutine","permalink":"https://n1vk.github.io/tags/Goroutine/"},{"name":"Gin","slug":"Gin","permalink":"https://n1vk.github.io/tags/Gin/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://n1vk.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Java","slug":"Java","permalink":"https://n1vk.github.io/tags/Java/"},{"name":"面向对象","slug":"面向对象","permalink":"https://n1vk.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"Java Virtual Machine","slug":"Java-Virtual-Machine","permalink":"https://n1vk.github.io/tags/Java-Virtual-Machine/"},{"name":"程序设计","slug":"程序设计","permalink":"https://n1vk.github.io/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"设计模式","slug":"设计模式","permalink":"https://n1vk.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Ethereum","slug":"Ethereum","permalink":"https://n1vk.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"https://n1vk.github.io/tags/Solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://n1vk.github.io/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"Python","slug":"Python","permalink":"https://n1vk.github.io/tags/Python/"},{"name":"算法","slug":"算法","permalink":"https://n1vk.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"想法","slug":"想法","permalink":"https://n1vk.github.io/tags/%E6%83%B3%E6%B3%95/"},{"name":"记录","slug":"记录","permalink":"https://n1vk.github.io/tags/%E8%AE%B0%E5%BD%95/"},{"name":"博客","slug":"博客","permalink":"https://n1vk.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]}