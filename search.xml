<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>子网还是专用网？我混淆了分类网和网络地址转换</title>
      <link href="Note/subnets-and-nat/"/>
      <url>Note/subnets-and-nat/</url>
      
        <content type="html"><![CDATA[<p>在最初学习计算机网络的时候，我首先学习了IPv4编址方式，紧接着学习了子网，CIDR，路由聚合，IP地址获取与NAT。但在思考和与朋友讨论的过程中，我发现我混淆了一些概念。因此我做了一些调查，在这篇笔记中按顺序梳理这几个概念，这个顺序也是互联网IP协议发展所采取的顺序。</p><h2 id="路由器和网关"><a href="#路由器和网关" class="headerlink" title="路由器和网关"></a>路由器和网关</h2><div class="story post-story"><p>首先我们明确，这些设备全部都是用来调控网络流量的。那么，简单一点来说：</p><p><strong>路由器在相同的网络中转发数据</strong>。路由器本身将会存储一个查找表。对于接受的数据包，路由器检查数据包内的数据是发给谁的，根据自己的查找表传递给下一台路由器/主机。网络中的数据包就是这样，经过多次跳跃，从一个主机到达另一个主机的。</p><p><strong>网关在不同的网络中传递数据</strong>。如果两个网络使用了不同的网络协议，那么我们就需要网关为我们做协议转换。最常见的就是我们接下来要讲的NAT。</p><p>路由器和网关是可以重叠的。一个设备，可以既做数据包在同协议网络间的转发，又为网络间通信转换网络协议，此时他就是一个路由器和一个网关。</p><p>除此之外，还有一些互联网设备的概念，诸如交换机，接入点（AP），调制解调器（MODEM）等，因为对于理解本篇文章不重要，就不展开讲了。</p></div><h2 id="子网与子网掩码"><a href="#子网与子网掩码" class="headerlink" title="子网与子网掩码"></a>子网与子网掩码</h2><div class="story post-story"><p>教科书上说，网络被分配到的一个IP地址由网络地址和子网掩码组成。IP地址由四段八比特二进制数组成，也可以写成点分的十进位形式。而子网掩码，其高比特位标志了该子网的地址，而低比特位标志了主机在子网中的地址。IP地址后用一个斜杠加一个数字，表示其前多少位是网络地址。我们举个例子。</p><figure class="highlight c"><figcaption><span>IP地址</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">十进制网络地址  <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span>/<span class="number">24</span></span><br><span class="line">二进制网络地址  <span class="number">11000000</span> <span class="number">10101000</span> <span class="number">00000001</span> <span class="number">01100100</span></span><br><span class="line"></span><br><span class="line">十进制子网掩码  <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">二进制子网掩码  <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure><p>IPv4协议是在1982年提出的，最开始的32位IPv4只用前8位确定网络地址，即主机连接到哪个网络，以及剩下的部分作为主机地址。这样的分类方式不能允许太多的独立网络。</p><p><strong>为什么需要区分一个网络地址和一个主机地址？</strong>我的理解是，这实际上是为了控制网络的边界，方便管理与路由器寻址。假设不区分子网，那么路由器需要维护的查找表将会非常庞大，需要将IP地址的每一位都记录下来，并且计算保存最近距离的路由器。如果区分了子网，那么路由器只需要存储<strong>以哪些字段开头</strong>的数据发给某个路由器即可。</p><p>而伴随其提出的是如何为子网划分地址的模式。最开始，人们选择了比较简单的分级式寻址。网络被分为ABCDE五个类，不同的类使用他们的前三位来识别：</p><ul><li>A类地址，第一位是0，使用前8位作为网络位，剩下的作为主机位，A类地址可以构建出 128 个网络，每个网络容纳 16,777,214 个主机。</li><li>B类地址，前两位是10，使用前16位作为网络位，剩下的作为主机位，B类地址可以构建出 16,384 个网络，每个网络容纳 65,534 个主机。</li><li>C类地址，前三位是110，使用前24位作为网络位，剩下的作为主机位，B类地址可以构建出 2,097,152 个网络，每个网络容纳 254 个主机。</li><li>D类群播地址，前四位是1110；和E类保留地址，前四位是1111。</li></ul><p>实际上，这种分类模式就没有必要说明子网掩码，因为你总是可以从前n位推断出其子网掩码应该是多少。这种分类模式<strong>现在已经被废止</strong>，因为其立刻展现出了问题：对于一个小型网，C类地址的主机容量太小，B类地址又太大。</p></div><h2 id="无类别区域间路由（CIDR）和路由聚合"><a href="#无类别区域间路由（CIDR）和路由聚合" class="headerlink" title="无类别区域间路由（CIDR）和路由聚合"></a>无类别区域间路由（CIDR）和路由聚合</h2><div class="story post-story"><p>为了解决刚刚提到的问题，我们使用CIDR。原理很简单，我们将IP地址重新设定为 <code>a.b.c.d/x</code>，x代表了IP地址的网络号，可以为任意值。这样我们就可以在灵活分配子网大小的同时，简化我们路由保存的转发表。</p><p>在实践中，我们就得到了路由聚合的概念。我们的路由器只需要保存开头x位的某个IP地址应当转发给哪个子网，而不需要关心子网内数据包是如何传递的。可能在子网内存在其他子网，但是发包的路由器并不关心。这种情况我们就称作路由聚合。</p><p><em>顺便一提，某些IP地址是协议规定的保留地址。比如127.0.0.1 (01111111 00000000 00000000 00000001) 是环回地址，也就是当前所在的主机，也叫做 <code>localhost</code>，实际上环回地址有 1,600,000 以上个，从127.0.0.1到127.255.255.255均为环回地址。</em></p><p><em>255.255.255.255是广播地址，向广播地址交付报文会让该报文被发送到该子网内的每个主机。当然，这是路由器的转发表保存的数据决定的，路由器在收到目的地是255.255.255.255地址的数据包之后，它会向它子网内的所有主机发该数据包。</em></p></div><h2 id="IP地址获取"><a href="#IP地址获取" class="headerlink" title="IP地址获取"></a>IP地址获取</h2><div class="story post-story"><p>我们已经做好了如何给IP地址分类，接下来简单讲一下IP地址是如何获取的。最简单的是由你的互联网服务提供商（ISP）提供，ISP自己有一个地址段，而后他可以将地址段划分为子网并交付给用户。如下例子（尖括号的部分是主机号，而中括号的部分是<strong>子组织相较于ISP地址增加的网络号</strong>）：</p><figure class="highlight c"><figcaption><span>ISP分配</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ISP得到的地址 <span class="number">200.23</span><span class="number">.16</span><span class="number">.0</span>/<span class="number">20</span> <span class="number">11001000</span> <span class="number">00010111</span> <span class="number">0001</span>&lt;<span class="number">0000</span> <span class="number">00000000</span>&gt;</span><br><span class="line"></span><br><span class="line">组织A <span class="number">200.23</span><span class="number">.16</span><span class="number">.0</span>/<span class="number">23</span> <span class="number">11001000</span> <span class="number">00010111</span> <span class="number">0001</span>[<span class="number">000</span>]&lt;<span class="number">0</span> <span class="number">00000000</span>&gt;</span><br><span class="line">组织B <span class="number">200.23</span><span class="number">.18</span><span class="number">.0</span>/<span class="number">23</span> <span class="number">11001000</span> <span class="number">00010111</span> <span class="number">0001</span>[<span class="number">001</span>]&lt;<span class="number">0</span> <span class="number">00000000</span>&gt;</span><br><span class="line">...</span><br><span class="line">组织G <span class="number">200.23</span><span class="number">.30</span><span class="number">.0</span>/<span class="number">23</span> <span class="number">11001000</span> <span class="number">00010111</span> <span class="number">0001</span>[<span class="number">111</span>]&lt;<span class="number">0</span> <span class="number">00000000</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么ISP的地址从哪儿来？答案是因特网名字和编号分配机构（ICANN）。ICANN是非营利组织，其不仅分配IP地址，也管理DNS根服务器，分配域名。</p><p>当然，还有一种方法，通常用于比较小的子网，就是动态主机配置协议（DHCP）。主机每次连接到配置了DHCP的网络，都会获得一个临时的IP地址。除此之外，主机还可以得到当前子网的子网掩码，第一跳路由地址（我们现在一般叫做<strong>默认网关</strong>），本地DNS服务器地址。现在打开你的手机，进入网络设置并查看连接的无线局域网信息，你就可以看到这些内容。连接学校的局域网，学校也会提前告知你要使用DHCP。</p></div><h2 id="网络地址转换（NAT）"><a href="#网络地址转换（NAT）" class="headerlink" title="网络地址转换（NAT）"></a>网络地址转换（NAT）</h2><div class="story post-story"><p>需要意识到的是，以上我们所有的工作都不过是在给我们的 4,294,967,296 个IP地址做分类，这也是我错误思想的来源。</p><p><strong>子网并不代表整个网络中的某两台主机可以分配相同的IP地址</strong>。想象一个身份证号或者手机号，其内容是不能重复的，对其不同段做分类只是为了方便罢了。即使是划分了子网，不同子网间的IP地址也必须是不同的。这实际上很好理解，如果他们相同，那路由算法将会被破坏。路由器不知道应该向谁发包，或者总有一个主机收不到包，因为路由表在较短的网络号处截断并转发（想象路由器发送所有212.144.*.*到路由器A，路由器A是212.144.1.1/12，而路由器B是212.144.1.1/16）。</p><p>为了解决IP枯竭问题，人们从1993年开始使用了NAT技术，并通过RFC 1918协议定义了一部分IP地址使其专门用于NAT网络内部地址分配。这样的网络叫做<strong>专用网</strong>或者<strong>私有网</strong>。以下是RFC 1918规定的IP块：</p><figure class="highlight c"><figcaption><span>RFC 1918</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">规定区块名   IP地址区块                   IP数量</span><br><span class="line"><span class="number">24</span>位区块    <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span> – <span class="number">10.255</span><span class="number">.255</span><span class="number">.255</span>       <span class="number">16</span>,<span class="number">777</span>,<span class="number">216</span></span><br><span class="line"><span class="number">20</span>位区块    <span class="number">172.16</span><span class="number">.0</span><span class="number">.0</span> – <span class="number">172.31</span><span class="number">.255</span><span class="number">.255</span>     <span class="number">1</span>,<span class="number">048</span>,<span class="number">576</span></span><br><span class="line"><span class="number">16</span>位区块    <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span> – <span class="number">192.168</span><span class="number">.255</span><span class="number">.255</span>   <span class="number">65</span>,<span class="number">536</span></span><br></pre></td></tr></table></figure><p>专用网通过<strong>网关</strong>来完成地址转换。我们现在自己使用的，提供无线局域网连接服务的路由器都做了NAT地址转换，因此提供WiFi的路由器也就是该私有网的网关。拿我自己的路由器为例，在私有网，其IP地址是192.168.1.1，访问该地址也会进入路由器的管理界面。我的所有设备的网关都是192.168.1.1，每个设备通过DHCP获得自己在私有网络的地址，将数据包交给网关做转发。而查看路由器自己的设置，可以看到路由器在外部网络的地址是172.26.55.113，也是通过DHCP获得IP地址。根据RFC 1918，这个地址仍然是一个私有地址。实际上，这是大学校园私有网络的地址。并且，路由器的网关是172.26.0.1，这就是大学校园私有网络的流量出口。在此处，校园网私网地址被翻译成更高一级的公网地址进行通信。</p><p>私有网络必须要有不同于公网的IP，因为如果出现了公网IP，那么当一个主机要发给此IP时，网关的路由就不确定这个数据包到底是要给私网内的主机，还是转发出去。</p><p>那么，通信是如何完成的？以网络地址端口转换（NAPT）为例，假设现在的网络是我的路由器创建的私有网，从我的手机(192.168.1.101)发送的数据，到达网关(192.168.1.1)后，网关会将其转为(172.26.55.113:Port)，再发往下一级路由。这样一层一层包裹，数据包能够最终到达公网。同样的，接收的数据会被网关根据端口号一层一层地解开，到学校局域网的一层时，学校网关(172.26.0.1)将会收到一个发往172.26.55.113:Port的包，那么学校网关将会把包路由到172.26.55.113，我的路由器则会根据Port将数据包路由回我的手机。</p><p>当然，如果私网内的某个IP用了两个端口，那么网关也会为其映射两个到外部的端口，以便进行通信。</p><p>NAT的好处在于，私网内的用户非常安全。如果不主动发送信息，那么公网将无法与其进行通信。而坏处是，NAT下的主机实际上没有真正的IP地址，不能参与某些网络协议，比如某些必须从外部建立的UDP协议。举例来说，任天堂说我的NAT类型是D不让我玩联机游戏。</p></div><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><div class="story post-story"><p>子网和私网不是一个概念。不过，路由器创建的网络仍然可以被称作一个子网，只不过这个子网并不属于一个大的互联网。如果要谈论<strong>获取公网IP</strong>，实际上我们谈论的是一个跳出NAT的过程。比较常用的是端口映射，也就是说我将私网内的IP<strong>固定</strong>映射到网关的公网地址的某个端口上去，这样其他用户就可以通过访问<code>网关公网IP:Port</code>来进行通信。当然，这样的方法似乎只能跳出一层NAT。</p></div>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造玩具版 Java 虚拟机 Lab1 - 软件工程课程作业 (待更新)</title>
      <link href="Programming/vjvm-lab1/"/>
      <url>Programming/vjvm-lab1/</url>
      
        <content type="html"><![CDATA[<p>Java 代码以类为基础。在编译时，每个类都会生成一个<code>.class</code>文件，其中用16进制字节码保存了JVM运行程序需要的各种信息。虚拟机读取信息，就可以执行程序。根据这个原理，我们可以用 Java 写一个 Java 虚拟机，这真是太有趣了（棒读）。</p><p>本程序使用 OpenJDK 1.8，使用 Gradle 构建并使用了 lombok 插件。如果使用IDEA，请在手动在项目设置里修改为 OpenJDK 1.8；提到的 lombok 插件非常便利，在自己编写程序时也有多次用到，比如最简单的应用是可以在抛出异常的地方写一个 <code>@SneakyThrow</code>，这样程序员就不用麻烦的为一个自己无法处理的异常写一个 <code>try-catch</code> 包裹了。</p><h2 id="Java-字节码"><a href="#Java-字节码" class="headerlink" title="Java 字节码"></a>Java 字节码</h2><div class="story post-story"><p>在一切开始之前，我们需要先了解 Java 字节码的结构。你可以用任何16进制编辑器查看<code>.class</code>文件，或者你可以使用<code>javap $&#123;target&#125; -verbose</code>来用人类可以读懂的方式查看其内容。下图展示了<code>.class</code>文件顺序排列的结构。一个固定长度的小块块代表了一个 Byte。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://s2.loli.net/2022/05/10/gnfljGtIoRTBwQN.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/10/gnfljGtIoRTBwQN.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="字节码结构示意图"></div><span class="image-caption">字节码结构示意图</span></div><h3 id="魔数和版本号"><a href="#魔数和版本号" class="headerlink" title="魔数和版本号"></a>魔数和版本号</h3><p>最开始的魔数 <code>0xCAFEBABE</code>，或者 3405691582 (int)，标志着这是一个 Java 虚拟机可运行的字节码文件，真是独特（Cafe Babe = 看板娘？）。接下来两个 short 存储了编译的副、主版本号。JVM在执行的时候也会检查自己能否运行该版本号的字节码。</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>首先，常量池计数器占用一个 short。它记录了 <code>cp_info</code> 即常量池项的个数，注意到常量池计数器是从1开始的，所以常量池项将会有<code>constant_pool_count - 1</code>个，因为偶尔会需要有一个引用“不指向任何常量”，即索引0。又注意到计数器因为是16比特存储，因此常量个数不能超过65534个（如果你在一个类里面写了这么多常量，那你应该思考一下设计模式）。</p><p>随其后的是不定长度的常量池数据区。如果它不定长度，那么我们如何读取呢？请打开我们的<a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf">手册</a>并翻到4.4节常量池（在78页）。我们可以看到，每个 <code>cp_info</code> 的结构是：</p><figure class="highlight c"><figcaption><span>cp_info</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u1 info[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据一个字节的类型标记，我们可以<code>info[]</code>到底是什么。比如，一个<code>CONSTANT_Utf8_info</code>结构，即字面常量结构在4.4.7被介绍，其结构如下：</p><figure class="highlight c"><figcaption><span>CONSTANT_Utf8_info</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 length;</span><br><span class="line">    u1 bytes[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这个原理，我们每次首先判断其是什么类型，再按照类型读取数据。建议随便写一个程序，然后利用<code>javap</code>观察一下，看看它存放了什么字面数据，别的数据又是如何被存放的。</p><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>访问标志就是你在程序里写的public, private, final, abstract等等。其具有两个字节，并且其是一个掩码结构。我们暂且不需要知道所有的访问标志都是什么，只需要知道计算这块区域的方式是将所有的访问标志求和即可，举例来说，假如有一个公开接口，其具有的访问标志有<code>PUBLIC</code>的值是<code>0x0001</code>，<code>INTERFACE</code>的值是<code>0x0200</code>，那么访问标志就是<code>0x0201</code>。</p><h3 id="类索引与父类索引"><a href="#类索引与父类索引" class="headerlink" title="类索引与父类索引"></a>类索引与父类索引</h3><p>这里的类索引和父类索引都分别占有两个字节，存储一个指向常量池中<code>CONSTANT_Class_info</code>的索引。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>首先具有接口数量信息，接着有该数量个接口数据信息。注意接口数据信息只是一个两字节的，指向常量池中<code>CONSTANT_Class_info</code>的索引。</p><h3 id="字段与方法"><a href="#字段与方法" class="headerlink" title="字段与方法"></a>字段与方法</h3><p>字段和方法相当类似，其开头都会有一个计数器，而后跟随一串数据，这些数据拥有这样的结构：</p><figure class="highlight c"><figcaption><span>field_info</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">    u2 access_flags;</span><br><span class="line">    u2 name_index;</span><br><span class="line">    u2 descriptor_index;</span><br><span class="line">    u2 attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>method_info</code>也是一模一样的。我们可以看到一个字段或方法拥有访问标志，具有其名字和描述符索引，属性计数器和属性等。</p><p>我们必须注意到的是，这个结构中也具有“属性”这个结构，即<code>attribute_info</code>。也就是说字段、方法和类文件都具有属性。实际上，方法是如何被执行的，即JVM的字节操作码就记录在<code>method_info</code>里的<code>attribute_info</code>内，并且其具体的属性是<code>Code</code>。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>我们暂时不需要关心属性(attribute)的部分，但是我还是把其结构表示出来：</p><figure class="highlight c"><figcaption><span>attribute_info</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u1 info[attribute_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在写代码的时候会用到，并且之后实现真正运行程序的时候也是必要的。除了上面提到的<code>Code</code>属性以外，还存在常量<code>ConstantValue</code>，异常<code>Exception</code>等等。</p></div><h2 id="程序框架"><a href="#程序框架" class="headerlink" title="程序框架"></a>程序框架</h2><div class="story post-story"><p>在 VJVM 项目的<code>src</code>目录中存放了所有的程序源代码，我们可以先观察一下其结构。不需要关心的部分被我去掉了。</p><figure class="highlight plain"><figcaption><span>Source File Tree</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── main</span><br><span class="line">│   └── java</span><br><span class="line">│       └── vjvm</span><br><span class="line">│           ├── classfiledefs</span><br><span class="line">│           │   ├── ...</span><br><span class="line">│           ├── classloader</span><br><span class="line">│           │   ├── JClassLoader.java</span><br><span class="line">│           │   └── searchpath</span><br><span class="line">│           │       ├── ClassSearchPath.java</span><br><span class="line">│           │       └── ModuleSearchPath.java</span><br><span class="line">│           ├── runtime</span><br><span class="line">│           │   ├── JClass.java</span><br><span class="line">│           │   └── classdata</span><br><span class="line">│           │       ├── ConstantPool.java</span><br><span class="line">│           │       ├── FieldInfo.java</span><br><span class="line">│           │       ├── MethodInfo.java</span><br><span class="line">│           │       ├── attribute</span><br><span class="line">│           │       │   ├── ...</span><br><span class="line">│           │       └── constant</span><br><span class="line">│           │           ├── ClassConstant.java</span><br><span class="line">│           │           ├── ...</span><br><span class="line">│           │           └── UnknownConstant.java</span><br><span class="line">│           ├── utils</span><br><span class="line">│           │   └── UnimplementedError.java</span><br><span class="line">│           └── vm</span><br><span class="line">│               ├── Main.java</span><br><span class="line">│               └── VMContext.java</span><br><span class="line">└── test</span><br><span class="line">    └── ...</span><br></pre></td></tr></table></figure><p>我们首先从目录<code>main/java/vjvm/vm</code>看起。这里有程序的入口，我们可以暂不关心。构造 VJVM 的程序员使用了 lombok 来简化程序的使用，我们可以理解为编译好程序运行后为其提供一些参数，由程序入口来处理。接下来 VMContext 就是接收查找目录并生成类加载器实例。</p><p>所以，我们来看<code>main/java/vjvm/classloader</code>，即类加载器。我们可以看到该目录下还有一个<code>searchpath</code>，我们合理的推测其是类加载器的成员。因为我们可能到运行时才知道我们需要从何处，比如文件内或是jar包内，或者是其他情况。因此需要动态绑定，面向接口编程。</p><p>JClassLoader 在对应路径加载到编译好的类文件后，其用得到的文件，根据代码实际内容来看是 <code>DataInputStream</code> 类型，即二进制数据流，和其本身创建一个 JClass。这带领我们来到<code>main/java/vjvm/classdata</code>目录。在这里我们需要实现读取一个类的内容。根据之前字节码的介绍，比较棘手的是常量池，字段方法属性信息等等。</p><p>其他有省略号的文件均不是本次 Lab 需要考虑的内容。</p></div><h2 id="构造查找类文件的代码"><a href="#构造查找类文件的代码" class="headerlink" title="构造查找类文件的代码"></a>构造查找类文件的代码</h2><div class="story post-story"><p>如果我们想要读取<code>.class</code>文件内容，首先该找到<code>.class</code>文件在哪里。</p><h3 id="类加载类"><a href="#类加载类" class="headerlink" title="类加载类"></a>类加载类</h3><p>我们首先来阅读一下框架给出的<code>JClassLoader</code>。</p><figure class="highlight java"><figcaption><span>JClassLoader.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JClassLoader</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> JClassLoader parent;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassSearchPath[] searchPaths;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, JClass&gt; definedClass = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">// Stores its creator</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> VMContext context;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// constructor</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JClass <span class="title">loadClass</span><span class="params">(String descriptor)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 以下的代码在这里</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@SneakyThrows</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先看属性，它具有一个同类型的parent，一个搜索路径列表和一个描述符对应JClass的的哈希表。</p><p>我们要知道Java加载类通过使用Parent-First优先策略，一个Loader得到一个路径，首先会交给父Loader查找，如果找不到再自己进行查找。而查找的路径就是ClassSearchPath。接下来完成loadClass()方法。</p><p>我们首先对类名字和路径做一下处理。Java类描述符大概长这样：<code>Ljava/lang/Object;</code>。如果换为路径，就是<code>java/lang/Object</code>，再用点更换斜杠，就得到了类名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String dir = descriptor.substring(<span class="number">1</span>, descriptor.length() - <span class="number">1</span>);</span><br><span class="line">String name = descriptor.substring(<span class="number">1</span>, descriptor.length() - <span class="number">1</span>).replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;.&quot;</span>);</span><br></pre></td></tr></table></figure><p>接下来看一下是否已经加载过，并丢给双亲加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.definedClass.containsKey(name)) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.definedClass.get(name);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">   parentFoundClass = <span class="keyword">this</span>.parent.loadClass(descriptor);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果双亲找到了，就返回双亲的。否则，自己去找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (parentFoundClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span>(ClassSearchPath p : <span class="keyword">this</span>.searchPaths) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p.findClass(dir) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      JClass tmp = <span class="keyword">new</span> JClass(<span class="keyword">new</span> DataInputStream(p.findClass(dir)), <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">this</span>.definedClass.put(name, tmp);</span><br><span class="line">      <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> parentFoundClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段代码其实涉及到一个<strong>风格问题</strong>。几天前看过的一个视频中提到，应该尽量少在代码中使用Else，这样可以减少嵌套。因此，我们这样修改一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (parentFoundClass != <span class="keyword">null</span>) &#123; <span class="keyword">return</span> parentFoundClass; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(ClassSearchPath p : <span class="keyword">this</span>.searchPaths) &#123;</span><br><span class="line">    <span class="comment">// 这里的findClass方法将在后面提到</span></span><br><span class="line">    <span class="keyword">if</span>(p.findClass(dir) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        JClass tmp = <span class="keyword">new</span> JClass(<span class="keyword">new</span> DataInputStream(p.findClass(dir)), <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.definedClass.put(name, tmp);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>通过把最开始的判等换为判不等，我们得到了一个<strong>守卫语句</strong>（Guard Clause）。这是在代码中减少使用嵌套的好办法。</p><h3 id="类加载路径类"><a href="#类加载路径类" class="headerlink" title="类加载路径类"></a>类加载路径类</h3><p>我们这样并没有完成构造，因为我们没有完成ClassSearchPath。在这里使用多态的原因是，我们的类可能来自于一个路径，也可能来自一个Jar包；在未来，可能有更多不同的路径。</p><p>我们在ClassSearchPath中有一个静态方法。通过调用这个静态方法，我们可以在不实例化任何类的时候，根据参数构建多个SearchPath。这是一个<strong>工厂模式</strong>的设计实例。</p><figure class="highlight java"><figcaption><span>ClassSearchPath内部方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ClassSearchPath[] constructSearchPath(String path) &#123;</span><br><span class="line"></span><br><span class="line">  String sep = System.getProperty(<span class="string">&quot;path.separator&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Split the path to array</span></span><br><span class="line">  String[] pathArray = path.split(sep);</span><br><span class="line">  ClassSearchPath[] tmp = <span class="keyword">new</span> ClassSearchPath[pathArray.length];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Implement different class for different path</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pathArray.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pathArray[i].endsWith(<span class="string">&quot;.jar&quot;</span>))&#123;</span><br><span class="line">      tmp[i] = <span class="keyword">new</span> JarSearchPath(pathArray[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp[i] = <span class="keyword">new</span> DirSearchPath(pathArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> InputStream <span class="title">findClass</span><span class="params">(String name)</span></span>;</span><br></pre></td></tr></table></figure><p>而我们每一个具体的SearchPath都要override父类的findClass()方法，拿路径搜索举例：</p><figure class="highlight java"><figcaption><span>DirSearchPath内部方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String searchDir;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DirSearchPath</span><span class="params">(String dir)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.searchDir = dir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">findClass</span><span class="params">(String dir)</span> </span>&#123;</span><br><span class="line">  String fileDir = <span class="keyword">this</span>.searchDir + System.getProperty(<span class="string">&quot;file.separator&quot;</span>) + dir + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open it directly</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FileInputStream(fileDir);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="构造读取字节码内容的代码"><a href="#构造读取字节码内容的代码" class="headerlink" title="构造读取字节码内容的代码"></a>构造读取字节码内容的代码</h2><div class="story post-story"><p><strong>待更新。</strong></p></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> Java Virtual Machine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式：观察者模式与装饰者模式</title>
      <link href="Programming/design-pattern-1/"/>
      <url>Programming/design-pattern-1/</url>
      
        <content type="html"><![CDATA[<p>通过自己举出的一些设计例子，配合代码，学习观察者模式和装饰者模式。这篇文章包含了两个不相关的内容，分别对应书上两个不同的章节。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><div class="story post-story"><p>假设目前我们有一位教务处老师，这位老师希望同学们帮他制作一个电子公告栏。亲切的教务处老师送给我们一段源码。</p><figure class="highlight java"><figcaption><span>ManagementSys类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManagementSys</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String courseName;</span><br><span class="line">    <span class="keyword">private</span> String courseSchedule;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCourseName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCourseSchedule</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infoChanged</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>教务处老师给出了获得课程信息，课程时间，授课老师等等一系列的<code>getter</code>方法。而且，每次老师获得新信息之后，都会调用一个<code>infoChanged()</code>方法。我们不需要在意<code>getter</code>的具体实现，只需要根据信息写电子版程序即可。我们很容易得到思路，首先，我定义一个可以显示内容的公告栏类，比如说开课栏目公告栏、开课时间公告栏等等，再为公告栏类增加<code>update()</code>方法来更新内容，因此…</p><figure class="highlight java"><figcaption><span>infoChanged()方法实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infoChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String courseName = getCourseName();</span><br><span class="line">    String courseSchedule = getCourseSchedule();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    courseAvailableDisplay.update(courseName, ...);</span><br><span class="line">    courseScheduleDisplay.update(courseSchedule, ...);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这应该是大部分人直觉中的方法，至少是我的。但是，这违反了我们曾经学习的设计原则。首先，我们没有封装变化的部分，大家的<code>update()</code>至少在形式上是一致的，应该被封装起来；其次，我们现在面向实现编程，也就是说，我们把<code>infoChanged()</code>将会更新哪些公告板写死在代码中。如果我们未来想要添加新的展板，我们不得不也修改这里的代码，并且我们将无法做到在运行时动态的改变是否更新某个告示板。不太好！</p><p>于是，我自己提出了一个解决方案，我打算让这些公告栏都继承自主公告栏类，这样它们就拥有相同的<code>update()</code>方法，当然我也可以用继承加多态的方式直接遍历所有<code>Display</code>对象，就如同下面这样：</p><figure class="highlight java"><figcaption><span>ManagementSys类内部</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span> ArrayList DisplayList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ManagementSys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DisplayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infoChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DisplayList.size(); ++i)&#123;</span><br><span class="line">        DisplayList.get(i).update(foo, bar, ...); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>将对象添加到数组的过程就相当于同意接受更新，也可以动态去除。我们来看看我们提出的土方法和观察者模式之间有何异同。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>观察者模式</strong>定义了对象之间的一对多依赖，这样一来当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。观察者模式将会设计一个主题(Subject)接口，其方法有添加观察者、去除观察者和通知观察者；以及一个观察者(Observer)接口，拥有更新的方法。具体的主题总是会实现主题接口，而具体的观察者将会实现观察者接口。</p><p>观察者模式提供的设计允许主题和观察者之间<strong>松耦合</strong>。这是什么意思？松耦合意味着两个对象之间可以交互，但是彼此并不明白各自的细节。主题只知道有某个类实现了观察者接口，但对于这个类是什么，将会做什么，主题不知道也不关心。如果我需要在其他地方使用主题或者观察者，那么可以轻易复用。这就带来了我们的第四个设计原则：<strong>为了交互对象之间的松耦合设计而努力。</strong></p><h3 id="重新设计"><a href="#重新设计" class="headerlink" title="重新设计"></a>重新设计</h3><p>根据我们已有的信息，我们来重新设计一下我们的系统，首先当然实现我们的主题-观察者接口。</p><figure class="highlight java"><figcaption><span>观察者接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;   <span class="comment">// 注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;     <span class="comment">// 移除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;              <span class="comment">// 通知，当主题有东西改变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(argu, ...)</span>   <span class="comment">//</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>有了接口之后，我们可以让<code>ManagementSys</code>实现接口…</p><figure class="highlight java"><figcaption><span>ManagementSys类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManagementSys</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList observers;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ManagementSys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; observers.size(); ++i)&#123;</span><br><span class="line">            Observer observer = (Observer)observers.get(i);</span><br><span class="line">            observer.update(foo, bar, ...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this.XX = XX;</span></span><br><span class="line">        infoChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infoChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不得不说，我们的土方法可以算是和观察者模式非常接近了，但是我们并没有把观察者和主题抽象成接口，也没有把存储观察者的ArrayList封装起来。对于单个项目来说，我想我们已经做的足够好了。不过，如果要讨论到可复用性，还是书上提出的方法更加完善。任何类只要实现了写好的接口就可以达到效果。这样，我们也可以针对性地修改我们的告示牌，只需要实现<code>Observer</code>接口，并在<code>update()</code>方法中选择自己需要的参数进行更新就可以了。</p><h3 id="内置的观察者模式"><a href="#内置的观察者模式" class="headerlink" title="内置的观察者模式"></a>内置的观察者模式</h3><p>Java API中有内置的观察者模式。<code>java.util</code>中包含基本的Observable类和Observer接口。与我们自己实现的观察者模式不同的是，它支持使用“推”和“拉”两种方式传递数据，同时在做之前需要调用<code>setChanged()</code>方法告知程序已经改变。但是，Java提供的“主题”是一个类，意味着你没有办法进行多继承，而且Observable具有Protected方法，这也会阻止你将Observable实例组合到你自己的类中。简直是我们之前所学的设计原则的灾难啊！</p><p>除了<code>java.util.Observable</code>，在其他各种地方也有类似的观察者模式的设计，比如Swing API中的JButton，其超类AbstractButton具有<code>AddListener()</code>的方法，允许你做到：当按钮被按下时，传递消息到所有的ActionListener中。ActionListener接口则有<code>actionPerformed()</code>方法，相当于本例子中的<code>update()</code>。这些会令人想到在 jQuery，MATLAB App Designer 等工具中编写回调函数。许多GUI框架大量使用了这种模式。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>上文提到的jQuery令我想起了一些事情。想象一下，<code>notifyObservers()</code>方法在循环中对所有观察者调用<code>update()</code>方法时，有一个观察者出现了问题，比如：过长甚至是死循环，抛出异常等等。这样将会打断<code>notifyObservers()</code>方法的整个过程。真不好！所以如果可以，我们应该用<strong>异步</strong>的办法解决这类问题。当然，成熟的GUI框架也都是如此做的。</p></div><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><div class="story post-story"><p>还记得上次的游戏公司吗？现在有新的工作了：你需要设计游戏里在NPC处售卖的武器。现在游戏里已经有一个原始的武器实现了。目前为止，每个武器都会有名字和返回价格的方法，其他的部分我们暂时不关心。</p><figure class="highlight java"><figcaption><span>Weapon超类及其子类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Weapon.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sword.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sword</span> <span class="keyword">extends</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name = <span class="string">&quot;Sword&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Axe.java</span></span><br><span class="line"><span class="comment">// Bow.java</span></span><br><span class="line"><span class="comment">// Spear.java</span></span><br><span class="line"><span class="comment">// Wand.java</span></span><br></pre></td></tr></table></figure><p>即所有的武器都继承自一个超类，各自实现自己的<code>cost()</code>方法。但是现在问题来了，如果只有这些单一的武器多没有意思啊，不会有人喜欢玩我们的游戏的。项目经理告诉你，我们打算做一个：</p><center>[<font color="#8A2BE2"> 稀有的 </font> <font color="#FF8C00"> 火焰附加 </font> <font color="#DB7093"> 恶灵退治 </font> <font color="#DC143C"> 吸血 </font> 长剑 <font color="#4169E1"> +3 </font>]</center><p>…怎么办？可不要说我们要实现下面的这个类：</p><figure class="highlight java"><figcaption><span>Can't believe I actually typed these</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RareFlameAspectUndeadSlayerVampireLongSwordPlusThree</span> <span class="keyword">extends</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我不想写他的构造函数了，但是你懂会出现什么的</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">173</span>,<span class="number">423.02</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，原始的武器实现严重违反了我们的设计原则：独立变化之处，少用继承。当然你可能想到了另一种思路，毕竟上面的那把炫酷剑，到头来说也是剑嘛。我们可以让剑HAS-A炫酷属性，不就解决问题了吗？</p><figure class="highlight java"><figcaption><span>尝试重设计 Weapon 类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hasFlameAspect</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hasVampire</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是书上给出的方案，但我觉得不够好，或者说完全不好，我甚至想不到如何计算价格，难道要遍历这些方法？书上的例子是否有些为了否定而否定呢？<br>HAS-A并不是无法解决这个问题。我想到，此时我们也许应该用到我们之前学习的策略模式，将炫酷属性封装起来，成为一个接口，具体的炫酷属性将会实现这个接口，并且再用一个ArrayList存储它们，现在我们就将变化之处独立出来了。如果游戏多了新的炫酷效果，那么我们只需要实现炫酷效果本身即可。</p><figure class="highlight java"><figcaption><span>策略模式的 Weapon 类设计</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Weapon.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    ArrayList allAbilities;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sword.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sword</span> <span class="keyword">extends</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        allAbilities = <span class="keyword">new</span> ArrayList&lt;WeaponAbility&gt;();</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;Sword&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>.cost = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAbility</span><span class="params">(WeaponAbility a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加入数组</span></span><br><span class="line">        <span class="comment">// 更新价格和名字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">WeaponAbility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> cost;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可能会实现属性的能力</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlameAspect</span> <span class="keyword">implements</span> <span class="title">WeaponAbility</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlameAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cost = <span class="number">109.3</span>;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;Flame Aspect&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看来其他的设计模式并不是不可行，我们也做到了使用组合不使用继承。但是毕竟我们这一节是讲装饰者模式嘛！装饰者模式究竟比我们以上的代码优越在何处？这需要我们理解我们的第五个设计原则：<strong>类应该对扩展开放，对修改关闭</strong>。可以用任何想要的行为扩展类，但是尽量不要修改类的代码。可能现在代码已经被写好，如果这个时候去修改Weapon类的属性，构造函数等等，就会出一些问题。装饰者模式严格遵守了开放-关闭原则，让我们看看这是怎么做到的。</p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>装饰者模式</strong>动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的方案。装饰者超类本身将会<strong>继承现有的超类</strong>。也就是说，在本例子中，装饰者超类和<code>Sword</code>类是同级别的。同时，装饰者的具体实现是继承了装饰者超类的。</p><p>等一下？不是不要使用继承要用组合吗？但其实，本处继承的重点是，要求装饰者和被装饰者必须是一样的类型。我们所做的事情是“类型匹配”，而非获得任何行为。当我们把装饰者和组件结合时，才是加入了新的行为。获得行为的方式是组合而来的。</p><h3 id="重新设计-1"><a href="#重新设计-1" class="headerlink" title="重新设计"></a>重新设计</h3><p>我们现在可以重新设计我们的武器属性了，首先，Weapon类不需要做任何变化，我们之前写好的Sword类也不需要变化，来看看装饰者的超类如何实现。</p><figure class="highlight java"><figcaption><span>WeaponDecorator 类实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WeaponDecorator</span> <span class="keyword">extends</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先别急着疑惑，我们再具体实现一个装饰者，这样就能具体看到它的作用了。</p><figure class="highlight java"><figcaption><span>Vampire 类实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vampire</span> <span class="keyword">extends</span> <span class="title">WeaponDecorator</span> </span>&#123;</span><br><span class="line">    Weapon weapon;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vampire</span><span class="params">(Weapon weapon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weapon = weapon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Vampire &quot;</span> + weapon.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200.3</span> + weapon.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，装饰者超类必须实现其父类需要改变的方法，而具体的装饰者将会override这些方法，并进行具体的改动。这样的行为可以让我们得到神奇的效果（我已经在兴奋了）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Weapon sellWeapon = <span class="keyword">new</span> Vampire(<span class="keyword">new</span> UndeadSlayer(<span class="keyword">new</span> FlameAspect(<span class="keyword">new</span> Rare(<span class="keyword">new</span> Sword()))));</span><br></pre></td></tr></table></figure><p>真是美丽又可怕！这立刻让我们想到了别的东西。</p><h3 id="真实世界的装饰者"><a href="#真实世界的装饰者" class="headerlink" title="真实世界的装饰者"></a>真实世界的装饰者</h3><p>装饰者竟在我身边，想想你曾经要做文件流读写的时候写过的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader iptStrm = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FIleInputStream(arg));</span><br></pre></td></tr></table></figure><p>这样看来，装饰者模式的缺点也非常明显了，因为这样嵌套的小类实在是太多了（比如我的一位朋友对于Java的印象就是：有很多new）。</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="story post-story"><p>来看看我们新学到的东西：</p><ul><li><strong>设计原则四：为了交互对象之间的松耦合设计而努力。</strong></li><li><strong>设计原则五：类要对扩展开放，对修改关闭。</strong></li><li><strong>观察者模式：定义对象之间的一对多依赖，这样一来当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</strong></li><li><strong>装饰者模式：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的方案。</strong></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solidity 语言的形式化规约</title>
      <link href="Programming/solidity-formal-specification/"/>
      <url>Programming/solidity-formal-specification/</url>
      
        <content type="html"><![CDATA[<p>智能合约与其他软件一样容易有错误和漏洞。在以太坊环境下，任何错误都伴随着潜在的对金融的破坏性结果。因此引入了形式化规约来验证操作。形式化规约存在相当多的形式，并拥有严谨的数学证明来描述系统行为，从<strong>事件所跟踪的具体的区块链上数据</strong>的角度来具体说明智能合约的行为。本文将给出两种不同的形式化规约。</p><h2 id="基于事件的形式化规约"><a href="#基于事件的形式化规约" class="headerlink" title="基于事件的形式化规约"></a>基于事件的形式化规约</h2><div class="story post-story"><p>一篇来自<a href="http://www.bme.hu/?language=en">BME</a>的论文介绍了基于事件的形式化规约，并给出了名为 <code>SOLC_VERIFY</code>的 验证程序。但是本文章只关心其提出的形式化规约说明。验证程序基于模块化程序验证，由Mike Barnett在其之前的<a href="https://link.springer.com/chapter/10.1007/11804192_17">论文</a>中提出，这与计算科学和程序语义等学科相关，不做讨论。</p><h3 id="智能合约事件介绍"><a href="#智能合约事件介绍" class="headerlink" title="智能合约事件介绍"></a>智能合约事件介绍</h3><p>本文介绍的方法主要用于依靠事件 (Event) 传递消息的 Solidity 程序。</p><p>Solidity 是面向合约的智能合约编程语言的代表。而事件代表了与用户相关的、有限的交易执行。合约可以利用事件传递链上数据的状态改变情况。技术上来说，事件可以看做有参数的触发器，其存储位置位于<strong>区块链的日志</strong>。这些日志是合约无法访问的，而用户却可以轻易的监听这些事件从而获得值。以往，事件往往是被认为是一种<strong>日志记录机制</strong>，与程序设计的正确性无关。然而，既然事件是DAPP中最主要的为用户设计的状态改变提示机制，确保用户正确理解且信任发送的事件是十分关键的。</p><p>Solidity 不为发送事件设置任何限制，因此错误的（或恶意的）合约可以发送与状态改变不一致的事件，或对于某些改变忽略发送事件，潜在的将会误导用户。</p><h3 id="语法举例"><a href="#语法举例" class="headerlink" title="语法举例"></a>语法举例</h3><p>请首先看已经加入形式化规约的 Solidity 演示代码：</p><figure class="highlight js"><figcaption><span>Solidity</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">contract Registry &#123;</span><br><span class="line">struct Entry &#123; bool set; int data; &#125; <span class="comment">// User-defined type</span></span><br><span class="line">mapping(<span class="function"><span class="params">address</span>=&gt;</span>Entry) entries; <span class="comment">// State variable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// @notice tracks-changes-in entries</span></span><br><span class="line"><span class="comment">/// @notice precondition !entries[at].set</span></span><br><span class="line"><span class="comment">/// @notice postcondition entries[at].set &amp;&amp; entries[at].data == value </span></span><br><span class="line">event new_entry(address at, int value);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @notice tracks-changes-in entries</span></span><br><span class="line"><span class="comment">/// @notice precondition entries[at].set &amp;&amp; entries[at].data &lt; value </span></span><br><span class="line"><span class="comment">/// @notice postcondition entries[at].set &amp;&amp; entries[at].data == value </span></span><br><span class="line">event updated_entry(address at, int value);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @notice emits new_entry</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">int value</span>) <span class="title">public</span> </span>&#123; </span><br><span class="line"><span class="built_in">require</span>(!entries[msg.sender].set); </span><br><span class="line">entries[msg.sender].set = <span class="literal">true</span>; </span><br><span class="line">entries[msg.sender].data = value; </span><br><span class="line">emit new_entry(msg.sender, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @notice emits updated_entry</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">int value</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line"><span class="built_in">require</span>(entries[msg.sender].set &amp;&amp; entries[msg.sender].data &lt; value); </span><br><span class="line">entries[msg.sender].data = value;</span><br><span class="line">emit updated_entry(msg.sender, value);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 演示代码非常简单，定义了一个 Entry 结构，和一个地址到 Entry 的映射的变量（在文章中叫做状态变量，<strong>state variable</strong>)；两个事件，一个代表新加入合约，另一个代表更新加入合约。以及添加和更新的函数。</p><p>首先，某个事件都跟随的是 <code>entries</code> 变量的变化，因此我们写出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; @notice tracks-changes-in entries</span><br></pre></td></tr></table></figure><p><code>tracks-changes-in</code> 关键字所说明的事实是：事件被触发<strong>当且仅当</strong>被跟踪的变量改变。由于数据经常以多步过程的形式改变（如例子中，函数依次更新了 Entry 结构中的两个数据），或者数据更新存在某种条件，因此事件不会总是立刻跟在某个追踪变量的改动后。因此，文章提出了前/后检查点的概念。前检查点是由事件所追踪的变量的第一次改变所动态的定义的。相对的，后检查点是一个静态边界，一般是循环或交易的边缘。<em>说白了就是，你的事件<strong>必须</strong>要在你跟的变量第一次改变之后，离开程序之前进行一次激发。</em></p><p>在跟随变量以外，事件也可以被用 <code>predicates</code> 来注释，它是用状态变量和事件的参数来定义的，并且有两种，<code>preconditions</code> 和 <code>postconditions</code>。前置条件在前检查点前捕捉状态变量的值，而后置条件对应着事件被发送的时刻。</p><p>举例来说，对于 <code>new_entry</code> 事件，其要求用户一开始不处于 <code>entries</code>，即<code>set</code> 布尔类型为假，且事件发出后用户属于<code>entries</code>，<code>data</code> 被赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; @notice precondition !entries[at].set</span><br><span class="line">&#x2F;&#x2F;&#x2F; @notice postcondition entries[at].set &amp;&amp; entries[at].data &#x3D;&#x3D; value </span><br><span class="line">event new_entry(address at, int value);</span><br></pre></td></tr></table></figure><p>最后，发射事件的函数必须被标记处发射了何等事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; @notice emits updated_entry</span><br><span class="line">function update(int value) public &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="基于函数的形式化规约"><a href="#基于函数的形式化规约" class="headerlink" title="基于函数的形式化规约"></a>基于函数的形式化规约</h2><div class="story post-story"><p>基于函数的形式化规约和基于事件的有很多相似之处（<em>并且是南大78004870课程所讲述的模式</em>），只是把修改变量的规约放在函数（与合约、循环）前。并且由于函数可以对值进行修改，而非像事件一样仅展现变化，所以会比基于事件的规约增加其他的东西。请看下例：</p><figure class="highlight js"><figcaption><span>Solidity</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @notice invariant x == y</span></span><br><span class="line">contract Track &#123;</span><br><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @notice precondition x == y</span></span><br><span class="line"><span class="comment">/// @notice postcondition x == (y + n)</span></span><br><span class="line"><span class="comment">/// @notice modifies x</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add_to_x</span>(<span class="params">int n</span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">x = x + n;</span><br><span class="line"><span class="built_in">require</span>(x &gt;= y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @notice modifies x if n &gt; 0</span></span><br><span class="line"><span class="comment">/// @notice modifies y if n &gt; 0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">int n</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line"><span class="built_in">require</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">add_to_x(n);</span><br><span class="line"><span class="comment">/// @notice invariant y&lt;=x</span></span><br><span class="line"><span class="function"><span class="title">while</span>(<span class="params">y &lt; x</span>)</span> &#123;</span><br><span class="line">y = y + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由例子，我们可以总结出基本的语句：</p><ul><li><p>如果某变量没有被改变，那么需要注明<strong>不变式</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invariant &lt;EXPRESSION&gt;</span><br></pre></td></tr></table></figure><p>注意，不变式出现在循环，合约，函数前。</p></li></ul><ul><li><p>如果函数开始前/结束后必须满足某条件，那么需要注明<strong>前置条件</strong>/<strong>后置条件</strong>，与基于事件的一样。</p></li><li><p>如果函数执行改变了状态变量，那么需要注明<strong>修改规约</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modifies &lt;TARGET&gt; [if &lt;CONDITION&gt;]</span><br></pre></td></tr></table></figure></li></ul><h3 id="进阶的规约表达"><a href="#进阶的规约表达" class="headerlink" title="进阶的规约表达"></a>进阶的规约表达</h3><p>课程同时给出了一些进阶的规约表达方式，例如：</p><ul><li><p>聚合计算的表达：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__verifier_sum_&lt;TYPE&gt;( ... )</span><br></pre></td></tr></table></figure><p>所代表了将 <code>&lt;TYPE&gt;</code> 相加所得到的结果。</p></li><li><p>复合数据类型判等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__verifier_eq(..., ...)</span><br></pre></td></tr></table></figure><p>其实就是更加复杂的 <code>x == y</code>。</p></li><li><p>变量旧值引用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__verifier_old_&lt;TYPE&gt;</span><br></pre></td></tr></table></figure><p><em>也许是在循环中引用上一次的值或者引用修改前的值</em>。</p></li><li><p>谓词逻辑表达：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">forall (&lt;VARS&gt;) &lt;QUANTEXPR&gt;</span><br><span class="line"></span><br><span class="line">exists (&lt;VARS&gt;) &lt;QUANTEXPR&gt;</span><br></pre></td></tr></table></figure><p>举例来说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forall (uint λ) !(λ &gt;&#x3D; 0 &amp;&amp; λ &lt; length)</span><br></pre></td></tr></table></figure></li></ul></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="story post-story"><p>形式化规约是一种让程序设计更加严谨的实现，而对于对准确度要求高的智能合约来说更加有用。即使没有检查器，掌握形式化合约也有助于形成良好的变量追踪与查询习惯。</p></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
            <tag> Solidity </tag>
            
            <tag> 智能合约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的以太坊智能合约部署</title>
      <link href="Programming/smart-contract/"/>
      <url>Programming/smart-contract/</url>
      
        <content type="html"><![CDATA[<p>可以简单的把以太坊虚拟机理解为一个公开使用的后端服务器，用户在其上拥有有限的操作空间，每次操作以交易的形式产生，并会根据修改数据的大小向用户收费，称为 <strong>Gas</strong>，以此支持服务器维护人员 (即矿工)。并且，服务器上的数据会被永久记录，操作后端数据的代码 (对于EVM，是 Solidity 代码) 也存放在服务器上不能被修改。</p><p>矿工可以根据 Gas 和数据操作量选择将哪一笔交易加入区块。因此 Solidity 编程要求存储尽量少的数据，节省空间和操作量，以此得到更快速的响应。</p><h2 id="使用-Remix-和-Ganache"><a href="#使用-Remix-和-Ganache" class="headerlink" title="使用 Remix 和 Ganache"></a>使用 Remix 和 Ganache</h2><div class="story post-story"><p><a href="https://remix.ethereum.org/">Remix</a> 是以太坊官方提供的 Solidity 开发环境。在 Remix 内写好代码后可以编译，编译会得到程序的二进制程序接口，称为 ABI。ABI 会提供给 web3.js 来提供操作接口。在编译后可以部署合约，Remix 本身提供了一些 JavaScript 虚拟机来运行智能合约。为了观察到用户和交易的情况，我们可以部署私有链，利用 Ganache。部署后会得到合约地址，你也可以直接在 Remix 和合约交互。</p><p><a href="https://trufflesuite.com/ganache/index.html">Ganache</a> 可以在本地设置好私有区块链，即开即用。用户可以自行设置端口号，而网络ID为5777而区块链ID为1337。在本地部署好之后，使用 MetaMask 钱包添加私有链。MetaMask 也可以使用其他测试链，虽然其他测试链可以有更多的用户，但在这些链上我们难以观察交易情况。添加私有链后，也记得添加私有链的账户。</p><p>说到账户，对于以太坊地址来说，所有链上的地址格式都完全一致。因此，你的任何一个账户都可以在任何链上使用（当然代币不会跟随）。可以尝试把 Ganache 里生成的账户的钱转入一个你主链的地址，操作将会成功且主链地址<strong>在私有链</strong>上的 ETH 会增加。注意 Ganache 不会追踪除了它生成的账户以外的账户（因为无穷多），但是你仍然可以看到 TX 信息，就在 Ganache 的操作面板。这到底是怎么做到的？得益于钱包地址的随机和海量，生成的两个地址相同的概率几乎是不可能的。</p></div><h2 id="Solidity-代码"><a href="#Solidity-代码" class="headerlink" title="Solidity 代码"></a>Solidity 代码</h2><div class="story post-story"><p>设计一个 Solidity 代码，对于每个账户存放一个数据，并且允许用户查看数据。</p><p>(<em>很遗憾，Hexo 对于 Solidity 代码暂时没有语法高亮，我也不想使用 hightlight.js，所以我随便选用了一种代码高亮模式。</em>)</p><figure class="highlight c#"><figcaption><span>Solidity</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明 License</span></span><br><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line"><span class="comment">// 声明编译器版本</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.7</span><span class="number">.0</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合约，就像一个类</span></span><br><span class="line">contract numberHolder &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射数据结构</span></span><br><span class="line">    mapping(address =&gt; uint16) userNumbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个事件</span></span><br><span class="line"><span class="function"><span class="keyword">event</span> <span class="title">numberSetted</span>(<span class="params">address addr,uint16 num</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地址的数据的setter函数</span></span><br><span class="line">    <span class="function">function <span class="title">setNumber</span>(<span class="params">uint16 inputNumber</span>) <span class="keyword">public</span></span>&#123;</span><br><span class="line">        userNumbers[msg.sender] = inputNumber;</span><br><span class="line">        <span class="comment">// 发送事件给前端</span></span><br><span class="line"><span class="function">emit <span class="title">numberSetted</span>(<span class="params">msg.sender, userNumbers[msg.sender]</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个只读函数获得用户地址和数据</span></span><br><span class="line">    <span class="function">function <span class="title">getNumber</span>(<span class="params"></span>) <span class="keyword">public</span> view <span class="title">returns</span> (<span class="params">uint16</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userNumbers[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">getAddress</span>(<span class="params"></span>) <span class="keyword">public</span> view <span class="title">returns</span> (<span class="params">address</span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> msg.sender;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体内容可以查看 Solidity 的<a href="https://solidity-cn.readthedocs.io/zh/develop/">文档</a>。函数发射的事件需要在前端进行监听。关键字 <code>view</code> 代表了这个函数不会操作数据。全局变量 <code>msg</code> 存储了一些当前合约的信息，例如 <code>msg.sender</code> 就是调用合约的地址。</p></div><h2 id="Web-代码"><a href="#Web-代码" class="headerlink" title="Web 代码"></a>Web 代码</h2><div class="story post-story"><p>Web 端我们使用以太坊 JavaScript API和后端交互，叫做 web3.js，使用此库类似于使用 jQuery 的 ajax。实际上，包括部署合约在内的操作都可以用 web3.js 完成，但本次我们不这样做。</p><p>在网页端，首先用简单 HTML 完成界面，给用户提示信息，显示一个可变文本并设置两个按钮：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>数字存放<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    在数据框中输入一个数字并点击上传数据，它将会被存储至区块，请注意这会消耗燃料。<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    点击获得数据将会显示您已经存储的数据，这不会消耗燃料。</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;info&quot;</span>&gt;</span>等待输入<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;data&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-2 control-label&quot;</span>&gt;</span>您的数据<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;data&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button_update&quot;</span>&gt;</span>上传数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button_download&quot;</span>&gt;</span>获得数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来在 <code>&lt;script&gt;</code> 部分设计网页的逻辑。别忘记把 web3.js 和 jQuery 加入到网页中。首先配置好我们的 web3 库：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    web3 = <span class="keyword">new</span> Web3(web3.currentProvider);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">&quot;http://localhost:8545&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这声明了，我们的 web3 是由 HTTP 在本地8545端口提供，也就是我们的 Ganache。接下来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.defaultAccount = web3.eth.accounts[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> contractABI = web3.eth.contract(<span class="comment">/* ABI Here */</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myContract = contractABI.at(<span class="string">&#x27;0x6f0D3623...&#x27;</span>)</span><br></pre></td></tr></table></figure><p>第一行代码说明了我们默认交互账户是 Ganache 里的第一个账户。我们现在还不将 MetaMask 链接功能提供在前端。MetaMask 要求前端网页不能是本地打开的，必须运行在一个服务器上 (Python 搭建的简易 HTTP 服务器就可以)，并且需要更复杂且完善的代码。第二行代码需要我们写入之前在 Remix 得到的 ABI，这是我们交互的基础。第三行就是合约本身，从语义上可以理解为：某个 ABI 位于某个确定的地址上。这个地址可以在 Remix 处看到，或在 Ganache 的 TX 信息里找到。</p><p>接下来我们来看一下在前端如何调用 Solidity 函数，并用 jQuery 改变前端显示。首先演示一下按钮如何获得数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#button_update&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">myContract.setNumber($(<span class="string">&quot;#data&quot;</span>).val());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;#button_download&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#info&quot;</span>).html(<span class="string">&#x27;您的地址：&#x27;</span> + myContract.getAddress.call() + <span class="string">&#x27;&lt;br&gt;&#x27;</span> + <span class="string">&#x27;您存储的数字：&#x27;</span> + myContract.getNumber.call() + <span class="string">&#x27;&lt;br&gt; 操作：读取数字&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对于 jQuery，简单的语法是利用 <code>$(&quot;#id&quot;)</code> 选中 HTML 对应 ID 的内容，在此是按钮类型。按钮类型具有 <code>click()</code> 方法，我们在内部写出一个函数，意思是“如果按钮被按下，那么执行这个函数，函数的内容是使用合约内的 setNumber() 函数，函数的参数是 HTML 中 ID 为 data 的元素的值”。对于下面获得值的操作，同理。 </p><p>再来看看怎么监听我们发出的事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eventSet = myContract.numberSetted()</span><br><span class="line">eventSet.watch(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">!error</span>)</span> &#123;</span><br><span class="line">        $(<span class="string">&quot;#info&quot;</span>).html(<span class="string">&#x27;您的地址：&#x27;</span> + result.args.addr + <span class="string">&#x27;&lt;br&gt;&#x27;</span> + <span class="string">&#x27;您存储的数字：&#x27;</span> + result.args.num</span><br><span class="line">        + <span class="string">&#x27;&lt;br&gt;&#x27;</span> + <span class="string">&#x27;操作：设置数字&#x27;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>基本原理同以上相同，我们将合约的 numberSetted 事件声明成一个变量，对这个变量进行 watch() 方法。里面的函数和刚才的差不多，它具有了两个参数。因为 web3 要求我们进行异常处理，即需要有 <code>if(!error) &#123;&#125; elese &#123;&#125;</code> 的形式。另一个参数 <code>result</code> 里面包含了我们在 Solidity 中写过的两个返回值。如果不太明白，可以在浏览器打开控制台观察一下 <code>log</code>，会完整展现 <code>result</code> 的结构。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://s2.loli.net/2022/03/29/9HjxGlDdiQqRuUv.png" class="lazyload" data-srcset="https://s2.loli.net/2022/03/29/9HjxGlDdiQqRuUv.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="网页的样子"></div><span class="image-caption">网页的样子</span></div></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="story post-story"><p>目前我们的前端已经可以在本地运行了。不过像这样直接链接私有链，利用索引选择调用合约的用户以及函数的处理方式都非常原始，只能作演示用。之后会尽量设计更完善的代码。</p></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
            <tag> Solidity </tag>
            
            <tag> 智能合约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题记录 - 键盘测试</title>
      <link href="Note/algorithm-0/"/>
      <url>Note/algorithm-0/</url>
      
        <content type="html"><![CDATA[<p>羊羊买了新键盘，并邀请大家来试用键盘，但前提是回答出以下问题。</p><blockquote><p>您将获得两个字符串s和t，两者都由小写的英文字母组成。您将逐个字符地键入字符串s，从第一个字符到最后一个字符。</p><p>特别之处在于，键入字符时，您可以按<code>Backspace</code>按钮，而不是按与之对应的按钮。<code>Backspace</code>会删除您刚刚键入的最后一个字符（如果您键入的字符串中没有字符，则不执行任何操作）。例如，如果s是”abcbd”，并且您按<code>Backspace</code>而不是键入第一个和第四个字符，您将获得字符串”bd”（第一次按<code>Backspace</code>不删除任何字符，第二次按删除字符”c”）。另一个例子，如果s是”abcaa”，并且您用<code>Backspace</code>键代替最后两个字母，则得到的文本为”a”。</p><p>您的任务是确定是否可以通过以上方式，从字符串s获取字符串t.</p></blockquote><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><div class="story post-story"><p>第一行是一个整数 q (1≤q≤10^5），代表测试用例的数量。<br>每个测试用例的第一行是字符串s (1≤s的长度≤10^5)，s中的每个字符是小写的英文字母。<br>每个测试用例的第二行是字符串t (1≤t的长度≤10^5)，t中的每个字符是小写的英文字母。</p><p>对于每个测试用例，如果可以按本题的方式从s得到t，请打印”YES“,否则，打印“NO”。</p><figure class="highlight text"><figcaption><span>Input</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">ababa</span><br><span class="line">ba</span><br><span class="line">ababa</span><br><span class="line">bb</span><br><span class="line">aaa</span><br><span class="line">aaaa</span><br><span class="line">aababa</span><br><span class="line">ababa</span><br></pre></td></tr></table></figure><figure class="highlight text"><figcaption><span>Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure></div><h2 id="初始想法"><a href="#初始想法" class="headerlink" title="初始想法"></a>初始想法</h2><div class="story post-story"><p>看到题目首先观察了 s 和 t 的联系。首先的想法如下：</p><ul><li>对于 s，首先寻找其中所包含的第一个 t[0]。如果没有 t[0]，那么肯定无法输出。</li><li>如果有 t[0]，接着去找 t[1]，看看两个字母之间的字母数是不是偶数个（打出，删除，打出，删除…）。如果不是，那么肯定无法输出。</li><li>如果还是，那么继续重复以上的步骤，直到 t 越界。</li></ul><p>遇到的问题：</p><ul><li>aababa 和 ababa 无法处理。说明如果 s 存在 t[0]，但完全无效，则应该去除 s 中 t[0] 即其之前的部分，重新进行测试。但是此方法只适用于 t[0]，因为实际上在符合要求的 t[0] 于 s 中出现之前，用户可以什么都不输入只按退格键。并且，这样的方法对于大数据来说太慢了。</li><li>本身的算法就非常难设计，需要三个指针，两个位于 s 标定位置，一个位于 t 指向当前的内容。</li></ul></div><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><div class="story post-story"><p>反向思考，如果说开头的东西可以忽视会让人难以处理，那么把开头放在最后就好了。同时，我们知道符合要求的字符串 s 的尾部要么和 t 完全一致，要么最后相差偶数个。所以最终的设计是，从 s 和 t 的尾部开始遍历，如果相同就同时前进 1 个字母，再比较；如果不同，则 s 前进2 个字母，再比较。直到 s 或 t 某个字符串结束。最后再判断 t 有没有结束。如果 t 结束了，那么答案就是 YES，此时 s 最开始的部分就是那些我们可以只按退格键的字符。</p><p>Python 代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">special_typing</span>():</span></span><br><span class="line">    stringNum = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(stringNum != <span class="number">0</span>):</span><br><span class="line">        stringS = <span class="built_in">list</span>(<span class="built_in">input</span>())</span><br><span class="line">        stringT = <span class="built_in">list</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">        comparePointer = <span class="built_in">len</span>(stringS) - <span class="number">1</span></span><br><span class="line">        current = <span class="built_in">len</span>(stringT) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(current &gt;= <span class="number">0</span>) <span class="keyword">and</span> (comparePointer &gt;= <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">if</span>(stringT[current] == stringS[comparePointer]):</span><br><span class="line">                current -= <span class="number">1</span></span><br><span class="line">                comparePointer -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                comparePointer -= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(current &lt; <span class="number">0</span>):</span><br><span class="line">            print(<span class="string">&quot;YES&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;NO&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        stringNum -= <span class="number">1</span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式：基本思想与策略模式</title>
      <link href="Programming/design-pattern-0/"/>
      <url>Programming/design-pattern-0/</url>
      
        <content type="html"><![CDATA[<p>知道继承，接口，多态和虚类不能让你学会面向对象程序设计。理解<strong>设计模式</strong>，因为设计模式是面向对象开发工程师们多年以来程序设计的经验总结，是为了解决问题而产生的历经验证的工程通用解决方案。良好的设计模式会包含可复用，可扩充，可维护三个特性，而模式可以帮我们做到这点。</p><p>首先来举个简单的例子，来展示继承所不能解决的问题。如图，某游戏公司程序员为自己游戏的职业系统设计了一个 Player 超类，所有的职业都会继承这个超类。在继承时，也会继承超类内所有的方法。如果需要新的职业，那么我们就添加一个新的类。完美！</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://s2.loli.net/2022/03/28/RJelt4WkrKUqCE8.png" class="lazyload" data-srcset="https://s2.loli.net/2022/03/28/RJelt4WkrKUqCE8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="美丽的UML图"></div><span class="image-caption">美丽的UML图</span></div><p>现在公司抛出了新的需求：要求玩家应该会闪避。这很好办，只需要在超类里加入一个 dodge() 方法即可。但是在测试的时候发现了新的问题：牧师会闪避导致了他过于强大的生存能力，以至于不需要队友保护他。这和游戏的设计理念不太符合，公司要求程序员让牧师不再会闪避。这也很简单，把 Priest 的 dodge() 方法的具体实现覆盖成什么都不做就可以了。到目前为止，一切都很好…</p><p>直到程序员意识到，公司为了赚钱每个月都会推出一款新职业，他们有的专注攻击不能防御，有的利用防御来攻击，有的……噢还有，公司还会推出氪金装备，使得 Priest 可以有限次的进行闪避动作。天啊，这要怎么办？来看看我们从最初的设计原则可以推出什么。</p><h2 id="变与不变"><a href="#变与不变" class="headerlink" title="变与不变"></a>变与不变</h2><div class="story post-story"><p>应用设计的第一个原则：<strong>找出应用中需要变化之处，将其独立，不要和不需要变化的代码写在一起</strong>。这样，每次新的需求来到，我们就可以不修改固定的部分，只修改变化的部分。</p><p>对于我们的游戏设计来说，我们知道 dodge() 是会随着职业的不同而改变的（<em>当然 attack() 和 defense() 也会变，但是原理是一样的</em> ）。那么我们把闪避行为拿出来，并为它创建一个类。<strong>所有的职业都将 HAS-A 闪避行为。</strong></p></div><h2 id="为谁而写"><a href="#为谁而写" class="headerlink" title="为谁而写"></a>为谁而写</h2><div class="story post-story"><p>应用设计的第二个原则：<strong>针对接口编程，不要针对实现编程</strong>。 说真的，我觉得这句话刚一看到非常难理解。</p><p>什么是实现？职业类如果实现了 dodge() 接口，那么就意味着所有职业都要实现这个接口，因为他们都继承自原始的超类。我们不要把什么类能实现什么在最开始的时候写死。</p><p>怎么针对接口编程？我设计一个 DodgeBehaviour 接口，此接口有 dodge() 方法。现在，我们让具体的类实现这个接口。DodgeNormal 类会正常的躲避，而 DodgeNaught 类什么都不做。现在，闪避行为和 Player 类没有任何关系了。我们可以随意添加闪避行为或者修改行为，比如我们为法师设计一个 DodgeKUXUAN，让闪避的时候会增加粒子效果。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://s2.loli.net/2022/03/28/NQL4YrXentSp9gx.png" class="lazyload" data-srcset="https://s2.loli.net/2022/03/28/NQL4YrXentSp9gx.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="另一个美丽的UML图"></div><span class="image-caption">另一个美丽的UML图</span></div></div><h2 id="完成设计"><a href="#完成设计" class="headerlink" title="完成设计"></a>完成设计</h2><div class="story post-story"><p>现在事情可能会变得有点奇怪，我们如何让某个职业进行闪避？请看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">  healthType Health;</span><br><span class="line">  DodgeBehaviour dodgeBehaviour;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performDodge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dodgeBehaviour.dodge();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们的超类。看，我们通过让职业 HAS-A 行为的方式成功地托管了闪避行为！这也就引出了我们的第三个设计原则：<strong>多用组合，少用继承</strong>。HAS-A is better than IS-A!</p><p>那么相对应的，子类的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Priest</span> <span class="keyword">extends</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Priest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dodgeBehaviour = <span class="keyword">new</span> DodgeNaught();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数里面，我们写好 Priest 会使用哪种 实现了 DodgeBahaviour 的类。不仅如此，如果我们对 dodgeBehaviour 设定一个 setter 函数，我们就可以在程序运行时改变牧师躲避的行为，比如牧师装备了氪金道具，那么就将 dodgeBehaviour 设定成可以闪避并计数，结束后改回去。这比写一个 ”可以进行10次闪避” 的 Priest 职业好太多了！</p><p>同理，攻击和防御方法都可以用相同的方式实现。以上的设计模式我们称为<strong>策略模式</strong>。策略模式<strong>定义且封装了独立于使用算法客户的算法族，使他们相互之间能够替换</strong>。这也不意味着继承方法真的没用了，比如所有的职业都需要走路，那么 walk() 方法就可以继承。关键点是确立好需求，并选择你需要的设计模式。</p><p>（<em>所以，这位程序员该好好跟他的产品经理吵一架 :P</em> ）</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="story post-story"><p>来看看我们目前学到的东西：</p><ul><li><strong>设计原则一：找出应用中需要变化之处，将其独立，不要和不需要变化的代码写在一起。</strong></li><li><strong>设计原则二：针对接口编程，不要针对实现编程。</strong> </li><li><strong>设计原则三：多用组合，少用继承。</strong></li><li><strong>策略模式：定义且封装了独立于使用算法客户的算法族，使他们相互之间能够替换。</strong></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重新记录我的博客</title>
      <link href="Thoughts/init_post/"/>
      <url>Thoughts/init_post/</url>
      
        <content type="html"><![CDATA[<p>两年前，我抱着玩玩的心态在 Github 上部署了一个小博客。然而搜肠刮肚发现自己既没技术，又没文笔，无甚可写，遂作罢。<br>近日和舍友闲谈，偶然间舍友提到了博客。突然想起了自己曾经弄的小站。再联想到自己最近需要学习，记忆力又狠狠衰退，于是打算把博客重拾起来。<br>为了避免自己又忘记什么重要的事，我把操作博客的方法都写下来。</p><h3 id="写作与更新"><a href="#写作与更新" class="headerlink" title="写作与更新"></a>写作与更新</h3><p>在部署时我就选择了 Hexo 托管页面。Hexo 是一个 Node.js 包，它能够自动生成网页，用户所需要做的只是写作。并且，它支持各种插件与主题。<br>使用如下代码在 <code>/source/_posts/</code> 内新建一个文件夹与 markdown 文件，名字为<code>name.md</code>。<code>name</code>也将组成这篇博客的 url 路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new name</span><br></pre></td></tr></table></figure><p>设置好以后，可以在本地<code>5000</code>端口部署测试页面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>待测试没问题后，push 到 Github 吧：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><p>等待几分钟就可以看到结果。</p><h3 id="配置和优化"><a href="#配置和优化" class="headerlink" title="配置和优化"></a>配置和优化</h3><p>关于配置，可以在 <a href="https://volantis.js.org/v5/getting-started/">Volantis 文档</a>内找到所有需要的内容，包括底栏侧栏导航栏配置等等。<br>对于 Post 的封面，我使用 <a href="https://www.canvas.cn/">Canvas 可画</a>来制作，按照微信公众号的标题随便做一个即可。<br>对于在文章内插图，我使用 <a href="https://sm.ms/">SM.MS</a> 图床。</p><h3 id="承诺"><a href="#承诺" class="headerlink" title="承诺"></a>承诺</h3><p>即使发一些毫无意义的 shitpost，我也尽量不会让博客停下来。拖延和懒惰的一部分来自于追求完美，会希望把事情做的足够好的想法，会导致人过分注重细枝末节而最后放弃。</p>]]></content>
      
      
      <categories>
          
          <category> Thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 想法 </tag>
            
            <tag> 记录 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
