<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>查看 Git 存储库中代码提交行数</title>
      <link href="Note/git-check-workload/"/>
      <url>Note/git-check-workload/</url>
      
        <content type="html"><![CDATA[<p>发现在某厂实习的同学有一个码力统计平台，可以看到写了多少代码。由此联想到，我们每次执行 Commit 的时候都可以看到控制台输出的文件行数增加减少的提示。因此此信息是被 Git 统计了的，那么当然可以在本地获取到，只不过获取的是单个存储库的内容。</p><p><del>我更好奇为啥 Gitlab 等 Git 端没有集成这个功能，是觉得意义不大吗</del></p><p>首先，我们来用 <code>git log</code> 获取当前存储库所有贡献者，并用 <code>sort -u</code> 去重。此处获得的名字是 <code>gitconfig</code> 设置的名字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">authors=$(git <span class="built_in">log</span> --format=<span class="string">&#x27;%aN&#x27;</span> | sort -u)</span><br></pre></td></tr></table></figure><p>接下来，我们来遍历这些名字，并根据作者名字获取<code>numstat</code>。</p><p>其中，<code>--pretty:tformat:</code>是一个空的自定义格式，表示我们将会忽略所有提交信息，这样我们的输出结果里只有<code>numstat</code>了。</p><p>最后，使用<code>awk</code>来统计数量即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一行一行读取名字</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$authors</span>&quot;</span> | <span class="keyword">while</span> <span class="built_in">read</span> name; <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 输出一个定宽名字</span></span><br><span class="line">    <span class="keyword">do</span> <span class="built_in">printf</span> <span class="string">&#x27;%-20s&#x27;</span> <span class="string">&quot;[<span class="variable">$name</span>]&quot;</span></span><br><span class="line">    </span><br><span class="line">    git <span class="built_in">log</span> --author=<span class="string">&quot;<span class="variable">$name</span>&quot;</span> --pretty=tformat: --numstat | awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        add += $1  # 累加添加的行数</span></span><br><span class="line"><span class="string">        subs += $2 # 累加删除的行数</span></span><br><span class="line"><span class="string">        loc += $1 - $2 # 计算总的代码行数变化</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    END &#123;</span></span><br><span class="line"><span class="string">        # 输出统计结果</span></span><br><span class="line"><span class="string">        printf &quot;[Add] %-6d [Removed] %-6d [Total] %-6d\n&quot;, add, subs, loc</span></span><br><span class="line"><span class="string">    &#125;&#x27;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>最终，我们可以把代码写成一行并用管道连接。可以做成一个<code>alias</code>，如果你想的话。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --format=<span class="string">&#x27;%aN&#x27;</span> | sort -u | <span class="keyword">while</span> <span class="built_in">read</span> name; <span class="keyword">do</span> <span class="built_in">printf</span> <span class="string">&#x27;%-20s&#x27;</span> <span class="string">&quot;[<span class="variable">$name</span>]&quot;</span>; git <span class="built_in">log</span> --author=<span class="string">&quot;<span class="variable">$name</span>&quot;</span> --pretty=tformat: --numstat | awk <span class="string">&#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;[Add] %-6d [Removed] %-6d [Total] %-6d\n&quot;, add, subs, loc &#125;&#x27;</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>这样就可以看到你写了多少行代码了。哇，好有用的功能啊。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Nivek]             [Add] 114514 [Removed] 1919   [Total] 112595 </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尝试在一台搭载 Ascend GPU 服务器上进行大模型推理</title>
      <link href="Note/inference-on-ascend-server/"/>
      <url>Note/inference-on-ascend-server/</url>
      
        <content type="html"><![CDATA[<p>真难搞，已老实。<del>好想要A100喔</del></p><h2 id="昇腾简介"><a href="#昇腾简介" class="headerlink" title="昇腾简介"></a>昇腾简介</h2><div class="story post-story"><p>华为设计发布了AI处理器（NPU），采用达芬奇架构，全面对标英伟达GPU并为人工智能提供全流程支持。我们平时也许对英伟达架构和其他开源AI框架比较熟悉，那么这里给出几个关键词的大概对应来更好地理解昇腾软硬件平台。</p><p>首先是硬件层：</p><blockquote><p>Atlas 硬件 (基于 Huawei Ascend 核心) &gt; Nvidia GPU (A100, H800..)</p></blockquote><p>其次是计算架构：</p><blockquote><p>CANN &gt; CUDA</p></blockquote><p>华为同样也有自己的深度学习框架，但也对第三方框架做出了适配：</p><blockquote><p>MindSpore 晟思 &gt; Tensorflow / Pytorch</p></blockquote></div><h2 id="服务器现状"><a href="#服务器现状" class="headerlink" title="服务器现状"></a>服务器现状</h2><div class="story post-story"><p>现有 Atlas 800 训练服务器，其拥有 8个 Atlas 300T（即 Ascend 910）。</p><p>服务器本身并不是华为，而是来自<code>烽火超微/长江计算</code>的<code>FitServer G420X V5</code>，在网络上鲜有资料。</p><p>服务器运行 BigCloud Enterprise Linux For Euler 21.10系统（应该就是openEuler，在中移官网上也显示出其本质是openEuler）。</p></div><h2 id="安装-CANN"><a href="#安装-CANN" class="headerlink" title="安装 CANN"></a>安装 CANN</h2><div class="story post-story"><p>CANN 分为几个版本，Toolkit是最全量的，其支持训练、推理、模型转换及其他应用开发。我们下载 <code>Ascend-cann-toolkit_8.0.RC2.alpha001_linux-x86_64.run</code> 并用 SFTP 上传到服务器。</p><h3 id="已失败-离线安装依赖"><a href="#已失败-离线安装依赖" class="headerlink" title="[已失败] 离线安装依赖"></a>[已失败] 离线安装依赖</h3><p>根据<a href="https://www.hiascend.com/document/detail/zh/canncommercial/80RC1/quickstart/quickstart/quickstart_18_0006.html">手册</a>，我们需要为系统安装第三方依赖，但服务器并无互联网连接。我们在本地启动一个Docker，并利用本地Docker下载包，上传到服务器安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br><span class="line">docker run -d -i -t --name bclinux centos /bin/bash</span><br></pre></td></tr></table></figure><blockquote><p> Docker 命令行知识</p><p><code>-d</code>以后台模式运行容器</p><p><code>-p 宿主机端口:容器端口</code> 将宿主机的端口映射到容器的某个端口</p><p><code>-i</code> 提供交互式bash（即使没有连接也保持STDIN开启）</p><p><code>-t</code>分配一个伪TTY</p></blockquote><p><em>这里回顾发现装错了，应该装 openEuler 的镜像的。不过这玩意真的有 Docker Image 吗？</em></p><p>BigCloud Enterprise Linux是中移基于CentOS自己包装的系统。因此我们装个CentOS8即可。这里记录一下CentOS出现的一些<code>yum</code>问题，由于CentOS已经停止更新，我们可以通过以下方式将其镜像设置为阿里云：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">minorver=8.5.2111</span><br><span class="line">sed -e <span class="string">&quot;s|^mirrorlist=|#mirrorlist=|g&quot;</span> \</span><br><span class="line">         -e <span class="string">&quot;s|^#baseurl=http://mirror.centos.org/\$contentdir/\$releasever|baseurl=https://mirrors.aliyun.com/centos-vault/<span class="variable">$minorver</span>|g&quot;</span> \</span><br><span class="line">         -i.bak \</span><br><span class="line">         /etc/yum.repos.d/CentOS-*.repo</span><br></pre></td></tr></table></figure><p>接下来我们使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install --downloadonly XXX --downloaddir=<span class="string">&quot;./pkgs&quot;</span></span><br></pre></td></tr></table></figure><p>就可以仅下载不安装rpm包了。</p><p>将安装好的<code>rpm</code>包拷贝到宿主机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp centos:/root/pkgs pkgs/</span><br></pre></td></tr></table></figure><p>并使用<code>rpm -ivh/-Uvh</code>安装。</p><p><strong>完全失败了。因为系统已经安装了很多包，同时需要安装的包也很多，相互间产生了循环依赖，手动解决的代价很大。</strong></p><h3 id="访问校园镜像"><a href="#访问校园镜像" class="headerlink" title="访问校园镜像"></a>访问校园镜像</h3><p>说服了服务器管理员允许集群访问校园镜像站。</p><p><del>还是社工好用啊.jpg</del></p><p>另：学校镜像站的IP地址是一个公网IP，在唐仲英楼。</p></div><h2 id="选择推理框架"><a href="#选择推理框架" class="headerlink" title="选择推理框架"></a>选择推理框架</h2><div class="story post-story"><p>已经有了算子，现在只需要推理框架就可以部署模型了。考虑以下几个备选：</p><ul><li><del>FastChat</del>  只支持使用单个 Ascend NPU 进行推理，能跑但效率感人，失败</li><li><del>MindIE</del>    没想到华为自己的框架都不支持这款服务器，失败</li><li><del>vLLM</del>      不支持 CANN</li></ul><p>暂时没有发现其他的框架。搁置。</p></div>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> LLM </tag>
            
            <tag> 昇腾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录 Vue 亲子组件遇到的坑和解决办法</title>
      <link href="Note/vue-component-control/"/>
      <url>Note/vue-component-control/</url>
      
        <content type="html"><![CDATA[<p>当有一个<code>el-dialog</code>在很多组件中都有用到，并且其逻辑一致，这个时候可以考虑把它抽象为一个单独的<code>.vue</code>文件。但此时组件和组件间无法传递<code>ref</code>类型，应该如何绑定<code>v-model</code>来控制组件的开启和关闭呢？使用什么办法给组件传递值呢？</p><h2 id="模版引用"><a href="#模版引用" class="headerlink" title="模版引用"></a>模版引用</h2><div class="story post-story"><p>如果我们直接使用<code>el-dialog</code>，一般都是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">  const dialogVisible &#x3D; ref(false)</span><br><span class="line"></span><br><span class="line">  func openLogic() &#123;</span><br><span class="line">    dialogVisible.value &#x3D; true</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;el-dialog v-model&#x3D;&quot;dialogVisible&quot;&gt;</span><br><span class="line">    &lt;!--  逻辑   --&gt;</span><br><span class="line">  &lt;&#x2F;el-dialog&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>我们可以直接操作是否显示。这是因为我们能够合理的使用 <code>openLogic()</code>。但如果这个组件内部只有一个<code>el-dialog</code>，即他被整体抽象出来了，我们就没地方执行<code>openLogic()</code>了。</p><p>这个时候就在亲组件里使用模版引用吧。以下是<code>componentDialog.vue</code>的核心部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">  const dialogVisible &#x3D; ref(false)</span><br><span class="line"></span><br><span class="line">  function open() &#123;</span><br><span class="line">    dialogVisible.value &#x3D; true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  defineExpose(&#123;</span><br><span class="line">    open</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;el-dialog v-model&#x3D;&quot;dialogVisible&quot;&gt;</span><br><span class="line">    &lt;!--  逻辑   --&gt;</span><br><span class="line">  &lt;&#x2F;el-dialog&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>向外界暴露了一个<code>open</code>方法。这个时候，在亲组件<code>parent.vue</code>里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">  const dialogRef &#x3D; ref(null)</span><br><span class="line"></span><br><span class="line">  function openLogic() &#123;</span><br><span class="line">    dialogRef.value.open()</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;componentDialog ref&#x3D;&quot;dialogRef&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>我们通过Vue的模版引用拿到了这个<strong>组件的引用</strong>。这样就可以执行组件暴露出的方法并完成<code>openLogic()</code>了。至于关闭，直接在子组件内定义即可。</p><h3 id="问题-ref的时机"><a href="#问题-ref的时机" class="headerlink" title="问题 - ref的时机"></a>问题 - ref的时机</h3><p>假设我的<code>componentDialog.vue</code>需要一些值，我们一般会想到使用props传递数据。那么当DOM被渲染的时候，组件就会试图拿到<code>parent.vue</code>中的数据，而这些数据可能在<code>parent.vue</code>执行一些逻辑后的后续的操作中才被初始化。</p><p>我遇到了这个问题，每次我打开<code>parent.vue</code>，子组件就会立刻被初始化，并且通过未初始化的值向后端发送请求，这导致了一些错误。我下意识的想法是使用<code>v-if</code>。</p><p>然而，<strong>模版引用并不是响应式的</strong>！<code>ref</code>只在DOM渲染的时候去获取对应的组件，然而最开始<code>v-if</code>是false，这就导致引用类型没有正常初始化，因为DOM也没有被渲染。当把<code>v-if</code>设定为true之后就去使用引用类型，则会报错。因为此时引用类型是<code>undefined</code>。这个坑对于<code>v-for</code>也是存在的。</p><p>我的解决方案是，仍然沿用问题一的逻辑，子组件暴露的函数需要一些参数，而亲代将需要的数据作为函数参数进行传递，这就推迟了子组件向后端索要数据的时机，从而避免错误。这样就弃用了亲传子常用的props属性。</p></div><h2 id="组件事件"><a href="#组件事件" class="headerlink" title="组件事件"></a>组件事件</h2><div class="story post-story"><p>子组件如何通知亲代组件关于某件事情的行为？使用组件事件即可。</p><p>子组件可以自定义一些事件，并在合适的时机触发这些事件。亲组件可以自定义一些函数和子组件的事件绑定。当子组件的事件被触发，亲组件相应绑定的函数就会被执行。</p><p>举例如下，<code> componentDialog.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">const emit &#x3D; defineEmits([&#39;operationFinish&#39;])</span><br><span class="line">  </span><br><span class="line">  func emitLogic() &#123;</span><br><span class="line">    emit(&quot;operationFinish&quot;, ...) &#x2F;&#x2F; 可选参数</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>parent.vue</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 同样可选参数</span><br><span class="line">  function handleLogic(...) &#123;</span><br><span class="line">    &#x2F;&#x2F; do sth</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;componentDialog @operation-finish&#x3D;&quot;handleLogic&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>你可以定义很多<code>emit</code>。这就完成了子传亲的行为。</p></div>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 标准库分析 - net/http (部分)</title>
      <link href="Programming/go-http/"/>
      <url>Programming/go-http/</url>
      
        <content type="html"><![CDATA[<p><strong>还没有写，哈哈</strong></p><h2 id="应用例"><a href="#应用例" class="headerlink" title="应用例"></a>应用例</h2><div class="story post-story"><h2 id="按执行顺序分析"><a href="#按执行顺序分析" class="headerlink" title="按执行顺序分析"></a>按执行顺序分析</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 标准库分析 - sync</title>
      <link href="Programming/go-sync/"/>
      <url>Programming/go-sync/</url>
      
        <content type="html"><![CDATA[<p><strong>挖坑慢填，尚未完工</strong></p><p>键入<code>go doc sync</code>你可以获得以下文档内容：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sync <span class="comment">// import &quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line">Package sync provides basic synchronization primitives such as mutual exclusion locks. Other than the Once and WaitGroup types, most are intended <span class="keyword">for</span> use by low-level library routines. Higher-level synchronization is better done via channels and communication.</span><br><span class="line"></span><br><span class="line">Values containing the types defined in this <span class="keyword">package</span> should not be copied.</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span></span><br><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>我们针对每个类型进行分析吧（顺序不按照上面给出）。</p><h2 id="sync-Locker"><a href="#sync-Locker" class="headerlink" title="sync.Locker"></a>sync.Locker</h2><div class="story post-story"><p>这个接口定义了锁结构必须实现的方法，也就是加锁和解锁，没有什么特别值得注意的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">Lock()</span><br><span class="line">Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面我们将看到很多原语都实现了这个接口。</p></div><h2 id="sync-Mutex-sync-RWMutex"><a href="#sync-Mutex-sync-RWMutex" class="headerlink" title="sync.Mutex / sync.RWMutex"></a>sync.Mutex / sync.RWMutex</h2><div class="story post-story"><p>顾名思义，这两个原语实现了互斥锁/读写互斥锁。</p></div><h2 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h2><div class="story post-story"><p>该原语能够确保某个函数只被执行一次。</p></div><h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><div class="story post-story"><p>该源于用于在一个 goroutine 中等待其他一组 goroutine 执行完毕。</p></div><h2 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h2><div class="story post-story"><p>这是一个并发池，用来安全地保存一组对象。当我们必须重用共享的和长期存在的对象（例如，数据库连接）时，或者需要优化内存分配时（使用<code>sync.Pool</code>可以防止GC后再分配）。</p></div><h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><div class="story post-story"><p>这是一个并发安全的<code>map</code>。当我们对<code>map</code>有频繁的读取和不频繁的写入，或者多个 goroutine 读取/写入/覆盖不相交的 <code>key</code> 时，我们使用 <code>sync.Map</code> 而不是普通的<code>map</code>配合<code>sync.Mutex</code>。</p><blockquote><p>注：Any race is a bug. 即使多个 goroutine 写入不相交map键，也会导致程序崩溃（<code>fatal error: concurrent map read and map write</code>），因为map的底层实现逻辑。关于底层逻辑之后再谈。</p></blockquote></div><h2 id="sync-Cond"><a href="#sync-Cond" class="headerlink" title="sync.Cond"></a>sync.Cond</h2><div class="story post-story"><p>很不常用地，这个原语用于发出一对一信号或广播信号。创建这个原语需要一个<code>sync.Locker</code>作为参数。</p></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang 包名的良好命名规范</title>
      <link href="Note/go-package-names/"/>
      <url>Note/go-package-names/</url>
      
        <content type="html"><![CDATA[<p><em>全文翻译自go.dev官方博客。其中穿插着一些自己的笔记。</em></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><div class="story post-story"><p>Go代码是以包进行组织的。在包内，代码可以引用其中定义的任何标识符。而包的客户（<em>即import该包的代码</em>）只能引用包的导出类型、函数、常量和变量（<em>以大写字符开头的</em>）。这类引用始终包含了<strong>包名</strong>作为其前缀：<code>foo.Bar</code>引用<code>foo</code>包中的导出名<code>Bar</code></p><p>好的包命名可以让代码更好。包名为其内容提供了上下文（<em>语义</em>），使客户更容易理解包的用途。同时其也能帮助包自身的维护者确定在扩展功能时，哪些内容仍然改属于这个包，哪些内容不该属于这个包。良好的包命名可以帮助你轻松找到所需代码。</p><p>Effective Go提供了包、类型、函数和变量的<a href="https://go.dev/doc/effective_go#names">命名指南</a>。本文则扩展包命名的讨论，并调查在标准库中发现的名称。并且，我们将讨论一些错误的包名和修复他们的方法。</p></div><h2 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h2><div class="story post-story"><p>好的包名是简短清晰的。<strong>小写，无下划线和驼峰</strong>。通常是简单名词，举例来说：</p><ul><li>time (提供了测量和显示时间功能的包)</li><li>list (实现了双向链表的包)</li><li>http (提供HTTP客户端/服务端实现的包)</li></ul><p>以下是两个名称示例，遵循了另一些语言的典型命名风格。这些名称在其他语言中可能很好，但在 Go 中不太适合：</p><ul><li>computeServiceClient</li><li>priority_queue</li></ul><p>一个 Go 包可以导出很多类型和函数。举例来说，<code>compute</code>包可以导出一个<code>Client</code>类型，其中包含使用服务的方法，以及跨越多个客户端划分计算任务的函数。</p><p><strong>审慎地缩写</strong>。当缩写对程序员很熟悉时，包名才可以缩写。常用的包有这些缩写了的名字：</p><ul><li>strconv -&gt; string conversion</li><li>syscall -&gt; system call</li><li>fmt -&gt; formatted I/O</li></ul><p>如果缩写会让包名含糊不清，那不如不要缩写。</p><p><strong>不要从用户手中偷取好名字</strong>。避免给包使用一个客户常用的命名。比如说，缓冲I/O包叫做<code>bufio</code>而不是<code>buf</code>，因为客户经常用<code>buf</code>来命名缓冲区。</p></div><h2 id="命名包内容"><a href="#命名包内容" class="headerlink" title="命名包内容"></a>命名包内容</h2><div class="story post-story"><p>考虑的客户会同时使用包和其内容，这两者的命名应是耦合的。设计包时应该站在客户的角度。</p><p><strong>避免重复</strong>。由于客户代码在引用包内容时使用包名称作为前缀，因此这些内容的名称不需要重复包名称。 <code>http</code> 包提供的 HTTP 服务器称为 <code>Server</code> ，而不是 <code>HTTPServer</code> 。客户端代码将此类型称为 <code>http.Server</code> ，因此没有歧义，不需要再重复一遍。</p><p><strong>简化函数名</strong>。当包<code>pkg</code>中的函数返回一个<code>pkg.Pkg</code>（或<code>*pkg.Pkg</code>）类型的值时，函数名称可以省略类型名称而不会造成混淆，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start := time.Now()                                  <span class="comment">// start is a time.Time</span></span><br><span class="line">t, err := time.Parse(time.Kitchen, <span class="string">&quot;6:06PM&quot;</span>)         <span class="comment">// t is a time.Time</span></span><br><span class="line">ctx = context.WithTimeout(ctx, <span class="number">10</span>*time.Millisecond)  <span class="comment">// ctx is a context.Context</span></span><br><span class="line">ip, ok := userip.FromContext(ctx)                    <span class="comment">// ip is a net.IP</span></span><br></pre></td></tr></table></figure><p>在包中，一个名字为<code>New</code>的函数返回一个<code>pkg.Pkg</code>类型。这是使用该类型的客户代码的标准进入点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q := list.New()<span class="comment">// q is a *list.List</span></span><br></pre></td></tr></table></figure><p>当函数返回 <code>pkg.T</code> 类型的值时，其中 <code>T</code> 不是 <code>Pkg</code> ，函数名称可以包含 <code>T</code> 以生成客户端代码更容易理解。常见的情况是一个包有多个类似 New 的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d, err := time.ParseDuration(<span class="string">&quot;10s&quot;</span>)  <span class="comment">// d is a time.Duration</span></span><br><span class="line">elapsed := time.Since(start)         <span class="comment">// elapsed is a time.Duration</span></span><br><span class="line">ticker := time.NewTicker(d)          <span class="comment">// ticker is a *time.Ticker</span></span><br><span class="line">timer := time.NewTimer(d)            <span class="comment">// timer is a *time.Timer</span></span><br></pre></td></tr></table></figure><p>不同包中的类型可以具有相同的名称，因为从客户端的角度来看，这些名称是通过包名称来区分的。例如，标准库包含多种名为 <code>Reader</code> 的类型，包括 <code>jpeg.Reader</code> 、 <code>bufio.Reader</code> 和 <code>csv.Reader</code> 。每个包名称都适合 <code>Reader</code> 以产生良好的类型名称。</p><p>如果你想不出一个对于包内容来说有意义的包名前缀，那么包的抽象边界可能是有错误的。在编写代码时，考虑客户会如何使用这个包，如果考虑的结果很差就要及时重构。这种方法将产生更容易让客户理解、更容易让开发人员维护的包。</p></div><h2 id="包路径"><a href="#包路径" class="headerlink" title="包路径"></a>包路径</h2><div class="story post-story"><p><strong>Go包同时拥有名字和路径</strong>。名字是在其源代码的package语句中指定的，同时客户代码会用它作为包名导出的前缀。客户端代码导入包时，则使用包的路径。按照<strong>约定</strong>，包路径的最后一个元素就是包名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span>                <span class="comment">// package context</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>                    <span class="comment">// package fmt</span></span><br><span class="line">    <span class="string">&quot;golang.org/x/time/rate&quot;</span> <span class="comment">// package rate</span></span><br><span class="line">    <span class="string">&quot;os/exec&quot;</span>                <span class="comment">// package exec</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>构建工具会将包路径映射到目录上（这一段是关于Go老版本GOPATH的东西，略过）。</p><p><strong>目录</strong>。标准库使用 <code>crypto</code> 、 <code>container</code> 、 <code>encoding</code> 和 <code>image</code> 等目录，对相关协议和算法的包进行分组。在这些目录中的包没有什么实际的关系。<strong>目录只是提供一种排列文件的方法</strong>。在不创建循环依赖的情况下，任何包都可以导入其他包。</p><blockquote><p>此处我可以给出个人测试的案例。假设有这样一个路径和这样一段代码（这个包是go init demo）：</p><p>.<br>├── go.mod<br>├── main.go<br>└── abcdefg<br>   　　└── code.go</p><p>其中，<code>code.go</code>的定义是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你试图在<code>main.go</code>中使用这个包，你需要：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">a <span class="string">&quot;demo/abcdefg&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a.A()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说import使用的是路径，而package声明则代表了客户使用包的名字。<strong>约定中</strong>包名应该和路径最后的名字保持一致。如果没有，<code>go fmt</code>会自动在import语句前给你添上那个包名。</p><p>另外，一个目录里不能有多个不同的package声明。</p><p>另另外，package main是一个特殊的包名，标识程序入口点。如果没有package main，那么<code>go run .</code>无法运行，<code>func main()</code>也不会被识别。</p></blockquote><p>正如不同包中的类型可以具有相同的名称而不会产生歧义一样，不同目录中的包也可以具有相同的名称。例如，runtime/pprof 以 pprof 分析工具期望的格式提供分析数据，而 net/http/pprof 则提供 HTTP 端点来以这种格式呈现分析数据。客户端代码使用包路径来导入包，因此不会出现混乱。如果源文件需要导入两个 <code>pprof</code> 包，它可以在本地重命名一个或两个包。重命名导入的包时，本地名称应遵循与包名称相同的准则（小写，没有下划线或驼峰 ）。</p></div><h2 id="错误的包名"><a href="#错误的包名" class="headerlink" title="错误的包名"></a>错误的包名</h2><div class="story post-story"><p>错误的包名称会使代码更难导航和维护。以下是一些识别和修复不良名称的指南。</p><p>避免无意义的包名称。名为 <code>util</code> 、 <code>common</code> 或 <code>misc</code> 的包让客户端不知道包包含什么内容（<em>天呐，这简直就是我</em>）。这使得客户更难使用该包，也使得维护人员更难保持该包的重点。随着时间的推移，它们会积累依赖关系，从而使编译速度明显变慢，尤其是在大型程序中。由于此类包名称是通用的，因此它们更有可能与客户端代码导入的其他包发生冲突，从而迫使客户端发明名称来区分它们。</p><p>分解通用包。要修复此类包，请查找具有通用名称元素的类型和函数，并将它们拉入自己的包中。例如，如果有</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> util</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStringSet</span><span class="params">(...<span class="keyword">string</span>)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">bool</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SortStringSet</span><span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span> []<span class="title">string</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>那么客户的代码就会看起来像</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set := util.NewStringSet(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">fmt.Println(util.SortStringSet(set))</span><br></pre></td></tr></table></figure><p>我们将这些函数从<code>util</code>提取到一个新的包并想一个合适的名字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stringset</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(...<span class="keyword">string</span>)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">bool</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span> []<span class="title">string</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>这样客户端代码就会变成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set := stringset.New(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">fmt.Println(stringset.Sort(set))</span><br></pre></td></tr></table></figure><p>进行此更改后，可以更轻松地了解如何扩展增强这个新包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stringset</span><br><span class="line"><span class="keyword">type</span> Set <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(...<span class="keyword">string</span>)</span> <span class="title">Set</span></span> &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span> <span class="title">Sort</span><span class="params">()</span> []<span class="title">string</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>这样客户的代码就会更加简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set := stringset.New(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">fmt.Println(set.Sort())</span><br></pre></td></tr></table></figure><p>包的名称是其设计的关键部分。应当努力从项目中消除无意义的包名称。</p><p><strong>不要对你的所有API使用一个单独的包</strong>。许多善意的程序员将他们的程序公开的所有接口放入一个名为 <code>api</code> 、 <code>types</code> 或 <code>interfaces</code> 的包中，认为这样更容易找到入口点指向他们的代码库。这是个错误。此类包与那些名为 <code>util</code> 或 <code>common</code> 的包存在相同的问题，无限制地增长、不向用户提供指导、累积依赖项以及与其他导入发生冲突。将它们分解，也许使用目录将公共包与实现分开。</p><p><strong>避免不必要的包名冲突</strong>。虽然不同目录中的包可能具有相同的名称，但经常一起使用的包应该具有不同的名称。这减少了混乱以及客户端代码中本地重命名的需要。出于同样的原因，请避免使用与 <code>io</code> 或 <code>http</code> 等流行标准包相同的名称。</p></div><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><div class="story post-story"><p>包名称是 Go 程序中良好命名的核心。花时间选择好的包名称并组织好您的代码。这有助于客户理解和使用您的包，并帮助维护人员优雅地扩展它们。</p></div>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Goroutines 的调度与并发控制</title>
      <link href="Programming/controlling-goroutines/"/>
      <url>Programming/controlling-goroutines/</url>
      
        <content type="html"><![CDATA[<h2 id="GMP-模型"><a href="#GMP-模型" class="headerlink" title="GMP 模型"></a>GMP 模型</h2><div class="story post-story"><p>GMP模型的原理不再多讲，处理器（P）通过维护自己的队列拿到需要执行的协程（G）并绑定到线程（M）。常见的GMP知识点不外乎全局队列，M0G0的知识，工作偷取和P遇到自旋M就解绑定并寻找新的M。</p><p>需要注意的一点是G，M与P的数量。G的数量理论上是无限的，但与程序自身的内存有关；P的数量是<code>runtime.GOMAXPROCS</code>控制的，注意这里是运行时宏；而M的数量就是操作系统相关的知识了，也同样受到资源的限制（题外话，进程数量受什么控制？）。</p></div><h2 id="main-等等我的-Goroutine"><a href="#main-等等我的-Goroutine" class="headerlink" title="main, 等等我的 Goroutine"></a>main, 等等我的 Goroutine</h2><div class="story post-story"><p>我们知道 Go 的一切都是 Goroutine 在跑，那么我们的主函数实际上也是跑在一个 Goroutine 里的，只不过这个Goroutine比较特殊，被标记为main Goroutine（废话）。那么我们用户创建这些 Goroutine 何时退出呢？</p><ul><li><p>进程被 Kill / 进程崩溃</p><p>显然这个时候所有的 G 都会退出，毕竟系统资源都没了。</p></li><li><p>main函数结束</p><p>这个时候所有的 G 的资源也会被收回。</p></li><li><p>主动退出</p><p>正常执行完毕 / return / 使用 Context, 这个比较复杂之后特地讲 / panic（不要用）</p></li></ul><p>然而main Goroutine 可不会在乎你创建的 G 是否执行完了。怎么确保我们创建的G能够执行完再让 main G退出呢？</p><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>对于一个比较简单的G，我们直接创建一个无缓冲区管道阻塞一下即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">    ch &lt;- <span class="string">&quot;Done&quot;</span></span><br><span class="line">  &#125;()</span><br><span class="line">  </span><br><span class="line">  data := &lt;-ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这种办法比较低级，如果我需要开启不定数量的 G，这种办法就不好用了（吗？实际上开一个有缓冲区的channel也可以，而且能控制同时运行的 G 的数量）。</p><h3 id="sync-Waitgroup"><a href="#sync-Waitgroup" class="headerlink" title="sync.Waitgroup"></a>sync.Waitgroup</h3><p>这是官方给我们用来控制并发流程的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup <span class="comment">// 声明这个结构, 如果要传到函数里记得指针</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// wg.Add(100) Add其实就是要执行的任务数量，直接在这加也行</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// [注意] wg.Add(1) 不能写在这，写了 linter 也会报错的</span></span><br><span class="line">      <span class="comment">// 因为可能当前还没有 wg.Add(1), wg.Wait() 的逻辑已经通过了 </span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 函数逻辑</span></span><br><span class="line">      wg.Done() <span class="comment">// 做好了</span></span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  wg.Wait()<span class="comment">// 等待结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="Goroutine-更详细的顺序"><a href="#Goroutine-更详细的顺序" class="headerlink" title="Goroutine 更详细的顺序"></a>Goroutine 更详细的顺序</h2><div class="story post-story"><p>运行一下这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        i := i</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    &lt;- ch<span class="comment">// 这里阻塞会 fatal error, 因为死锁了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们控制P的数量是1，并<strong>看似</strong>从0到9创建了一堆G。但实际上，程序的输出是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p>哇，太棒了。为什么会这样？这就必须讲一下 GMP 模型中的三个队列了。</p><h3 id="三个队列"><a href="#三个队列" class="headerlink" title="三个队列"></a>三个队列</h3><p>每个P所拥有的队列大概是这样：<code>runnext</code>，<code>local</code>。以及程序本身有一个<code>global</code>。</p><p>每次创建G的时候，G会首先抢占 <code>runnext</code>。这确保了如果有很多P的话，G会被优先执行，不会有空闲的P，这太浪费资源了。<code>runnext</code>只有一个空位，从名字也能看懂这是P要绑定给M的那个G。但如果有一个新来的G呢？old G就会被new G挤走，到<code>local</code>队列的末尾，下一个调用。这也是为了每个G都能被执行。</p><p><code>local</code>队列最长256，是一个环形队列，头尾指针控制。如果这玩意也满了G就会去<code>global</code>。当然如果空了就会偷取，不再多谈。</p><p>因此这样输出什么情况就很明显了，因为IO操作很慢，因此最后出现的G也就是9抢占了<code>runnext</code>进行执行，而剩下的G则以0～8的方式从<code>local</code>中取出来执行，就有了上面的输出。</p></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 后端 </tag>
            
            <tag> Goroutine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Golang的后端高性能框架 —— Gin</title>
      <link href="Programming/learn-gin/"/>
      <url>Programming/learn-gin/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-Gin"><a href="#使用-Gin" class="headerlink" title="使用 Gin"></a>使用 Gin</h2><div class="story post-story"><p>使用 Gin 框架的基本方法可以展示为下面这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    serveRoute := <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;message&quot;</span>: <span class="string">&quot;hello world&quot;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.GET(<span class="string">&quot;/hi&quot;</span>, serveRoute)</span><br><span class="line"></span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>r</code>是一个使用默认值实例化了的<code>gin.Engine</code>。该引擎用于管理所有HTTP请求，接受路由注册等。<code>serveRoute</code>是一个用于处理路由的函数，其参数必须为一个<code>*gin.Context</code>。接下来向引擎的特定请求和路由路径注册这个处理函数。最终，我们让引擎进行默认监听（局域网地址，8080端口）。这就启动了一个Web服务。</p><p>在内部，引擎对于每一个到来的请求分配一个对应的<code>gin.Context</code>，将这个上下文传入我们的自定义函数。在原理部分再详细展开相关内容。</p></div><h2 id="路由组和动态路由"><a href="#路由组和动态路由" class="headerlink" title="路由组和动态路由"></a>路由组和动态路由</h2><div class="story post-story"><p>（还没写）</p></div><h2 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h2><div class="story post-story"><p>（还没写）</p></div><h2 id="Gin-原理-Engine-部分"><a href="#Gin-原理-Engine-部分" class="headerlink" title="Gin 原理 - Engine 部分"></a>Gin 原理 - Engine 部分</h2><div class="story post-story"><p><code>gin.Default()</code>做了什么？我们参考一下Gin的<a href="https://pkg.go.dev/github.com/gin-gonic/gin#section-sourcefiles">源代码</a>中的<code>gin.go</code>：</p><p><em>（有句吐槽不说不快，感觉这源代码目录结构也太随意了。而且同一个包下的不同文件实际上都是共享上下文的，导致某个文件里声明的类型大概率是另一个文件里的某处冒出来的，如果不用IDE看源代码真是头大）</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default returns an Engine instance with the Logger and Recovery middleware already attached.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Default</span><span class="params">()</span> *<span class="title">Engine</span></span> &#123;</span><br><span class="line">        debugPrintWARNINGDefault()</span><br><span class="line">        engine := New()</span><br><span class="line">        engine.Use(Logger(), Recovery())</span><br><span class="line">        <span class="keyword">return</span> engine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上其使用了<code>New()</code>，并默认使用了两个中间件<code>Logger(), Recovery()</code>。那我们紧接着去看<code>New()</code>的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Engine</span></span> &#123;</span><br><span class="line">        debugPrintWARNINGNew()</span><br><span class="line">        engine := &amp;Engine&#123;</span><br><span class="line">                RouterGroup: RouterGroup&#123;</span><br><span class="line">                        Handlers: <span class="literal">nil</span>,</span><br><span class="line">                        basePath: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">                        root:     <span class="literal">true</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                FuncMap:                template.FuncMap&#123;&#125;,</span><br><span class="line">                RedirectTrailingSlash:  <span class="literal">true</span>,</span><br><span class="line">                RedirectFixedPath:      <span class="literal">false</span>,</span><br><span class="line">                HandleMethodNotAllowed: <span class="literal">false</span>,</span><br><span class="line">                ForwardedByClientIP:    <span class="literal">true</span>,</span><br><span class="line">                AppEngine:              defaultAppEngine,</span><br><span class="line">                UseRawPath:             <span class="literal">false</span>,</span><br><span class="line">                UnescapePathValues:     <span class="literal">true</span>,</span><br><span class="line">                MaxMultipartMemory:     defaultMultipartMemory,</span><br><span class="line">                trees:                  <span class="built_in">make</span>(methodTrees, <span class="number">0</span>, <span class="number">9</span>),</span><br><span class="line">                delims:                 render.Delims&#123;Left: <span class="string">&quot;&#123;&#123;&quot;</span>, Right: <span class="string">&quot;&#125;&#125;&quot;</span>&#125;,</span><br><span class="line">                secureJsonPrefix:       <span class="string">&quot;while(1);&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        engine.RouterGroup.engine = engine</span><br><span class="line">        engine.pool.New = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">                <span class="keyword">return</span> engine.allocateContext()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> engine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先不考虑默认引擎使用的中间件，而研究一下<code>Run()</code>方法是如何实现的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">Run</span><span class="params">(addr ...<span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; debugPrintError(err) &#125;()</span><br><span class="line"></span><br><span class="line">        address := resolveAddress(addr)</span><br><span class="line">        debugPrint(<span class="string">&quot;Listening and serving HTTP on %s\n&quot;</span>, address)</span><br><span class="line">        err = http.ListenAndServe(address, engine)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了 <code>net/http</code> 的 <code>ListenAndServe()</code>。那么引擎必须实现 <code>net/http</code> 的接口 <code>ServeHTTP</code>。我们再回到源码里寻找一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">        c := engine.pool.Get().(*Context)</span><br><span class="line">        c.writermem.reset(w)</span><br><span class="line">        c.Request = req</span><br><span class="line">        c.reset()</span><br><span class="line"></span><br><span class="line">        engine.handleHTTPRequest(c)</span><br><span class="line"></span><br><span class="line">        engine.pool.Put(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个处理流程很明确了，首先从<code>pool</code>中获得一个<code>gin.Context</code>，给这个上下文赋值我们后面再看，放到<code>handleHTTPRequest()</code>里面，处理完毕之后再放回池子回收。那这个方法又具体做了些什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">handleHTTPRequest</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">        httpMethod := c.Request.Method</span><br><span class="line">        path := c.Request.URL.Path</span><br><span class="line">        unescape := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> engine.UseRawPath &amp;&amp; <span class="built_in">len</span>(c.Request.URL.RawPath) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                path = c.Request.URL.RawPath</span><br><span class="line">                unescape = engine.UnescapePathValues</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find root of the tree for the given HTTP method</span></span><br><span class="line">        t := engine.trees</span><br><span class="line">        <span class="keyword">for</span> i, tl := <span class="number">0</span>, <span class="built_in">len</span>(t); i &lt; tl; i++ &#123;</span><br><span class="line">                <span class="keyword">if</span> t[i].method == httpMethod &#123;</span><br><span class="line">                        root := t[i].root</span><br><span class="line">                        <span class="comment">// Find route in tree</span></span><br><span class="line">                        handlers, params, tsr := root.getValue(path, c.Params, unescape)</span><br><span class="line">                        <span class="keyword">if</span> handlers != <span class="literal">nil</span> &#123;</span><br><span class="line">                                c.handlers = handlers</span><br><span class="line">                                c.Params = params</span><br><span class="line">                                c.Next()</span><br><span class="line">                                c.writermem.WriteHeaderNow()</span><br><span class="line">                                <span class="keyword">return</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> httpMethod != <span class="string">&quot;CONNECT&quot;</span> &amp;&amp; path != <span class="string">&quot;/&quot;</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> tsr &amp;&amp; engine.RedirectTrailingSlash &#123;</span><br><span class="line">                                        redirectTrailingSlash(c)</span><br><span class="line">                                        <span class="keyword">return</span></span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> engine.RedirectFixedPath &amp;&amp; redirectFixedPath(c, root, engine.RedirectFixedPath) &#123;</span><br><span class="line">                                        <span class="keyword">return</span></span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> engine.HandleMethodNotAllowed &#123;</span><br><span class="line">                <span class="keyword">for</span> _, tree := <span class="keyword">range</span> engine.trees &#123;</span><br><span class="line">                        <span class="keyword">if</span> tree.method != httpMethod &#123;</span><br><span class="line">                                <span class="keyword">if</span> handlers, _, _ := tree.root.getValue(path, <span class="literal">nil</span>, unescape); handlers != <span class="literal">nil</span> &#123;</span><br><span class="line">                                        c.handlers = engine.allNoMethod</span><br><span class="line">                                        serveError(c, <span class="number">405</span>, default405Body)</span><br><span class="line">                                        <span class="keyword">return</span></span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c.handlers = engine.allNoRoute</span><br><span class="line">        serveError(c, <span class="number">404</span>, default404Body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用语法树进行匹配。核心逻辑是如果成功，那么去<code>c.Next()</code>。我们接下来有必要看看上下文的源代码了。</p><p>但在这之前，引擎结构体的成员还有些值得注意的点，我们浅浅分开看一看。</p><h3 id="RouterGroup"><a href="#RouterGroup" class="headerlink" title="RouterGroup"></a>RouterGroup</h3><p>显然这个是用来处理路由的，可以看到RouterGroup结构中存在着Handlers，这些应该就是中间件和处理方法存放的地方。看看<code>routergroup.go</code>中的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RouterGroup is used internally to configure router, a RouterGroup is associated with</span></span><br><span class="line"><span class="comment">// a prefix and an array of handlers (middleware).</span></span><br><span class="line"><span class="keyword">type</span> RouterGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">Handlers HandlersChain</span><br><span class="line">basePath <span class="keyword">string</span></span><br><span class="line">engine   *Engine</span><br><span class="line">root     <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的注释已经讲很清楚了，<code>HandlersChain</code>就是一个放着中间件的数组。<code>basePath</code>则是代表这个路由组的基础地址。在注册路由时，我们会传入新的相对地址。路由的实际地址是根据这两个地址的结合算出来的。</p><p>为什么要持有对引擎的引用？<code>Use()</code>,<code>GET()</code>等方法都调用了<code>handle()</code>这个没有暴露的方法，我们看一下这个方法的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">handle</span><span class="params">(httpMethod, relativePath <span class="keyword">string</span>, handlers HandlersChain)</span> <span class="title">IRoutes</span></span> &#123;</span><br><span class="line">absolutePath := group.calculateAbsolutePath(relativePath)</span><br><span class="line">handlers = group.combineHandlers(handlers)</span><br><span class="line">group.engine.addRoute(httpMethod, absolutePath, handlers)</span><br><span class="line"><span class="keyword">return</span> group.returnObj()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说我们在当前路由组中注册了中间件，并引擎中注册了路径。非常合理。请注意注册路径的时候传递的参数，也就是http方法 / 绝对路径 / HandlersChain的值类型。那么我们可以猜到<strong>语法树存放的K-V逻辑是路径-方法列表</strong>。</p><p>关于返回值类型<code>IRoutes</code>我觉得也有必要看一看。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRouter defines all router handle interface includes single and group router.</span></span><br><span class="line"><span class="keyword">type</span> IRouter <span class="keyword">interface</span> &#123;</span><br><span class="line">IRoutes</span><br><span class="line">Group(<span class="keyword">string</span>, ...HandlerFunc) *RouterGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IRoutes defines all router handle interface.</span></span><br><span class="line"><span class="keyword">type</span> IRoutes <span class="keyword">interface</span> &#123;</span><br><span class="line">Use(...HandlerFunc) IRoutes</span><br><span class="line"></span><br><span class="line">Handle(<span class="keyword">string</span>, <span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">Any(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">GET(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">POST(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">DELETE(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">PATCH(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">PUT(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">OPTIONS(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">HEAD(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">Match([]<span class="keyword">string</span>, <span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line"></span><br><span class="line">StaticFile(<span class="keyword">string</span>, <span class="keyword">string</span>) IRoutes</span><br><span class="line">StaticFileFS(<span class="keyword">string</span>, <span class="keyword">string</span>, http.FileSystem) IRoutes</span><br><span class="line">Static(<span class="keyword">string</span>, <span class="keyword">string</span>) IRoutes</span><br><span class="line">StaticFS(<span class="keyword">string</span>, http.FileSystem) IRoutes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没什么特别的，就是路由类型的接口。</p><h3 id="trees"><a href="#trees" class="headerlink" title="trees"></a>trees</h3><p>字典树，路由的处理就放在这里了。它的类型是<code>methodTrees</code>。我们转去<code>tree.go</code>看他的实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> methodTree <span class="keyword">struct</span> &#123;</span><br><span class="line">method <span class="keyword">string</span></span><br><span class="line">root   *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> methodTrees []methodTree</span><br></pre></td></tr></table></figure><p>结合之前引擎匹配路径的原理不难猜出，引擎实际上为<strong>每种不同的HTTP请求方式维护了一个Trie树</strong>。接下来就是这个数据结构的具体实现了。</p><p><em>(有空再写)</em></p><h3 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h3><p>此处使用了 Go 包 <code>sync/pool</code>实现了上下文池。这是一个为了减少GC而设计的对象池，其是可伸缩、线程安全的。它的目的是存放分配但暂时不用的对象，在需要的时候直接拿出来。我们现在只需要知道这些，具体的原理感觉之后需要详细了解一下<code>sync</code>包。</p></div><h2 id="Gin-原理-Context-部分"><a href="#Gin-原理-Context-部分" class="headerlink" title="Gin 原理 - Context 部分"></a>Gin 原理 - Context 部分</h2><div class="story post-story"><p>Context是Gin中的重要的一部分，它承担了在中间件间传递信息，控制流，验证JSON和快速返回请求的一些功能。<strong>这种设计方法也就是责任链模式的体现</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">writermem responseWriter</span><br><span class="line">Request   *http.Request</span><br><span class="line">Writer    ResponseWriter</span><br><span class="line"></span><br><span class="line">Params   Params</span><br><span class="line">handlers HandlersChain</span><br><span class="line">index    <span class="keyword">int8</span></span><br><span class="line">fullPath <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">engine       *Engine</span><br><span class="line">params       *Params</span><br><span class="line">skippedNodes *[]skippedNode</span><br><span class="line"></span><br><span class="line"><span class="comment">// This mutex protects Keys map.</span></span><br><span class="line">mu sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keys is a key/value pair exclusively for the context of each request.</span></span><br><span class="line">Keys <span class="keyword">map</span>[<span class="keyword">string</span>]any</span><br><span class="line"></span><br><span class="line"><span class="comment">// Errors is a list of errors attached to all the handlers/middlewares who used this context.</span></span><br><span class="line">Errors errorMsgs</span><br><span class="line"></span><br><span class="line"><span class="comment">// Accepted defines a list of manually accepted formats for content negotiation.</span></span><br><span class="line">Accepted []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// queryCache caches the query result from c.Request.URL.Query().</span></span><br><span class="line">queryCache url.Values</span><br><span class="line"></span><br><span class="line"><span class="comment">// formCache caches c.Request.PostForm, which contains the parsed form data from POST, PATCH,</span></span><br><span class="line"><span class="comment">// or PUT body parameters.</span></span><br><span class="line">formCache url.Values</span><br><span class="line"></span><br><span class="line"><span class="comment">// SameSite allows a server to define a cookie attribute making it impossible for</span></span><br><span class="line"><span class="comment">// the browser to send this cookie along with cross-site requests.</span></span><br><span class="line">sameSite http.SameSite</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的index和handlers就是<code>Next()</code>方法执行的关键。这个方法的实现很简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Next</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.index++</span><br><span class="line"><span class="keyword">for</span> c.index &lt; <span class="keyword">int8</span>(<span class="built_in">len</span>(c.handlers)) &#123;</span><br><span class="line">c.handlers[c.index](c)</span><br><span class="line">c.index++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让index在所有方法上不停的移动，并将自身传入对应的方法中进行执行。我们方法中常用的一些Context提供的功能可以浅浅看一看。</p><h3 id="Set-和-Get"><a href="#Set-和-Get" class="headerlink" title="Set 和 Get"></a>Set 和 Get</h3><p>使用到了Context的RWMutex和Keys这两个参数。很简单地对map进行上锁，读取再解锁。可以预料到如果用这个的话应该会影响性能。但Golang的map实现要求必须上锁，否则必定fatal error。</p><h3 id="BindXX-和-ShouldBindXX"><a href="#BindXX-和-ShouldBindXX" class="headerlink" title="BindXX 和 ShouldBindXX"></a>BindXX 和 ShouldBindXX</h3><p>（Gin终于舍得给binding单独写个Package了，但是代码好多，有空再看）</p><h3 id="Abort"><a href="#Abort" class="headerlink" title="Abort"></a>Abort</h3><p>Abort的操作把index设置为abortIndex。这个行为一般在某个Handler末尾前执行，并让Context不执行接下来的handlers。也就是说你可以在某个中间件截断这次请求。那么abortIndex是啥呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abortIndex represents a typical value used in abort functions.</span></span><br><span class="line"><span class="keyword">const</span> abortIndex <span class="keyword">int8</span> = math.MaxInt8 &gt;&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure><p>再浅说一下怎么简单记忆位移运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n &lt;&lt; m (n times 2 for m times)</span><br><span class="line">y &gt;&gt; x (y divided by 2 for x times)</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 后端 </tag>
            
            <tag> Gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅浅区分一下分类网和网络地址转换</title>
      <link href="Note/subnets-and-nat/"/>
      <url>Note/subnets-and-nat/</url>
      
        <content type="html"><![CDATA[<p>在最初学习计算机网络的时候，我首先学习了IPv4编址方式，紧接着学习了子网，CIDR，路由聚合，IP地址获取与NAT。但在思考和与朋友讨论的过程中，我发现我混淆了一些概念。因此我做了一些调查，在这篇笔记中按顺序梳理这几个概念，这个顺序也是互联网IP协议发展所采取的顺序。</p><h2 id="路由器和网关"><a href="#路由器和网关" class="headerlink" title="路由器和网关"></a>路由器和网关</h2><div class="story post-story"><p>首先我们明确，这些设备全部都是用来调控网络流量的。那么，简单一点来说：</p><p><strong>路由器在相同的网络中转发数据</strong>。路由器本身将会存储一个查找表。对于接受的数据包，路由器检查数据包内的数据是发给谁的，根据自己的查找表传递给下一台路由器/主机。网络中的数据包就是这样，经过多次跳跃，从一个主机到达另一个主机的。</p><p><strong>网关在不同的网络中传递数据</strong>。如果两个网络使用了不同的网络协议，那么我们就需要网关为我们做协议转换。最常见的就是我们接下来要讲的NAT。</p><p>路由器和网关是可以重叠的。一个设备，可以既做数据包在同协议网络间的转发，又为网络间通信转换网络协议，此时他就是一个路由器和一个网关。</p><p>除此之外，还有一些互联网设备的概念，诸如交换机，接入点（AP），调制解调器（MODEM）等，因为对于理解本篇文章不重要，就不展开讲了。</p></div><h2 id="子网与子网掩码"><a href="#子网与子网掩码" class="headerlink" title="子网与子网掩码"></a>子网与子网掩码</h2><div class="story post-story"><p>教科书上说，网络被分配到的一个IP地址由网络地址和子网掩码组成。IP地址由四段八比特二进制数组成，也可以写成点分的十进位形式。而子网掩码，其高比特位标志了该子网的地址，而低比特位标志了主机在子网中的地址。IP地址后用一个斜杠加一个数字，表示其前多少位是网络地址。我们举个例子。</p><figure class="highlight c"><figcaption><span>IP地址</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">十进制网络地址  <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span>/<span class="number">24</span></span><br><span class="line">二进制网络地址  <span class="number">11000000</span> <span class="number">10101000</span> <span class="number">00000001</span> <span class="number">01100100</span></span><br><span class="line"></span><br><span class="line">十进制子网掩码  <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">二进制子网掩码  <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure><p>IPv4协议是在1982年提出的，最开始的32位IPv4只用前8位确定网络地址，即主机连接到哪个网络，以及剩下的部分作为主机地址。这样的分类方式不能允许太多的独立网络。</p><p><strong>为什么需要区分一个网络地址和一个主机地址？</strong>我的理解是，这实际上是为了控制网络的边界，方便管理与路由器寻址。假设不区分子网，那么路由器需要维护的查找表将会非常庞大，需要将IP地址的每一位都记录下来，并且计算保存最近距离的路由器。如果区分了子网，那么路由器只需要存储<strong>以哪些字段开头</strong>的数据发给某个路由器即可。</p><p>而伴随其提出的是如何为子网划分地址的模式。最开始，人们选择了比较简单的分级式寻址。网络被分为ABCDE五个类，不同的类使用他们的前三位来识别：</p><ul><li>A类地址，第一位是0，使用前8位作为网络位，剩下的作为主机位，A类地址可以构建出 128 个网络，每个网络容纳 16,777,214 个主机。</li><li>B类地址，前两位是10，使用前16位作为网络位，剩下的作为主机位，B类地址可以构建出 16,384 个网络，每个网络容纳 65,534 个主机。</li><li>C类地址，前三位是110，使用前24位作为网络位，剩下的作为主机位，B类地址可以构建出 2,097,152 个网络，每个网络容纳 254 个主机。</li><li>D类群播地址，前四位是1110；和E类保留地址，前四位是1111。</li></ul><p>实际上，这种分类模式就没有必要说明子网掩码，因为你总是可以从前n位推断出其子网掩码应该是多少。这种分类模式<strong>现在已经被废止</strong>，因为其立刻展现出了问题：对于一个小型网，C类地址的主机容量太小，B类地址又太大。</p></div><h2 id="无类别区域间路由（CIDR）和路由聚合"><a href="#无类别区域间路由（CIDR）和路由聚合" class="headerlink" title="无类别区域间路由（CIDR）和路由聚合"></a>无类别区域间路由（CIDR）和路由聚合</h2><div class="story post-story"><p>为了解决刚刚提到的问题，我们使用CIDR。原理很简单，我们将IP地址重新设定为 <code>a.b.c.d/x</code>，x代表了IP地址的网络号，可以为任意值。这样我们就可以在灵活分配子网大小的同时，简化我们路由保存的转发表。</p><p>在实践中，我们就得到了路由聚合的概念。我们的路由器只需要保存开头x位的某个IP地址应当转发给哪个子网，而不需要关心子网内数据包是如何传递的。可能在子网内存在其他子网，但是发包的路由器并不关心。这种情况我们就称作路由聚合。</p><p><em>顺便一提，某些IP地址是协议规定的保留地址。比如127.0.0.1 (01111111 00000000 00000000 00000001) 是环回地址，也就是当前所在的主机，也叫做 <code>localhost</code>，实际上环回地址有 1,600,000 以上个，从127.0.0.1到127.255.255.255均为环回地址。</em></p><p><em>255.255.255.255是广播地址，向广播地址交付报文会让该报文被发送到该子网内的每个主机。当然，这是路由器的转发表保存的数据决定的，路由器在收到目的地是255.255.255.255地址的数据包之后，它会向它子网内的所有主机发该数据包。</em></p></div><h2 id="IP地址获取"><a href="#IP地址获取" class="headerlink" title="IP地址获取"></a>IP地址获取</h2><div class="story post-story"><p>我们已经做好了如何给IP地址分类，接下来简单讲一下IP地址是如何获取的。最简单的是由你的互联网服务提供商（ISP）提供，ISP自己有一个地址段，而后他可以将地址段划分为子网并交付给用户。如下例子（尖括号的部分是主机号，而中括号的部分是<strong>子组织相较于ISP地址增加的网络号</strong>）：</p><figure class="highlight c"><figcaption><span>ISP分配</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ISP得到的地址 <span class="number">200.23</span><span class="number">.16</span><span class="number">.0</span>/<span class="number">20</span> <span class="number">11001000</span> <span class="number">00010111</span> <span class="number">0001</span>&lt;<span class="number">0000</span> <span class="number">00000000</span>&gt;</span><br><span class="line"></span><br><span class="line">组织A <span class="number">200.23</span><span class="number">.16</span><span class="number">.0</span>/<span class="number">23</span> <span class="number">11001000</span> <span class="number">00010111</span> <span class="number">0001</span>[<span class="number">000</span>]&lt;<span class="number">0</span> <span class="number">00000000</span>&gt;</span><br><span class="line">组织B <span class="number">200.23</span><span class="number">.18</span><span class="number">.0</span>/<span class="number">23</span> <span class="number">11001000</span> <span class="number">00010111</span> <span class="number">0001</span>[<span class="number">001</span>]&lt;<span class="number">0</span> <span class="number">00000000</span>&gt;</span><br><span class="line">...</span><br><span class="line">组织G <span class="number">200.23</span><span class="number">.30</span><span class="number">.0</span>/<span class="number">23</span> <span class="number">11001000</span> <span class="number">00010111</span> <span class="number">0001</span>[<span class="number">111</span>]&lt;<span class="number">0</span> <span class="number">00000000</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么ISP的地址从哪儿来？答案是因特网名字和编号分配机构（ICANN）。ICANN是非营利组织，其不仅分配IP地址，也管理DNS根服务器，分配域名。</p><p>当然，还有一种方法，通常用于比较小的子网，就是动态主机配置协议（DHCP）。主机每次连接到配置了DHCP的网络，都会获得一个临时的IP地址。除此之外，主机还可以得到当前子网的子网掩码，第一跳路由地址（我们现在一般叫做<strong>默认网关</strong>），本地DNS服务器地址。现在打开你的手机，进入网络设置并查看连接的无线局域网信息，你就可以看到这些内容。连接学校的局域网，学校也会提前告知你要使用DHCP。</p></div><h2 id="网络地址转换（NAT）"><a href="#网络地址转换（NAT）" class="headerlink" title="网络地址转换（NAT）"></a>网络地址转换（NAT）</h2><div class="story post-story"><p>需要意识到的是，以上我们所有的工作都不过是在给我们的 4,294,967,296 个IP地址做分类，这也是我错误思想的来源。</p><p><strong>子网并不代表整个网络中的某两台主机可以分配相同的IP地址</strong>。想象一个身份证号或者手机号，其内容是不能重复的，对其不同段做分类只是为了方便罢了。即使是划分了子网，不同子网间的IP地址也必须是不同的。这实际上很好理解，如果他们相同，那路由算法将会被破坏。路由器不知道应该向谁发包，或者总有一个主机收不到包，因为路由表在较短的网络号处截断并转发（想象路由器发送所有212.144.*.*到路由器A，路由器A是212.144.1.1/12，而路由器B是212.144.1.1/16）。</p><p>为了解决IP枯竭问题，人们从1993年开始使用了NAT技术，并通过RFC 1918协议定义了一部分IP地址使其专门用于NAT网络内部地址分配。这样的网络叫做<strong>专用网</strong>或者<strong>私有网</strong>。以下是RFC 1918规定的IP块：</p><figure class="highlight c"><figcaption><span>RFC 1918</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">规定区块名   IP地址区块                   IP数量</span><br><span class="line"><span class="number">24</span>位区块    <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span> – <span class="number">10.255</span><span class="number">.255</span><span class="number">.255</span>       <span class="number">16</span>,<span class="number">777</span>,<span class="number">216</span></span><br><span class="line"><span class="number">20</span>位区块    <span class="number">172.16</span><span class="number">.0</span><span class="number">.0</span> – <span class="number">172.31</span><span class="number">.255</span><span class="number">.255</span>     <span class="number">1</span>,<span class="number">048</span>,<span class="number">576</span></span><br><span class="line"><span class="number">16</span>位区块    <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span> – <span class="number">192.168</span><span class="number">.255</span><span class="number">.255</span>   <span class="number">65</span>,<span class="number">536</span></span><br></pre></td></tr></table></figure><p>专用网通过<strong>网关</strong>来完成地址转换。我们现在自己使用的，提供无线局域网连接服务的路由器都做了NAT地址转换，因此提供WiFi的路由器也就是该私有网的网关。拿我自己的路由器为例，在私有网，其IP地址是192.168.1.1，访问该地址也会进入路由器的管理界面。我的所有设备的网关都是192.168.1.1，每个设备通过DHCP获得自己在私有网络的地址，将数据包交给网关做转发。而查看路由器自己的设置，可以看到路由器在外部网络的地址是172.26.55.113，也是通过DHCP获得IP地址。根据RFC 1918，这个地址仍然是一个私有地址。实际上，这是大学校园私有网络的地址。并且，路由器的网关是172.26.0.1，这就是大学校园私有网络的流量出口。在此处，校园网私网地址被翻译成更高一级的公网地址进行通信。</p><p>私有网络必须要有不同于公网的IP，因为如果出现了公网IP，那么当一个主机要发给此IP时，网关的路由就不确定这个数据包到底是要给私网内的主机，还是转发出去。</p><p>那么，通信是如何完成的？以网络地址端口转换（NAPT）为例，假设现在的网络是我的路由器创建的私有网，从我的手机(192.168.1.101)发送的数据，到达网关(192.168.1.1)后，网关会将其转为(172.26.55.113:Port)，再发往下一级路由。这样一层一层包裹，数据包能够最终到达公网。同样的，接收的数据会被网关根据端口号一层一层地解开，到学校局域网的一层时，学校网关(172.26.0.1)将会收到一个发往172.26.55.113:Port的包，那么学校网关将会把包路由到172.26.55.113，我的路由器则会根据Port将数据包路由回我的手机。</p><p>当然，如果私网内的某个IP用了两个端口，那么网关也会为其映射两个到外部的端口，以便进行通信。</p><p>NAT的好处在于，私网内的用户非常安全。如果不主动发送信息，那么公网将无法与其进行通信。而坏处是，NAT下的主机实际上没有真正的IP地址，不能参与某些网络协议，比如某些必须从外部建立的UDP协议。举例来说，任天堂说我的NAT类型是D不让我玩联机游戏。</p></div><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><div class="story post-story"><p>子网和私网不是一个概念。不过，路由器创建的网络仍然可以被称作一个子网，只不过这个子网并不属于一个大的互联网。如果要谈论<strong>获取公网IP</strong>，实际上我们谈论的是一个跳出NAT的过程。比较常用的是端口映射，也就是说我将私网内的IP<strong>固定</strong>映射到网关的公网地址的某个端口上去，这样其他用户就可以通过访问<code>网关公网IP:Port</code>来进行通信。当然，这样的方法似乎只能跳出一层NAT。</p></div>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造玩具版 Java 虚拟机 - 软件工程课程作业 Lab1</title>
      <link href="Programming/vjvm-lab1/"/>
      <url>Programming/vjvm-lab1/</url>
      
        <content type="html"><![CDATA[<p>Java 代码以类为基础。在编译时，每个类都会生成一个<code>.class</code>文件，其中用16进制字节码保存了JVM运行程序需要的各种信息。虚拟机读取信息，就可以执行程序。根据这个原理，我们可以用 Java 写一个 Java 虚拟机，这真是太有趣了（棒读）。</p><p>本程序使用 OpenJDK 1.8，使用 Gradle 构建并使用了 lombok 插件。如果使用IDEA，请在手动在项目设置里修改为 OpenJDK 1.8；提到的 lombok 插件非常便利，在自己编写程序时也有多次用到，比如最简单的应用是可以在抛出异常的地方写一个 <code>@SneakyThrow</code>，这样程序员就不用麻烦的为一个自己无法处理的异常写一个 <code>try-catch</code> 包裹了。</p><h2 id="Java-字节码"><a href="#Java-字节码" class="headerlink" title="Java 字节码"></a>Java 字节码</h2><div class="story post-story"><p>在一切开始之前，我们需要先了解 Java 字节码的结构。你可以用任何16进制编辑器查看<code>.class</code>文件，或者你可以使用<code>javap $&#123;target&#125; -verbose</code>来用人类可以读懂的方式查看其内容。下图展示了<code>.class</code>文件顺序排列的结构。一个固定长度的小块块代表了一个 Byte。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://s2.loli.net/2022/05/10/gnfljGtIoRTBwQN.png" class="lazyload" data-srcset="https://s2.loli.net/2022/05/10/gnfljGtIoRTBwQN.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="字节码结构示意图"></div><span class="image-caption">字节码结构示意图</span></div><h3 id="魔数和版本号"><a href="#魔数和版本号" class="headerlink" title="魔数和版本号"></a>魔数和版本号</h3><p>最开始的魔数 <code>0xCAFEBABE</code>，或者 3405691582 (int)，标志着这是一个 Java 虚拟机可运行的字节码文件，真是独特（Cafe Babe = 看板娘？）。接下来两个 short 存储了编译的副、主版本号。JVM在执行的时候也会检查自己能否运行该版本号的字节码。</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>首先，常量池计数器占用一个 short。它记录了 <code>cp_info</code> 即常量池项的个数，注意到常量池计数器是从1开始的，所以常量池项将会有<code>constant_pool_count - 1</code>个，因为偶尔会需要有一个引用“不指向任何常量”，即索引0。又注意到计数器因为是16比特存储，因此常量个数不能超过65534个（如果你在一个类里面写了这么多常量，那你应该思考一下设计模式）。</p><p>随其后的是不定长度的常量池数据区。如果它不定长度，那么我们如何读取呢？请打开我们的<a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf">手册</a>并翻到4.4节常量池（在78页）。我们可以看到，每个 <code>cp_info</code> 的结构是：</p><figure class="highlight c"><figcaption><span>cp_info</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u1 info[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据一个字节的类型标记，我们可以<code>info[]</code>到底是什么。比如，一个<code>CONSTANT_Utf8_info</code>结构，即字面常量结构在4.4.7被介绍，其结构如下：</p><figure class="highlight c"><figcaption><span>CONSTANT_Utf8_info</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 length;</span><br><span class="line">    u1 bytes[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这个原理，我们每次首先判断其是什么类型，再按照类型读取数据。建议随便写一个程序，然后利用<code>javap</code>观察一下，看看它存放了什么字面数据，别的数据又是如何被存放的。</p><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>访问标志就是你在程序里写的public, private, final, abstract等等。其具有两个字节，并且其是一个掩码结构。我们暂且不需要知道所有的访问标志都是什么，只需要知道计算这块区域的方式是将所有的访问标志求和即可，举例来说，假如有一个公开接口，其具有的访问标志有<code>PUBLIC</code>的值是<code>0x0001</code>，<code>INTERFACE</code>的值是<code>0x0200</code>，那么访问标志就是<code>0x0201</code>。</p><h3 id="类索引与父类索引"><a href="#类索引与父类索引" class="headerlink" title="类索引与父类索引"></a>类索引与父类索引</h3><p>这里的类索引和父类索引都分别占有两个字节，存储一个指向常量池中<code>CONSTANT_Class_info</code>的索引。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>首先具有接口数量信息，接着有该数量个接口数据信息。注意接口数据信息只是一个两字节的，指向常量池中<code>CONSTANT_Class_info</code>的索引。</p><h3 id="字段与方法"><a href="#字段与方法" class="headerlink" title="字段与方法"></a>字段与方法</h3><p>字段和方法相当类似，其开头都会有一个计数器，而后跟随一串数据，这些数据拥有这样的结构：</p><figure class="highlight c"><figcaption><span>field_info</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">    u2 access_flags;</span><br><span class="line">    u2 name_index;</span><br><span class="line">    u2 descriptor_index;</span><br><span class="line">    u2 attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>method_info</code>也是一模一样的。我们可以看到一个字段或方法拥有访问标志，具有其名字和描述符索引，属性计数器和属性等。</p><p>我们必须注意到的是，这个结构中也具有“属性”这个结构，即<code>attribute_info</code>的数组。也就是说字段、方法和类文件都具有属性。实际上，方法是如何被执行的，即JVM的字节操作码就记录在<code>method_info</code>里的<code>attribute_info</code>的数组内，并且其具体的<code>attribute_info</code>类型是<code>Code</code>。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>我们暂时不需要关心属性(attribute)的部分，但是我还是把其结构表示出来：</p><figure class="highlight c"><figcaption><span>attribute_info</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u1 info[attribute_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在写代码的时候会用到，并且之后实现真正运行程序的时候也是必要的。除了上面提到的<code>Code</code>属性以外，还存在常量<code>ConstantValue</code>，异常<code>Exception</code>等等。</p></div><h2 id="程序框架"><a href="#程序框架" class="headerlink" title="程序框架"></a>程序框架</h2><div class="story post-story"><p>在 VJVM 项目的<code>src</code>目录中存放了所有的程序源代码，我们可以先观察一下其结构。不需要关心的部分被我去掉了。</p><figure class="highlight plain"><figcaption><span>Source File Tree</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── main</span><br><span class="line">│   └── java</span><br><span class="line">│       └── vjvm</span><br><span class="line">│           ├── classfiledefs</span><br><span class="line">│           │   ├── ...</span><br><span class="line">│           ├── classloader</span><br><span class="line">│           │   ├── JClassLoader.java</span><br><span class="line">│           │   └── searchpath</span><br><span class="line">│           │       ├── ClassSearchPath.java</span><br><span class="line">│           │       └── ModuleSearchPath.java</span><br><span class="line">│           ├── runtime</span><br><span class="line">│           │   ├── JClass.java</span><br><span class="line">│           │   └── classdata</span><br><span class="line">│           │       ├── ConstantPool.java</span><br><span class="line">│           │       ├── FieldInfo.java</span><br><span class="line">│           │       ├── MethodInfo.java</span><br><span class="line">│           │       ├── attribute</span><br><span class="line">│           │       │   ├── ...</span><br><span class="line">│           │       └── constant</span><br><span class="line">│           │           ├── ClassConstant.java</span><br><span class="line">│           │           ├── ...</span><br><span class="line">│           │           └── UnknownConstant.java</span><br><span class="line">│           ├── utils</span><br><span class="line">│           │   └── UnimplementedError.java</span><br><span class="line">│           └── vm</span><br><span class="line">│               ├── Main.java</span><br><span class="line">│               └── VMContext.java</span><br><span class="line">└── test</span><br><span class="line">    └── ...</span><br></pre></td></tr></table></figure><p>我们首先从目录<code>main/java/vjvm/vm</code>看起。这里有程序的入口，我们可以暂不关心。构造 VJVM 的程序员使用了 lombok 来简化程序的使用，我们可以理解为编译好程序运行后为其提供一些参数，由程序入口来处理。接下来 VMContext 就是接收查找目录并生成类加载器实例。</p><p>所以，我们来看<code>main/java/vjvm/classloader</code>，即类加载器。我们可以看到该目录下还有一个<code>searchpath</code>，我们合理的推测其是类加载器的成员。因为我们可能到运行时才知道我们需要从何处，比如文件内或是jar包内，或者是其他情况。因此需要动态绑定，面向接口编程。</p><p>JClassLoader 在对应路径加载到编译好的类文件后，其用得到的文件，根据代码实际内容来看是 <code>DataInputStream</code> 类型，即二进制数据流，和其本身创建一个 JClass。这带领我们来到<code>main/java/vjvm/classdata</code>目录。在这里我们需要实现读取一个类的内容。根据之前字节码的介绍，比较棘手的是常量池，字段方法属性信息等等。</p><p>其他有省略号的文件均不是本次 Lab 需要考虑的内容。</p></div><h2 id="构造查找类文件的代码"><a href="#构造查找类文件的代码" class="headerlink" title="构造查找类文件的代码"></a>构造查找类文件的代码</h2><div class="story post-story"><p>如果我们想要读取<code>.class</code>文件内容，首先该找到<code>.class</code>文件在哪里。</p><h3 id="类加载类"><a href="#类加载类" class="headerlink" title="类加载类"></a>类加载类</h3><p>我们首先来阅读一下框架给出的<code>JClassLoader</code>。</p><figure class="highlight java"><figcaption><span>JClassLoader.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JClassLoader</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> JClassLoader parent;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassSearchPath[] searchPaths;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, JClass&gt; definedClass = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">// Stores its creator</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> VMContext context;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// constructor</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JClass <span class="title">loadClass</span><span class="params">(String descriptor)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 以下的代码在这里</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@SneakyThrows</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先看属性，它具有一个同类型的parent，一个搜索路径列表和一个描述符对应JClass的的哈希表。</p><p>我们要知道Java加载类通过使用Parent-First优先策略，一个Loader得到一个路径，首先会交给父Loader查找，如果找不到再自己进行查找。而查找的路径就是ClassSearchPath。接下来完成loadClass()方法。</p><p>我们首先对类名字和路径做一下处理。Java类描述符大概长这样：<code>Ljava/lang/Object;</code>。如果换为路径，就是<code>java/lang/Object</code>，再用点更换斜杠，就得到了类名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String dir = descriptor.substring(<span class="number">1</span>, descriptor.length() - <span class="number">1</span>);</span><br><span class="line">String name = descriptor.substring(<span class="number">1</span>, descriptor.length() - <span class="number">1</span>).replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;.&quot;</span>);</span><br></pre></td></tr></table></figure><p>接下来看一下是否已经加载过，并丢给双亲加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.definedClass.containsKey(name)) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.definedClass.get(name);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">   parentFoundClass = <span class="keyword">this</span>.parent.loadClass(descriptor);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果双亲找到了，就返回双亲的。否则，自己去找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (parentFoundClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span>(ClassSearchPath p : <span class="keyword">this</span>.searchPaths) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p.findClass(dir) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      JClass tmp = <span class="keyword">new</span> JClass(<span class="keyword">new</span> DataInputStream(p.findClass(dir)), <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">this</span>.definedClass.put(name, tmp);</span><br><span class="line">      <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> parentFoundClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段代码其实涉及到一个<strong>风格问题</strong>。几天前看过的一个视频中提到，应该尽量少在代码中使用Else，这样可以减少嵌套。因此，我们这样修改一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (parentFoundClass != <span class="keyword">null</span>) &#123; <span class="keyword">return</span> parentFoundClass; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(ClassSearchPath p : <span class="keyword">this</span>.searchPaths) &#123;</span><br><span class="line">    <span class="comment">// 这里的findClass方法将在后面提到</span></span><br><span class="line">    <span class="keyword">if</span>(p.findClass(dir) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        JClass tmp = <span class="keyword">new</span> JClass(<span class="keyword">new</span> DataInputStream(p.findClass(dir)), <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.definedClass.put(name, tmp);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>通过把最开始的判等换为判不等，我们得到了一个<strong>守卫语句</strong>（Guard Clause）。这是在代码中减少使用嵌套的好办法。</p><h3 id="类加载路径类"><a href="#类加载路径类" class="headerlink" title="类加载路径类"></a>类加载路径类</h3><p>我们这样并没有完成构造，因为我们没有完成ClassSearchPath。在这里使用多态的原因是，我们的类可能来自于一个路径，也可能来自一个Jar包；在未来，可能有更多不同的路径。</p><p>我们在ClassSearchPath中有一个静态方法。通过调用这个静态方法，我们可以在不实例化任何类的时候，根据参数构建多个SearchPath。这是一个<strong>工厂模式</strong>的设计实例。</p><figure class="highlight java"><figcaption><span>ClassSearchPath内部方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ClassSearchPath[] constructSearchPath(String path) &#123;</span><br><span class="line"></span><br><span class="line">  String sep = System.getProperty(<span class="string">&quot;path.separator&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Split the path to array</span></span><br><span class="line">  String[] pathArray = path.split(sep);</span><br><span class="line">  ClassSearchPath[] tmp = <span class="keyword">new</span> ClassSearchPath[pathArray.length];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Implement different class for different path</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pathArray.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pathArray[i].endsWith(<span class="string">&quot;.jar&quot;</span>))&#123;</span><br><span class="line">      tmp[i] = <span class="keyword">new</span> JarSearchPath(pathArray[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp[i] = <span class="keyword">new</span> DirSearchPath(pathArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> InputStream <span class="title">findClass</span><span class="params">(String name)</span></span>;</span><br></pre></td></tr></table></figure><p>而我们每一个具体的SearchPath都要override父类的findClass()方法，拿路径搜索举例：</p><figure class="highlight java"><figcaption><span>DirSearchPath内部方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String searchDir;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DirSearchPath</span><span class="params">(String dir)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.searchDir = dir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">findClass</span><span class="params">(String dir)</span> </span>&#123;</span><br><span class="line">  String fileDir = <span class="keyword">this</span>.searchDir + System.getProperty(<span class="string">&quot;file.separator&quot;</span>) + dir + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open it directly</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FileInputStream(fileDir);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="构造读取字节码内容的代码"><a href="#构造读取字节码内容的代码" class="headerlink" title="构造读取字节码内容的代码"></a>构造读取字节码内容的代码</h2><div class="story post-story"><p><strong>待更新。</strong></p></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> Java Virtual Machine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式：观察者模式与装饰者模式</title>
      <link href="Programming/design-pattern-1/"/>
      <url>Programming/design-pattern-1/</url>
      
        <content type="html"><![CDATA[<p>通过自己举出的一些设计例子，配合代码，学习观察者模式和装饰者模式。这篇文章包含了两个不相关的内容，分别对应书上两个不同的章节。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><div class="story post-story"><p>假设目前我们有一位教务处老师，这位老师希望同学们帮他制作一个电子公告栏。亲切的教务处老师送给我们一段源码。</p><figure class="highlight java"><figcaption><span>ManagementSys类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManagementSys</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String courseName;</span><br><span class="line">    <span class="keyword">private</span> String courseSchedule;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCourseName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCourseSchedule</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infoChanged</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>教务处老师给出了获得课程信息，课程时间，授课老师等等一系列的<code>getter</code>方法。而且，每次老师获得新信息之后，都会调用一个<code>infoChanged()</code>方法。我们不需要在意<code>getter</code>的具体实现，只需要根据信息写电子版程序即可。我们很容易得到思路，首先，我定义一个可以显示内容的公告栏类，比如说开课栏目公告栏、开课时间公告栏等等，再为公告栏类增加<code>update()</code>方法来更新内容，因此…</p><figure class="highlight java"><figcaption><span>infoChanged()方法实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infoChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String courseName = getCourseName();</span><br><span class="line">    String courseSchedule = getCourseSchedule();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    courseAvailableDisplay.update(courseName, ...);</span><br><span class="line">    courseScheduleDisplay.update(courseSchedule, ...);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这应该是大部分人直觉中的方法，至少是我的。但是，这违反了我们曾经学习的设计原则。首先，我们没有封装变化的部分，大家的<code>update()</code>至少在形式上是一致的，应该被封装起来；其次，我们现在面向实现编程，也就是说，我们把<code>infoChanged()</code>将会更新哪些公告板写死在代码中。如果我们未来想要添加新的展板，我们不得不也修改这里的代码，并且我们将无法做到在运行时动态的改变是否更新某个告示板。不太好！</p><p>于是，我自己提出了一个解决方案，我打算让这些公告栏都继承自主公告栏类，这样它们就拥有相同的<code>update()</code>方法，当然我也可以用继承加多态的方式直接遍历所有<code>Display</code>对象，就如同下面这样：</p><figure class="highlight java"><figcaption><span>ManagementSys类内部</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span> ArrayList DisplayList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ManagementSys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DisplayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infoChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DisplayList.size(); ++i)&#123;</span><br><span class="line">        DisplayList.get(i).update(foo, bar, ...); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>将对象添加到数组的过程就相当于同意接受更新，也可以动态去除。我们来看看我们提出的土方法和观察者模式之间有何异同。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>观察者模式</strong>定义了对象之间的一对多依赖，这样一来当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。观察者模式将会设计一个主题(Subject)接口，其方法有添加观察者、去除观察者和通知观察者；以及一个观察者(Observer)接口，拥有更新的方法。具体的主题总是会实现主题接口，而具体的观察者将会实现观察者接口。</p><p>观察者模式提供的设计允许主题和观察者之间<strong>松耦合</strong>。这是什么意思？松耦合意味着两个对象之间可以交互，但是彼此并不明白各自的细节。主题只知道有某个类实现了观察者接口，但对于这个类是什么，将会做什么，主题不知道也不关心。如果我需要在其他地方使用主题或者观察者，那么可以轻易复用。这就带来了我们的第四个设计原则：<strong>为了交互对象之间的松耦合设计而努力。</strong></p><h3 id="重新设计"><a href="#重新设计" class="headerlink" title="重新设计"></a>重新设计</h3><p>根据我们已有的信息，我们来重新设计一下我们的系统，首先当然实现我们的主题-观察者接口。</p><figure class="highlight java"><figcaption><span>观察者接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;   <span class="comment">// 注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;     <span class="comment">// 移除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;              <span class="comment">// 通知，当主题有东西改变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(argu, ...)</span>   <span class="comment">//</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>有了接口之后，我们可以让<code>ManagementSys</code>实现接口…</p><figure class="highlight java"><figcaption><span>ManagementSys类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManagementSys</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList observers;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ManagementSys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; observers.size(); ++i)&#123;</span><br><span class="line">            Observer observer = (Observer)observers.get(i);</span><br><span class="line">            observer.update(foo, bar, ...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this.XX = XX;</span></span><br><span class="line">        infoChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infoChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不得不说，我们的土方法可以算是和观察者模式非常接近了，但是我们并没有把观察者和主题抽象成接口，也没有把存储观察者的ArrayList封装起来。对于单个项目来说，我想我们已经做的足够好了。不过，如果要讨论到可复用性，还是书上提出的方法更加完善。任何类只要实现了写好的接口就可以达到效果。这样，我们也可以针对性地修改我们的告示牌，只需要实现<code>Observer</code>接口，并在<code>update()</code>方法中选择自己需要的参数进行更新就可以了。</p><h3 id="内置的观察者模式"><a href="#内置的观察者模式" class="headerlink" title="内置的观察者模式"></a>内置的观察者模式</h3><p>Java API中有内置的观察者模式。<code>java.util</code>中包含基本的Observable类和Observer接口。与我们自己实现的观察者模式不同的是，它支持使用“推”和“拉”两种方式传递数据，同时在做之前需要调用<code>setChanged()</code>方法告知程序已经改变。但是，Java提供的“主题”是一个类，意味着你没有办法进行多继承，而且Observable具有Protected方法，这也会阻止你将Observable实例组合到你自己的类中。简直是我们之前所学的设计原则的灾难啊！</p><p>除了<code>java.util.Observable</code>，在其他各种地方也有类似的观察者模式的设计，比如Swing API中的JButton，其超类AbstractButton具有<code>AddListener()</code>的方法，允许你做到：当按钮被按下时，传递消息到所有的ActionListener中。ActionListener接口则有<code>actionPerformed()</code>方法，相当于本例子中的<code>update()</code>。这些会令人想到在 jQuery，MATLAB App Designer 等工具中编写回调函数。许多GUI框架大量使用了这种模式。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>上文提到的jQuery令我想起了一些事情。想象一下，<code>notifyObservers()</code>方法在循环中对所有观察者调用<code>update()</code>方法时，有一个观察者出现了问题，比如：过长甚至是死循环，抛出异常等等。这样将会打断<code>notifyObservers()</code>方法的整个过程。真不好！所以如果可以，我们应该用<strong>异步</strong>的办法解决这类问题。当然，成熟的GUI框架也都是如此做的。</p></div><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><div class="story post-story"><p>还记得上次的游戏公司吗？现在有新的工作了：你需要设计游戏里在NPC处售卖的武器。现在游戏里已经有一个原始的武器实现了。目前为止，每个武器都会有名字和返回价格的方法，其他的部分我们暂时不关心。</p><figure class="highlight java"><figcaption><span>Weapon超类及其子类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Weapon.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sword.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sword</span> <span class="keyword">extends</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name = <span class="string">&quot;Sword&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Axe.java</span></span><br><span class="line"><span class="comment">// Bow.java</span></span><br><span class="line"><span class="comment">// Spear.java</span></span><br><span class="line"><span class="comment">// Wand.java</span></span><br></pre></td></tr></table></figure><p>即所有的武器都继承自一个超类，各自实现自己的<code>cost()</code>方法。但是现在问题来了，如果只有这些单一的武器多没有意思啊，不会有人喜欢玩我们的游戏的。项目经理告诉你，我们打算做一个：</p><center>[<font color="#8A2BE2"> 稀有的 </font> <font color="#FF8C00"> 火焰附加 </font> <font color="#DB7093"> 恶灵退治 </font> <font color="#DC143C"> 吸血 </font> 长剑 <font color="#4169E1"> +3 </font>]</center><p>…怎么办？可不要说我们要实现下面的这个类：</p><figure class="highlight java"><figcaption><span>Can't believe I actually typed these</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RareFlameAspectUndeadSlayerVampireLongSwordPlusThree</span> <span class="keyword">extends</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我不想写他的构造函数了，但是你懂会出现什么的</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">173</span>,<span class="number">423.02</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，原始的武器实现严重违反了我们的设计原则：独立变化之处，少用继承。当然你可能想到了另一种思路，毕竟上面的那把炫酷剑，到头来说也是剑嘛。我们可以让剑HAS-A炫酷属性，不就解决问题了吗？</p><figure class="highlight java"><figcaption><span>尝试重设计 Weapon 类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hasFlameAspect</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hasVampire</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是书上给出的方案，但我觉得不够好，或者说完全不好，我甚至想不到如何计算价格，难道要遍历这些方法？书上的例子是否有些为了否定而否定呢？<br>HAS-A并不是无法解决这个问题。我想到，此时我们也许应该用到我们之前学习的策略模式，将炫酷属性封装起来，成为一个接口，具体的炫酷属性将会实现这个接口，并且再用一个ArrayList存储它们，现在我们就将变化之处独立出来了。如果游戏多了新的炫酷效果，那么我们只需要实现炫酷效果本身即可。</p><figure class="highlight java"><figcaption><span>策略模式的 Weapon 类设计</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Weapon.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    ArrayList allAbilities;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sword.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sword</span> <span class="keyword">extends</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        allAbilities = <span class="keyword">new</span> ArrayList&lt;WeaponAbility&gt;();</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;Sword&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>.cost = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAbility</span><span class="params">(WeaponAbility a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加入数组</span></span><br><span class="line">        <span class="comment">// 更新价格和名字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">WeaponAbility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> cost;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可能会实现属性的能力</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlameAspect</span> <span class="keyword">implements</span> <span class="title">WeaponAbility</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlameAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cost = <span class="number">109.3</span>;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;Flame Aspect&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看来其他的设计模式并不是不可行，我们也做到了使用组合不使用继承。但是毕竟我们这一节是讲装饰者模式嘛！装饰者模式究竟比我们以上的代码优越在何处？这需要我们理解我们的第五个设计原则：<strong>类应该对扩展开放，对修改关闭</strong>。可以用任何想要的行为扩展类，但是尽量不要修改类的代码。可能现在代码已经被写好，如果这个时候去修改Weapon类的属性，构造函数等等，就会出一些问题。装饰者模式严格遵守了开放-关闭原则，让我们看看这是怎么做到的。</p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>装饰者模式</strong>动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的方案。装饰者超类本身将会<strong>继承现有的超类</strong>。也就是说，在本例子中，装饰者超类和<code>Sword</code>类是同级别的。同时，装饰者的具体实现是继承了装饰者超类的。</p><p>等一下？不是不要使用继承要用组合吗？但其实，本处继承的重点是，要求装饰者和被装饰者必须是一样的类型。我们所做的事情是“类型匹配”，而非获得任何行为。当我们把装饰者和组件结合时，才是加入了新的行为。获得行为的方式是组合而来的。</p><h3 id="重新设计-1"><a href="#重新设计-1" class="headerlink" title="重新设计"></a>重新设计</h3><p>我们现在可以重新设计我们的武器属性了，首先，Weapon类不需要做任何变化，我们之前写好的Sword类也不需要变化，来看看装饰者的超类如何实现。</p><figure class="highlight java"><figcaption><span>WeaponDecorator 类实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WeaponDecorator</span> <span class="keyword">extends</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先别急着疑惑，我们再具体实现一个装饰者，这样就能具体看到它的作用了。</p><figure class="highlight java"><figcaption><span>Vampire 类实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vampire</span> <span class="keyword">extends</span> <span class="title">WeaponDecorator</span> </span>&#123;</span><br><span class="line">    Weapon weapon;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vampire</span><span class="params">(Weapon weapon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weapon = weapon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Vampire &quot;</span> + weapon.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200.3</span> + weapon.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，装饰者超类必须实现其父类需要改变的方法，而具体的装饰者将会override这些方法，并进行具体的改动。这样的行为可以让我们得到神奇的效果（我已经在兴奋了）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Weapon sellWeapon = <span class="keyword">new</span> Vampire(<span class="keyword">new</span> UndeadSlayer(<span class="keyword">new</span> FlameAspect(<span class="keyword">new</span> Rare(<span class="keyword">new</span> Sword()))));</span><br></pre></td></tr></table></figure><p>真是美丽又可怕！这立刻让我们想到了别的东西。</p><h3 id="真实世界的装饰者"><a href="#真实世界的装饰者" class="headerlink" title="真实世界的装饰者"></a>真实世界的装饰者</h3><p>装饰者竟在我身边，想想你曾经要做文件流读写的时候写过的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader iptStrm = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FIleInputStream(arg));</span><br></pre></td></tr></table></figure><p>这样看来，装饰者模式的缺点也非常明显了，因为这样嵌套的小类实在是太多了（比如我的一位朋友对于Java的印象就是：有很多new）。</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="story post-story"><p>来看看我们新学到的东西：</p><ul><li><strong>设计原则四：为了交互对象之间的松耦合设计而努力。</strong></li><li><strong>设计原则五：类要对扩展开放，对修改关闭。</strong></li><li><strong>观察者模式：定义对象之间的一对多依赖，这样一来当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</strong></li><li><strong>装饰者模式：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的方案。</strong></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solidity 语言的形式化规约</title>
      <link href="Programming/solidity-formal-specification/"/>
      <url>Programming/solidity-formal-specification/</url>
      
        <content type="html"><![CDATA[<p>智能合约与其他软件一样容易有错误和漏洞。在以太坊环境下，任何错误都伴随着潜在的对金融的破坏性结果。因此引入了形式化规约来验证操作。形式化规约存在相当多的形式，并拥有严谨的数学证明来描述系统行为，从<strong>事件所跟踪的具体的区块链上数据</strong>的角度来具体说明智能合约的行为。本文将给出两种不同的形式化规约。</p><h2 id="基于事件的形式化规约"><a href="#基于事件的形式化规约" class="headerlink" title="基于事件的形式化规约"></a>基于事件的形式化规约</h2><div class="story post-story"><p>一篇来自<a href="http://www.bme.hu/?language=en">BME</a>的论文介绍了基于事件的形式化规约，并给出了名为 <code>SOLC_VERIFY</code>的 验证程序。但是本文章只关心其提出的形式化规约说明。验证程序基于模块化程序验证，由Mike Barnett在其之前的<a href="https://link.springer.com/chapter/10.1007/11804192_17">论文</a>中提出，这与计算科学和程序语义等学科相关，不做讨论。</p><h3 id="智能合约事件介绍"><a href="#智能合约事件介绍" class="headerlink" title="智能合约事件介绍"></a>智能合约事件介绍</h3><p>本文介绍的方法主要用于依靠事件 (Event) 传递消息的 Solidity 程序。</p><p>Solidity 是面向合约的智能合约编程语言的代表。而事件代表了与用户相关的、有限的交易执行。合约可以利用事件传递链上数据的状态改变情况。技术上来说，事件可以看做有参数的触发器，其存储位置位于<strong>区块链的日志</strong>。这些日志是合约无法访问的，而用户却可以轻易的监听这些事件从而获得值。以往，事件往往是被认为是一种<strong>日志记录机制</strong>，与程序设计的正确性无关。然而，既然事件是DAPP中最主要的为用户设计的状态改变提示机制，确保用户正确理解且信任发送的事件是十分关键的。</p><p>Solidity 不为发送事件设置任何限制，因此错误的（或恶意的）合约可以发送与状态改变不一致的事件，或对于某些改变忽略发送事件，潜在的将会误导用户。</p><h3 id="语法举例"><a href="#语法举例" class="headerlink" title="语法举例"></a>语法举例</h3><p>请首先看已经加入形式化规约的 Solidity 演示代码：</p><figure class="highlight js"><figcaption><span>Solidity</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">contract Registry &#123;</span><br><span class="line">struct Entry &#123; bool set; int data; &#125; <span class="comment">// User-defined type</span></span><br><span class="line">mapping(<span class="function"><span class="params">address</span>=&gt;</span>Entry) entries; <span class="comment">// State variable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// @notice tracks-changes-in entries</span></span><br><span class="line"><span class="comment">/// @notice precondition !entries[at].set</span></span><br><span class="line"><span class="comment">/// @notice postcondition entries[at].set &amp;&amp; entries[at].data == value </span></span><br><span class="line">event new_entry(address at, int value);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @notice tracks-changes-in entries</span></span><br><span class="line"><span class="comment">/// @notice precondition entries[at].set &amp;&amp; entries[at].data &lt; value </span></span><br><span class="line"><span class="comment">/// @notice postcondition entries[at].set &amp;&amp; entries[at].data == value </span></span><br><span class="line">event updated_entry(address at, int value);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @notice emits new_entry</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">int value</span>) <span class="title">public</span> </span>&#123; </span><br><span class="line"><span class="built_in">require</span>(!entries[msg.sender].set); </span><br><span class="line">entries[msg.sender].set = <span class="literal">true</span>; </span><br><span class="line">entries[msg.sender].data = value; </span><br><span class="line">emit new_entry(msg.sender, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @notice emits updated_entry</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">int value</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line"><span class="built_in">require</span>(entries[msg.sender].set &amp;&amp; entries[msg.sender].data &lt; value); </span><br><span class="line">entries[msg.sender].data = value;</span><br><span class="line">emit updated_entry(msg.sender, value);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 演示代码非常简单，定义了一个 Entry 结构，和一个地址到 Entry 的映射的变量（在文章中叫做状态变量，<strong>state variable</strong>)；两个事件，一个代表新加入合约，另一个代表更新加入合约。以及添加和更新的函数。</p><p>首先，某个事件都跟随的是 <code>entries</code> 变量的变化，因此我们写出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; @notice tracks-changes-in entries</span><br></pre></td></tr></table></figure><p><code>tracks-changes-in</code> 关键字所说明的事实是：事件被触发<strong>当且仅当</strong>被跟踪的变量改变。由于数据经常以多步过程的形式改变（如例子中，函数依次更新了 Entry 结构中的两个数据），或者数据更新存在某种条件，因此事件不会总是立刻跟在某个追踪变量的改动后。因此，文章提出了前/后检查点的概念。前检查点是由事件所追踪的变量的第一次改变所动态的定义的。相对的，后检查点是一个静态边界，一般是循环或交易的边缘。<em>说白了就是，你的事件<strong>必须</strong>要在你跟的变量第一次改变之后，离开程序之前进行一次激发。</em></p><p>在跟随变量以外，事件也可以被用 <code>predicates</code> 来注释，它是用状态变量和事件的参数来定义的，并且有两种，<code>preconditions</code> 和 <code>postconditions</code>。前置条件在前检查点前捕捉状态变量的值，而后置条件对应着事件被发送的时刻。</p><p>举例来说，对于 <code>new_entry</code> 事件，其要求用户一开始不处于 <code>entries</code>，即<code>set</code> 布尔类型为假，且事件发出后用户属于<code>entries</code>，<code>data</code> 被赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; @notice precondition !entries[at].set</span><br><span class="line">&#x2F;&#x2F;&#x2F; @notice postcondition entries[at].set &amp;&amp; entries[at].data &#x3D;&#x3D; value </span><br><span class="line">event new_entry(address at, int value);</span><br></pre></td></tr></table></figure><p>最后，发射事件的函数必须被标记处发射了何等事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; @notice emits updated_entry</span><br><span class="line">function update(int value) public &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="基于函数的形式化规约"><a href="#基于函数的形式化规约" class="headerlink" title="基于函数的形式化规约"></a>基于函数的形式化规约</h2><div class="story post-story"><p>基于函数的形式化规约和基于事件的有很多相似之处（<em>并且是南大78004870课程所讲述的模式</em>），只是把修改变量的规约放在函数（与合约、循环）前。并且由于函数可以对值进行修改，而非像事件一样仅展现变化，所以会比基于事件的规约增加其他的东西。请看下例：</p><figure class="highlight js"><figcaption><span>Solidity</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @notice invariant x == y</span></span><br><span class="line">contract Track &#123;</span><br><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @notice precondition x == y</span></span><br><span class="line"><span class="comment">/// @notice postcondition x == (y + n)</span></span><br><span class="line"><span class="comment">/// @notice modifies x</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add_to_x</span>(<span class="params">int n</span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">x = x + n;</span><br><span class="line"><span class="built_in">require</span>(x &gt;= y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @notice modifies x if n &gt; 0</span></span><br><span class="line"><span class="comment">/// @notice modifies y if n &gt; 0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">int n</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line"><span class="built_in">require</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">add_to_x(n);</span><br><span class="line"><span class="comment">/// @notice invariant y&lt;=x</span></span><br><span class="line"><span class="function"><span class="title">while</span>(<span class="params">y &lt; x</span>)</span> &#123;</span><br><span class="line">y = y + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由例子，我们可以总结出基本的语句：</p><ul><li><p>如果某变量没有被改变，那么需要注明<strong>不变式</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invariant &lt;EXPRESSION&gt;</span><br></pre></td></tr></table></figure><p>注意，不变式出现在循环，合约，函数前。</p></li></ul><ul><li><p>如果函数开始前/结束后必须满足某条件，那么需要注明<strong>前置条件</strong>/<strong>后置条件</strong>，与基于事件的一样。</p></li><li><p>如果函数执行改变了状态变量，那么需要注明<strong>修改规约</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modifies &lt;TARGET&gt; [if &lt;CONDITION&gt;]</span><br></pre></td></tr></table></figure></li></ul><h3 id="进阶的规约表达"><a href="#进阶的规约表达" class="headerlink" title="进阶的规约表达"></a>进阶的规约表达</h3><p>课程同时给出了一些进阶的规约表达方式，例如：</p><ul><li><p>聚合计算的表达：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__verifier_sum_&lt;TYPE&gt;( ... )</span><br></pre></td></tr></table></figure><p>所代表了将 <code>&lt;TYPE&gt;</code> 相加所得到的结果。</p></li><li><p>复合数据类型判等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__verifier_eq(..., ...)</span><br></pre></td></tr></table></figure><p>其实就是更加复杂的 <code>x == y</code>。</p></li><li><p>变量旧值引用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__verifier_old_&lt;TYPE&gt;</span><br></pre></td></tr></table></figure><p><em>也许是在循环中引用上一次的值或者引用修改前的值</em>。</p></li><li><p>谓词逻辑表达：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">forall (&lt;VARS&gt;) &lt;QUANTEXPR&gt;</span><br><span class="line"></span><br><span class="line">exists (&lt;VARS&gt;) &lt;QUANTEXPR&gt;</span><br></pre></td></tr></table></figure><p>举例来说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forall (uint λ) !(λ &gt;&#x3D; 0 &amp;&amp; λ &lt; length)</span><br></pre></td></tr></table></figure></li></ul></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="story post-story"><p>形式化规约是一种让程序设计更加严谨的实现，而对于对准确度要求高的智能合约来说更加有用。即使没有检查器，掌握形式化合约也有助于形成良好的变量追踪与查询习惯。</p></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
            <tag> Solidity </tag>
            
            <tag> 智能合约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的以太坊智能合约部署</title>
      <link href="Programming/smart-contract/"/>
      <url>Programming/smart-contract/</url>
      
        <content type="html"><![CDATA[<p>可以简单的把以太坊虚拟机理解为一个公开使用的后端服务器，用户在其上拥有有限的操作空间，每次操作以交易的形式产生，并会根据修改数据的大小向用户收费，称为 <strong>Gas</strong>，以此支持服务器维护人员 (即矿工)。并且，服务器上的数据会被永久记录，操作后端数据的代码 (对于EVM，是 Solidity 代码) 也存放在服务器上不能被修改。</p><p>矿工可以根据 Gas 和数据操作量选择将哪一笔交易加入区块。因此 Solidity 编程要求存储尽量少的数据，节省空间和操作量，以此得到更快速的响应。</p><h2 id="使用-Remix-和-Ganache"><a href="#使用-Remix-和-Ganache" class="headerlink" title="使用 Remix 和 Ganache"></a>使用 Remix 和 Ganache</h2><div class="story post-story"><p><a href="https://remix.ethereum.org/">Remix</a> 是以太坊官方提供的 Solidity 开发环境。在 Remix 内写好代码后可以编译，编译会得到程序的二进制程序接口，称为 ABI。ABI 会提供给 web3.js 来提供操作接口。在编译后可以部署合约，Remix 本身提供了一些 JavaScript 虚拟机来运行智能合约。为了观察到用户和交易的情况，我们可以部署私有链，利用 Ganache。部署后会得到合约地址，你也可以直接在 Remix 和合约交互。</p><p><a href="https://trufflesuite.com/ganache/index.html">Ganache</a> 可以在本地设置好私有区块链，即开即用。用户可以自行设置端口号，而网络ID为5777而区块链ID为1337。在本地部署好之后，使用 MetaMask 钱包添加私有链。MetaMask 也可以使用其他测试链，虽然其他测试链可以有更多的用户，但在这些链上我们难以观察交易情况。添加私有链后，也记得添加私有链的账户。</p><p>说到账户，对于以太坊地址来说，所有链上的地址格式都完全一致。因此，你的任何一个账户都可以在任何链上使用（当然代币不会跟随）。可以尝试把 Ganache 里生成的账户的钱转入一个你主链的地址，操作将会成功且主链地址<strong>在私有链</strong>上的 ETH 会增加。注意 Ganache 不会追踪除了它生成的账户以外的账户（因为无穷多），但是你仍然可以看到 TX 信息，就在 Ganache 的操作面板。这到底是怎么做到的？得益于钱包地址的随机和海量，生成的两个地址相同的概率几乎是不可能的。</p></div><h2 id="Solidity-代码"><a href="#Solidity-代码" class="headerlink" title="Solidity 代码"></a>Solidity 代码</h2><div class="story post-story"><p>设计一个 Solidity 代码，对于每个账户存放一个数据，并且允许用户查看数据。</p><p>(<em>很遗憾，Hexo 对于 Solidity 代码暂时没有语法高亮，我也不想使用 hightlight.js，所以我随便选用了一种代码高亮模式。</em>)</p><figure class="highlight c#"><figcaption><span>Solidity</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明 License</span></span><br><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line"><span class="comment">// 声明编译器版本</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.7</span><span class="number">.0</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合约，就像一个类</span></span><br><span class="line">contract numberHolder &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射数据结构</span></span><br><span class="line">    mapping(address =&gt; uint16) userNumbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个事件</span></span><br><span class="line"><span class="function"><span class="keyword">event</span> <span class="title">numberSetted</span>(<span class="params">address addr,uint16 num</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地址的数据的setter函数</span></span><br><span class="line">    <span class="function">function <span class="title">setNumber</span>(<span class="params">uint16 inputNumber</span>) <span class="keyword">public</span></span>&#123;</span><br><span class="line">        userNumbers[msg.sender] = inputNumber;</span><br><span class="line">        <span class="comment">// 发送事件给前端</span></span><br><span class="line"><span class="function">emit <span class="title">numberSetted</span>(<span class="params">msg.sender, userNumbers[msg.sender]</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个只读函数获得用户地址和数据</span></span><br><span class="line">    <span class="function">function <span class="title">getNumber</span>(<span class="params"></span>) <span class="keyword">public</span> view <span class="title">returns</span> (<span class="params">uint16</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userNumbers[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">getAddress</span>(<span class="params"></span>) <span class="keyword">public</span> view <span class="title">returns</span> (<span class="params">address</span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> msg.sender;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体内容可以查看 Solidity 的<a href="https://solidity-cn.readthedocs.io/zh/develop/">文档</a>。函数发射的事件需要在前端进行监听。关键字 <code>view</code> 代表了这个函数不会操作数据。全局变量 <code>msg</code> 存储了一些当前合约的信息，例如 <code>msg.sender</code> 就是调用合约的地址。</p></div><h2 id="Web-代码"><a href="#Web-代码" class="headerlink" title="Web 代码"></a>Web 代码</h2><div class="story post-story"><p>Web 端我们使用以太坊 JavaScript API和后端交互，叫做 web3.js，使用此库类似于使用 jQuery 的 ajax。实际上，包括部署合约在内的操作都可以用 web3.js 完成，但本次我们不这样做。</p><p>在网页端，首先用简单 HTML 完成界面，给用户提示信息，显示一个可变文本并设置两个按钮：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>数字存放<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    在数据框中输入一个数字并点击上传数据，它将会被存储至区块，请注意这会消耗燃料。<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    点击获得数据将会显示您已经存储的数据，这不会消耗燃料。</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;info&quot;</span>&gt;</span>等待输入<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;data&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-2 control-label&quot;</span>&gt;</span>您的数据<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;data&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button_update&quot;</span>&gt;</span>上传数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button_download&quot;</span>&gt;</span>获得数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来在 <code>&lt;script&gt;</code> 部分设计网页的逻辑。别忘记把 web3.js 和 jQuery 加入到网页中。首先配置好我们的 web3 库：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    web3 = <span class="keyword">new</span> Web3(web3.currentProvider);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">&quot;http://localhost:8545&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这声明了，我们的 web3 是由 HTTP 在本地8545端口提供，也就是我们的 Ganache。接下来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.defaultAccount = web3.eth.accounts[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> contractABI = web3.eth.contract(<span class="comment">/* ABI Here */</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myContract = contractABI.at(<span class="string">&#x27;0x6f0D3623...&#x27;</span>)</span><br></pre></td></tr></table></figure><p>第一行代码说明了我们默认交互账户是 Ganache 里的第一个账户。我们现在还不将 MetaMask 链接功能提供在前端。MetaMask 要求前端网页不能是本地打开的，必须运行在一个服务器上 (Python 搭建的简易 HTTP 服务器就可以)，并且需要更复杂且完善的代码。第二行代码需要我们写入之前在 Remix 得到的 ABI，这是我们交互的基础。第三行就是合约本身，从语义上可以理解为：某个 ABI 位于某个确定的地址上。这个地址可以在 Remix 处看到，或在 Ganache 的 TX 信息里找到。</p><p>接下来我们来看一下在前端如何调用 Solidity 函数，并用 jQuery 改变前端显示。首先演示一下按钮如何获得数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#button_update&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">myContract.setNumber($(<span class="string">&quot;#data&quot;</span>).val());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;#button_download&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#info&quot;</span>).html(<span class="string">&#x27;您的地址：&#x27;</span> + myContract.getAddress.call() + <span class="string">&#x27;&lt;br&gt;&#x27;</span> + <span class="string">&#x27;您存储的数字：&#x27;</span> + myContract.getNumber.call() + <span class="string">&#x27;&lt;br&gt; 操作：读取数字&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对于 jQuery，简单的语法是利用 <code>$(&quot;#id&quot;)</code> 选中 HTML 对应 ID 的内容，在此是按钮类型。按钮类型具有 <code>click()</code> 方法，我们在内部写出一个函数，意思是“如果按钮被按下，那么执行这个函数，函数的内容是使用合约内的 setNumber() 函数，函数的参数是 HTML 中 ID 为 data 的元素的值”。对于下面获得值的操作，同理。 </p><p>再来看看怎么监听我们发出的事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eventSet = myContract.numberSetted()</span><br><span class="line">eventSet.watch(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">!error</span>)</span> &#123;</span><br><span class="line">        $(<span class="string">&quot;#info&quot;</span>).html(<span class="string">&#x27;您的地址：&#x27;</span> + result.args.addr + <span class="string">&#x27;&lt;br&gt;&#x27;</span> + <span class="string">&#x27;您存储的数字：&#x27;</span> + result.args.num</span><br><span class="line">        + <span class="string">&#x27;&lt;br&gt;&#x27;</span> + <span class="string">&#x27;操作：设置数字&#x27;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>基本原理同以上相同，我们将合约的 numberSetted 事件声明成一个变量，对这个变量进行 watch() 方法。里面的函数和刚才的差不多，它具有了两个参数。因为 web3 要求我们进行异常处理，即需要有 <code>if(!error) &#123;&#125; elese &#123;&#125;</code> 的形式。另一个参数 <code>result</code> 里面包含了我们在 Solidity 中写过的两个返回值。如果不太明白，可以在浏览器打开控制台观察一下 <code>log</code>，会完整展现 <code>result</code> 的结构。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://s2.loli.net/2022/03/29/9HjxGlDdiQqRuUv.png" class="lazyload" data-srcset="https://s2.loli.net/2022/03/29/9HjxGlDdiQqRuUv.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="网页的样子"></div><span class="image-caption">网页的样子</span></div></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="story post-story"><p>目前我们的前端已经可以在本地运行了。不过像这样直接链接私有链，利用索引选择调用合约的用户以及函数的处理方式都非常原始，只能作演示用。之后会尽量设计更完善的代码。</p></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
            <tag> Solidity </tag>
            
            <tag> 智能合约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题记录 - 键盘测试</title>
      <link href="Note/algorithm-0/"/>
      <url>Note/algorithm-0/</url>
      
        <content type="html"><![CDATA[<p>羊羊买了新键盘，并邀请大家来试用键盘，但前提是回答出以下问题。</p><blockquote><p>您将获得两个字符串s和t，两者都由小写的英文字母组成。您将逐个字符地键入字符串s，从第一个字符到最后一个字符。</p><p>特别之处在于，键入字符时，您可以按<code>Backspace</code>按钮，而不是按与之对应的按钮。<code>Backspace</code>会删除您刚刚键入的最后一个字符（如果您键入的字符串中没有字符，则不执行任何操作）。例如，如果s是”abcbd”，并且您按<code>Backspace</code>而不是键入第一个和第四个字符，您将获得字符串”bd”（第一次按<code>Backspace</code>不删除任何字符，第二次按删除字符”c”）。另一个例子，如果s是”abcaa”，并且您用<code>Backspace</code>键代替最后两个字母，则得到的文本为”a”。</p><p>您的任务是确定是否可以通过以上方式，从字符串s获取字符串t.</p></blockquote><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><div class="story post-story"><p>第一行是一个整数 q (1≤q≤10^5），代表测试用例的数量。<br>每个测试用例的第一行是字符串s (1≤s的长度≤10^5)，s中的每个字符是小写的英文字母。<br>每个测试用例的第二行是字符串t (1≤t的长度≤10^5)，t中的每个字符是小写的英文字母。</p><p>对于每个测试用例，如果可以按本题的方式从s得到t，请打印”YES“,否则，打印“NO”。</p><figure class="highlight text"><figcaption><span>Input</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">ababa</span><br><span class="line">ba</span><br><span class="line">ababa</span><br><span class="line">bb</span><br><span class="line">aaa</span><br><span class="line">aaaa</span><br><span class="line">aababa</span><br><span class="line">ababa</span><br></pre></td></tr></table></figure><figure class="highlight text"><figcaption><span>Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure></div><h2 id="初始想法"><a href="#初始想法" class="headerlink" title="初始想法"></a>初始想法</h2><div class="story post-story"><p>看到题目首先观察了 s 和 t 的联系。首先的想法如下：</p><ul><li>对于 s，首先寻找其中所包含的第一个 t[0]。如果没有 t[0]，那么肯定无法输出。</li><li>如果有 t[0]，接着去找 t[1]，看看两个字母之间的字母数是不是偶数个（打出，删除，打出，删除…）。如果不是，那么肯定无法输出。</li><li>如果还是，那么继续重复以上的步骤，直到 t 越界。</li></ul><p>遇到的问题：</p><ul><li>aababa 和 ababa 无法处理。说明如果 s 存在 t[0]，但完全无效，则应该去除 s 中 t[0] 即其之前的部分，重新进行测试。但是此方法只适用于 t[0]，因为实际上在符合要求的 t[0] 于 s 中出现之前，用户可以什么都不输入只按退格键。并且，这样的方法对于大数据来说太慢了。</li><li>本身的算法就非常难设计，需要三个指针，两个位于 s 标定位置，一个位于 t 指向当前的内容。</li></ul></div><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><div class="story post-story"><p>反向思考，如果说开头的东西可以忽视会让人难以处理，那么把开头放在最后就好了。同时，我们知道符合要求的字符串 s 的尾部要么和 t 完全一致，要么最后相差偶数个。所以最终的设计是，从 s 和 t 的尾部开始遍历，如果相同就同时前进 1 个字母，再比较；如果不同，则 s 前进2 个字母，再比较。直到 s 或 t 某个字符串结束。最后再判断 t 有没有结束。如果 t 结束了，那么答案就是 YES，此时 s 最开始的部分就是那些我们可以只按退格键的字符。</p><p>Python 代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">special_typing</span>():</span></span><br><span class="line">    stringNum = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(stringNum != <span class="number">0</span>):</span><br><span class="line">        stringS = <span class="built_in">list</span>(<span class="built_in">input</span>())</span><br><span class="line">        stringT = <span class="built_in">list</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">        comparePointer = <span class="built_in">len</span>(stringS) - <span class="number">1</span></span><br><span class="line">        current = <span class="built_in">len</span>(stringT) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(current &gt;= <span class="number">0</span>) <span class="keyword">and</span> (comparePointer &gt;= <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">if</span>(stringT[current] == stringS[comparePointer]):</span><br><span class="line">                current -= <span class="number">1</span></span><br><span class="line">                comparePointer -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                comparePointer -= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(current &lt; <span class="number">0</span>):</span><br><span class="line">            print(<span class="string">&quot;YES&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;NO&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        stringNum -= <span class="number">1</span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式：基本思想与策略模式</title>
      <link href="Programming/design-pattern-0/"/>
      <url>Programming/design-pattern-0/</url>
      
        <content type="html"><![CDATA[<p>知道继承，接口，多态和虚类不能让你学会面向对象程序设计。理解<strong>设计模式</strong>，因为设计模式是面向对象开发工程师们多年以来程序设计的经验总结，是为了解决问题而产生的历经验证的工程通用解决方案。良好的设计模式会包含可复用，可扩充，可维护三个特性，而模式可以帮我们做到这点。</p><p>首先来举个简单的例子，来展示继承所不能解决的问题。如图，某游戏公司程序员为自己游戏的职业系统设计了一个 Player 超类，所有的职业都会继承这个超类。在继承时，也会继承超类内所有的方法。如果需要新的职业，那么我们就添加一个新的类。完美！</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://s2.loli.net/2022/03/28/RJelt4WkrKUqCE8.png" class="lazyload" data-srcset="https://s2.loli.net/2022/03/28/RJelt4WkrKUqCE8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="美丽的UML图"></div><span class="image-caption">美丽的UML图</span></div><p>现在公司抛出了新的需求：要求玩家应该会闪避。这很好办，只需要在超类里加入一个 dodge() 方法即可。但是在测试的时候发现了新的问题：牧师会闪避导致了他过于强大的生存能力，以至于不需要队友保护他。这和游戏的设计理念不太符合，公司要求程序员让牧师不再会闪避。这也很简单，把 Priest 的 dodge() 方法的具体实现覆盖成什么都不做就可以了。到目前为止，一切都很好…</p><p>直到程序员意识到，公司为了赚钱每个月都会推出一款新职业，他们有的专注攻击不能防御，有的利用防御来攻击，有的……噢还有，公司还会推出氪金装备，使得 Priest 可以有限次的进行闪避动作。天啊，这要怎么办？来看看我们从最初的设计原则可以推出什么。</p><h2 id="变与不变"><a href="#变与不变" class="headerlink" title="变与不变"></a>变与不变</h2><div class="story post-story"><p>应用设计的第一个原则：<strong>找出应用中需要变化之处，将其独立，不要和不需要变化的代码写在一起</strong>。这样，每次新的需求来到，我们就可以不修改固定的部分，只修改变化的部分。</p><p>对于我们的游戏设计来说，我们知道 dodge() 是会随着职业的不同而改变的（<em>当然 attack() 和 defense() 也会变，但是原理是一样的</em> ）。那么我们把闪避行为拿出来，并为它创建一个类。<strong>所有的职业都将 HAS-A 闪避行为。</strong></p></div><h2 id="为谁而写"><a href="#为谁而写" class="headerlink" title="为谁而写"></a>为谁而写</h2><div class="story post-story"><p>应用设计的第二个原则：<strong>针对接口编程，不要针对实现编程</strong>。 说真的，我觉得这句话刚一看到非常难理解。</p><p>什么是实现？职业类如果实现了 dodge() 接口，那么就意味着所有职业都要实现这个接口，因为他们都继承自原始的超类。我们不要把什么类能实现什么在最开始的时候写死。</p><p>怎么针对接口编程？我设计一个 DodgeBehaviour 接口，此接口有 dodge() 方法。现在，我们让具体的类实现这个接口。DodgeNormal 类会正常的躲避，而 DodgeNaught 类什么都不做。现在，闪避行为和 Player 类没有任何关系了。我们可以随意添加闪避行为或者修改行为，比如我们为法师设计一个 DodgeKUXUAN，让闪避的时候会增加粒子效果。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://s2.loli.net/2022/03/28/NQL4YrXentSp9gx.png" class="lazyload" data-srcset="https://s2.loli.net/2022/03/28/NQL4YrXentSp9gx.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="另一个美丽的UML图"></div><span class="image-caption">另一个美丽的UML图</span></div></div><h2 id="完成设计"><a href="#完成设计" class="headerlink" title="完成设计"></a>完成设计</h2><div class="story post-story"><p>现在事情可能会变得有点奇怪，我们如何让某个职业进行闪避？请看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">  healthType Health;</span><br><span class="line">  DodgeBehaviour dodgeBehaviour;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performDodge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dodgeBehaviour.dodge();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们的超类。看，我们通过让职业 HAS-A 行为的方式成功地托管了闪避行为！这也就引出了我们的第三个设计原则：<strong>多用组合，少用继承</strong>。HAS-A is better than IS-A!</p><p>那么相对应的，子类的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Priest</span> <span class="keyword">extends</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Priest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dodgeBehaviour = <span class="keyword">new</span> DodgeNaught();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数里面，我们写好 Priest 会使用哪种 实现了 DodgeBahaviour 的类。不仅如此，如果我们对 dodgeBehaviour 设定一个 setter 函数，我们就可以在程序运行时改变牧师躲避的行为，比如牧师装备了氪金道具，那么就将 dodgeBehaviour 设定成可以闪避并计数，结束后改回去。这比写一个 ”可以进行10次闪避” 的 Priest 职业好太多了！</p><p>同理，攻击和防御方法都可以用相同的方式实现。以上的设计模式我们称为<strong>策略模式</strong>。策略模式<strong>定义且封装了独立于使用算法客户的算法族，使他们相互之间能够替换</strong>。这也不意味着继承方法真的没用了，比如所有的职业都需要走路，那么 walk() 方法就可以继承。关键点是确立好需求，并选择你需要的设计模式。</p><p>（<em>所以，这位程序员该好好跟他的产品经理吵一架 :P</em> ）</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="story post-story"><p>来看看我们目前学到的东西：</p><ul><li><strong>设计原则一：找出应用中需要变化之处，将其独立，不要和不需要变化的代码写在一起。</strong></li><li><strong>设计原则二：针对接口编程，不要针对实现编程。</strong> </li><li><strong>设计原则三：多用组合，少用继承。</strong></li><li><strong>策略模式：定义且封装了独立于使用算法客户的算法族，使他们相互之间能够替换。</strong></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重新记录我的博客</title>
      <link href="Thoughts/init_post/"/>
      <url>Thoughts/init_post/</url>
      
        <content type="html"><![CDATA[<p>两年前，我抱着玩玩的心态在 Github 上部署了一个小博客。然而搜肠刮肚发现自己既没技术，又没文笔，无甚可写，遂作罢。<br>近日和舍友闲谈，偶然间舍友提到了博客。突然想起了自己曾经弄的小站。再联想到自己最近需要学习，记忆力又狠狠衰退，于是打算把博客重拾起来。<br>为了避免自己又忘记什么重要的事，我把操作博客的方法都写下来。</p><h2 id="写作与更新"><a href="#写作与更新" class="headerlink" title="写作与更新"></a>写作与更新</h2><div class="story post-story"><p>在部署时我就选择了 Hexo 托管页面。Hexo 是一个 Node.js 包，它能够自动生成网页，用户所需要做的只是写作。并且，它支持各种插件与主题。</p><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><p>使用如下代码在 <code>/source/_posts/</code> 内新建一个文件夹与 markdown 文件，名字为<code>name.md</code>。<code>name</code>也将组成这篇博客的 url 路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new name</span><br></pre></td></tr></table></figure><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><p>使用Generate功能为前端生成静态文件吧。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">-d (在生成后直接部署)</span><br><span class="line">-w (查看改变内容)</span><br><span class="line">-b (如果生成出错则抛出异常)</span><br><span class="line">-f (强行生成)</span><br><span class="line">-c (控制并行生成量, 默认无限大)</span><br></pre></td></tr></table></figure><p>可以简写为 <code>hexo g</code>。</p><h3 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line">-p (复写默认端口4000)</span><br><span class="line">-s (只serve静态文件)</span><br><span class="line">-l (打印日志)</span><br></pre></td></tr></table></figure><p>同理，<code>hexo s</code> for short.</p><h3 id="部署到远端"><a href="#部署到远端" class="headerlink" title="部署到远端"></a>部署到远端</h3><p>待测试没问题后，push 到 Github 吧：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">-g (在部署前生成)</span><br></pre></td></tr></table></figure><h3 id="清理生成文件"><a href="#清理生成文件" class="headerlink" title="清理生成文件"></a>清理生成文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>这个行为在修改了样式后需要被使用一下。</p></div><h2 id="配置和优化"><a href="#配置和优化" class="headerlink" title="配置和优化"></a>配置和优化</h2><div class="story post-story"><p>关于Hexo的配置，可以在<code>hexo config</code>获取，或者修改<code>_config.yml</code>。</p><p>关于样式配置，可以在 <a href="https://volantis.js.org/v5/getting-started/">Volantis 文档</a>内找到所有需要的内容，包括底栏侧栏导航栏配置等等。<br>对于 Post 的封面，我使用 <a href="https://www.canvas.cn/">Canvas 可画</a>来制作，按照微信公众号的标题随便做一个即可。<br>对于在文章内插图，我使用 <a href="https://sm.ms/">SM.MS</a> 图床。</p></div><h2 id="承诺"><a href="#承诺" class="headerlink" title="承诺"></a>承诺</h2><div class="story post-story"><p>即使发一些毫无意义的 shitpost，我也尽量不会让博客停下来。拖延和懒惰的一部分来自于追求完美，会希望把事情做的足够好的想法，会导致人过分注重细枝末节而最后放弃。</p><p>（2023年某日：笑死，根本没时间写，我是sb）</p></div>]]></content>
      
      
      <categories>
          
          <category> Thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 想法 </tag>
            
            <tag> 记录 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
