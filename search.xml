<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Solidity 语言的形式化规约</title>
      <link href="Programming/solidity-formal-specification/"/>
      <url>Programming/solidity-formal-specification/</url>
      
        <content type="html"><![CDATA[<p>智能合约与其他软件一样容易有错误和漏洞。在以太坊环境下，任何错误都伴随着潜在的对金融的破坏性结果。因此引入了形式化规约来验证操作。形式化规约存在相当多的形式，并拥有严谨的数学证明来描述系统行为，从<strong>事件所跟踪的具体的区块链上数据</strong>的角度来具体说明智能合约的行为。本文将给出两种不同的形式化规约。</p><h2 id="基于事件的形式化规约"><a href="#基于事件的形式化规约" class="headerlink" title="基于事件的形式化规约"></a>基于事件的形式化规约</h2><div class="story post-story"><p>一篇来自<a href="http://www.bme.hu/?language=en">BME</a>的论文介绍了基于事件的形式化规约，并给出了名为 <code>SOLC_VERIFY</code>的 验证程序。但是本文章只关心其提出的形式化规约说明。验证程序基于模块化程序验证，由Mike Barnett在其之前的<a href="https://link.springer.com/chapter/10.1007/11804192_17">论文</a>中提出，这与计算科学和程序语义等学科相关，不做讨论。</p><h3 id="智能合约事件介绍"><a href="#智能合约事件介绍" class="headerlink" title="智能合约事件介绍"></a>智能合约事件介绍</h3><p>本文介绍的方法主要用于依靠事件 (Event) 传递消息的 Solidity 程序。</p><p>Solidity 是面向合约的智能合约编程语言的代表。而事件代表了与用户相关的、有限的交易执行。合约可以利用事件传递链上数据的状态改变情况。技术上来说，事件可以看做有参数的触发器，其存储位置位于<strong>区块链的日志</strong>。这些日志是合约无法访问的，而用户却可以轻易的监听这些事件从而获得值。以往，事件往往是被认为是一种<strong>日志记录机制</strong>，与程序设计的正确性无关。然而，既然事件是DAPP中最主要的为用户设计的状态改变提示机制，确保用户正确理解且信任发送的事件是十分关键的。</p><p>Solidity 不为发送事件设置任何限制，因此错误的（或恶意的）合约可以发送与状态改变不一致的事件，或对于某些改变忽略发送事件，潜在的将会误导用户。</p><h3 id="语法举例"><a href="#语法举例" class="headerlink" title="语法举例"></a>语法举例</h3><p>请首先看已经加入形式化规约的 Solidity 演示代码：</p><figure class="highlight js"><figcaption><span>Solidity</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">contract Registry &#123;</span><br><span class="line">struct Entry &#123; bool set; int data; &#125; <span class="comment">// User-defined type</span></span><br><span class="line">mapping(<span class="function"><span class="params">address</span>=&gt;</span>Entry) entries; <span class="comment">// State variable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// @notice tracks-changes-in entries</span></span><br><span class="line"><span class="comment">/// @notice precondition !entries[at].set</span></span><br><span class="line"><span class="comment">/// @notice postcondition entries[at].set &amp;&amp; entries[at].data == value </span></span><br><span class="line">event new_entry(address at, int value);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @notice tracks-changes-in entries</span></span><br><span class="line"><span class="comment">/// @notice precondition entries[at].set &amp;&amp; entries[at].data &lt; value </span></span><br><span class="line"><span class="comment">/// @notice postcondition entries[at].set &amp;&amp; entries[at].data == value </span></span><br><span class="line">event updated_entry(address at, int value);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @notice emits new_entry</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">int value</span>) <span class="title">public</span> </span>&#123; </span><br><span class="line"><span class="built_in">require</span>(!entries[msg.sender].set); </span><br><span class="line">entries[msg.sender].set = <span class="literal">true</span>; </span><br><span class="line">entries[msg.sender].data = value; </span><br><span class="line">emit new_entry(msg.sender, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @notice emits updated_entry</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">int value</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line"><span class="built_in">require</span>(entries[msg.sender].set &amp;&amp; entries[msg.sender].data &lt; value); </span><br><span class="line">entries[msg.sender].data = value;</span><br><span class="line">emit updated_entry(msg.sender, value);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 演示代码非常简单，定义了一个 Entry 结构，和一个地址到 Entry 的映射的变量（在文章中叫做状态变量，<strong>state variable</strong>)；两个事件，一个代表新加入合约，另一个代表更新加入合约。以及添加和更新的函数。</p><p>首先，某个事件都跟随的是 <code>entries</code> 变量的变化，因此我们写出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; @notice tracks-changes-in entries</span><br></pre></td></tr></table></figure><p><code>tracks-changes-in</code> 关键字所说明的事实是：事件被触发<strong>当且仅当</strong>被跟踪的变量改变。由于数据经常以多步过程的形式改变（如例子中，函数依次更新了 Entry 结构中的两个数据），或者数据更新存在某种条件，因此事件不会总是立刻跟在某个追踪变量的改动后。因此，文章提出了前/后检查点的概念。前检查点是由事件所追踪的变量的第一次改变所动态的定义的。相对的，后检查点是一个静态边界，一般是循环或交易的边缘。<em>说白了就是，你的事件<strong>必须</strong>要在你跟的变量第一次改变之后，离开程序之前进行一次激发。</em></p><p>在跟随变量以外，事件也可以被用 <code>predicates</code> 来注释，它是用状态变量和事件的参数来定义的，并且有两种，<code>preconditions</code> 和 <code>postconditions</code>。前置条件在前检查点前捕捉状态变量的值，而后置条件对应着事件被发送的时刻。</p><p>举例来说，对于 <code>new_entry</code> 事件，其要求用户一开始不处于 <code>entries</code>，即<code>set</code> 布尔类型为假，且事件发出后用户属于<code>entries</code>，<code>data</code> 被赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; @notice precondition !entries[at].set</span><br><span class="line">&#x2F;&#x2F;&#x2F; @notice postcondition entries[at].set &amp;&amp; entries[at].data &#x3D;&#x3D; value </span><br><span class="line">event new_entry(address at, int value);</span><br></pre></td></tr></table></figure><p>最后，发射事件的函数必须被标记处发射了何等事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; @notice emits updated_entry</span><br><span class="line">function update(int value) public &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="基于函数的形式化规约"><a href="#基于函数的形式化规约" class="headerlink" title="基于函数的形式化规约"></a>基于函数的形式化规约</h2><div class="story post-story"><p>基于函数的形式化规约和基于事件的有很多相似之处（<em>并且是南大78004870课程所讲述的模式</em>），只是把修改变量的规约放在函数（与合约、循环）前。并且由于函数可以对值进行修改，而非像事件一样仅展现变化，所以会比基于事件的规约增加其他的东西。请看下例：</p><figure class="highlight js"><figcaption><span>Solidity</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @notice invariant x == y</span></span><br><span class="line">contract Track &#123;</span><br><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @notice precondition x == y</span></span><br><span class="line"><span class="comment">/// @notice postcondition x == (y + n)</span></span><br><span class="line"><span class="comment">/// @notice modifies x</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add_to_x</span>(<span class="params">int n</span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">x = x + n;</span><br><span class="line"><span class="built_in">require</span>(x &gt;= y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @notice modifies x if n &gt; 0</span></span><br><span class="line"><span class="comment">/// @notice modifies y if n &gt; 0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">int n</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line"><span class="built_in">require</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">add_to_x(n);</span><br><span class="line"><span class="comment">/// @notice invariant y&lt;=x</span></span><br><span class="line"><span class="function"><span class="title">while</span>(<span class="params">y &lt; x</span>)</span> &#123;</span><br><span class="line">y = y + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由例子，我们可以总结出基本的语句：</p><ul><li><p>如果某变量没有被改变，那么需要注明<strong>不变式</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invariant &lt;EXPRESSION&gt;</span><br></pre></td></tr></table></figure><p>注意，不变式出现在循环，合约，函数前。</p></li></ul><ul><li><p>如果函数开始前/结束后必须满足某条件，那么需要注明<strong>前置条件</strong>/<strong>后置条件</strong>，与基于事件的一样。</p></li><li><p>如果函数执行改变了状态变量，那么需要注明<strong>修改规约</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modifies &lt;TARGET&gt; [if &lt;CONDITION&gt;]</span><br></pre></td></tr></table></figure></li></ul><h3 id="进阶的规约表达"><a href="#进阶的规约表达" class="headerlink" title="进阶的规约表达"></a>进阶的规约表达</h3><p>课程同时给出了一些进阶的规约表达方式，例如：</p><ul><li><p>聚合计算的表达：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__verifier_sum_&lt;TYPE&gt;( ... )</span><br></pre></td></tr></table></figure><p>所代表了将 <code>&lt;TYPE&gt;</code> 相加所得到的结果。</p></li><li><p>复合数据类型判等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__verifier_eq(..., ...)</span><br></pre></td></tr></table></figure><p>其实就是更加复杂的 <code>x == y</code>。</p></li><li><p>变量旧值引用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__verifier_old_&lt;TYPE&gt;</span><br></pre></td></tr></table></figure><p><em>也许是在循环中引用上一次的值或者引用修改前的值</em>。</p></li><li><p>谓词逻辑表达：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">forall (&lt;VARS&gt;) &lt;QUANTEXPR&gt;</span><br><span class="line"></span><br><span class="line">exists (&lt;VARS&gt;) &lt;QUANTEXPR&gt;</span><br></pre></td></tr></table></figure><p>举例来说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forall (uint λ) !(λ &gt;&#x3D; 0 &amp;&amp; λ &lt; length)</span><br></pre></td></tr></table></figure></li></ul></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="story post-story"><p>形式化规约是一种让程序设计更加严谨的实现，而对于对准确度要求高的智能合约来说更加有用。即使没有检查器，掌握形式化合约也有助于形成良好的变量追踪与查询习惯。</p></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
            <tag> Solidity </tag>
            
            <tag> 智能合约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的以太坊智能合约部署</title>
      <link href="Programming/smart-contract/"/>
      <url>Programming/smart-contract/</url>
      
        <content type="html"><![CDATA[<p>可以简单的把以太坊虚拟机理解为一个公开使用的后端服务器，用户在其上拥有有限的操作空间，每次操作以交易的形式产生，并会根据修改数据的大小向用户收费，称为 <strong>Gas</strong>，以此支持服务器维护人员 (即矿工)。并且，服务器上的数据会被永久记录，操作后端数据的代码 (对于EVM，是 Solidity 代码) 也存放在服务器上不能被修改。</p><p>矿工可以根据 Gas 和数据操作量选择将哪一笔交易加入区块。因此 Solidity 编程要求存储尽量少的数据，节省空间和操作量，以此得到更快速的响应。</p><h2 id="使用-Remix-和-Ganache"><a href="#使用-Remix-和-Ganache" class="headerlink" title="使用 Remix 和 Ganache"></a>使用 Remix 和 Ganache</h2><div class="story post-story"><p><a href="https://remix.ethereum.org/">Remix</a> 是以太坊官方提供的 Solidity 开发环境。在 Remix 内写好代码后可以编译，编译会得到程序的二进制程序接口，称为 ABI。ABI 会提供给 web3.js 来提供操作接口。在编译后可以部署合约，Remix 本身提供了一些 JavaScript 虚拟机来运行智能合约。为了观察到用户和交易的情况，我们可以部署私有链，利用 Ganache。部署后会得到合约地址，你也可以直接在 Remix 和合约交互。</p><p><a href="https://trufflesuite.com/ganache/index.html">Ganache</a> 可以在本地设置好私有区块链，即开即用。用户可以自行设置端口号，而网络ID为5777而区块链ID为1337。在本地部署好之后，使用 MetaMask 钱包添加私有链。MetaMask 也可以使用其他测试链，虽然其他测试链可以有更多的用户，但在这些链上我们难以观察交易情况。添加私有链后，也记得添加私有链的账户。</p><p>说到账户，对于以太坊地址来说，所有链上的地址格式都完全一致。因此，你的任何一个账户都可以在任何链上使用（当然代币不会跟随）。可以尝试把 Ganache 里生成的账户的钱转入一个你主链的地址，操作将会成功且主链地址<strong>在私有链</strong>上的 ETH 会增加。注意 Ganache 不会追踪除了它生成的账户以外的账户（因为无穷多），但是你仍然可以看到 TX 信息，就在 Ganache 的操作面板。这到底是怎么做到的？得益于钱包地址的随机和海量，生成的两个地址相同的概率几乎是不可能的。</p></div><h2 id="Solidity-代码"><a href="#Solidity-代码" class="headerlink" title="Solidity 代码"></a>Solidity 代码</h2><div class="story post-story"><p>设计一个 Solidity 代码，对于每个账户存放一个数据，并且允许用户查看数据。</p><p>(<em>很遗憾，Hexo 对于 Solidity 代码暂时没有语法高亮，我也不想使用 hightlight.js，所以我随便选用了一种代码高亮模式。</em>)</p><figure class="highlight c#"><figcaption><span>Solidity</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明 License</span></span><br><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line"><span class="comment">// 声明编译器版本</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.7</span><span class="number">.0</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合约，就像一个类</span></span><br><span class="line">contract numberHolder &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射数据结构</span></span><br><span class="line">    mapping(address =&gt; uint16) userNumbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个事件</span></span><br><span class="line"><span class="function"><span class="keyword">event</span> <span class="title">numberSetted</span>(<span class="params">address addr,uint16 num</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地址的数据的setter函数</span></span><br><span class="line">    <span class="function">function <span class="title">setNumber</span>(<span class="params">uint16 inputNumber</span>) <span class="keyword">public</span></span>&#123;</span><br><span class="line">        userNumbers[msg.sender] = inputNumber;</span><br><span class="line">        <span class="comment">// 发送事件给前端</span></span><br><span class="line"><span class="function">emit <span class="title">numberSetted</span>(<span class="params">msg.sender, userNumbers[msg.sender]</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个只读函数获得用户地址和数据</span></span><br><span class="line">    <span class="function">function <span class="title">getNumber</span>(<span class="params"></span>) <span class="keyword">public</span> view <span class="title">returns</span> (<span class="params">uint16</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userNumbers[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">getAddress</span>(<span class="params"></span>) <span class="keyword">public</span> view <span class="title">returns</span> (<span class="params">address</span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> msg.sender;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体内容可以查看 Solidity 的<a href="https://solidity-cn.readthedocs.io/zh/develop/">文档</a>。函数发射的事件需要在前端进行监听。关键字 <code>view</code> 代表了这个函数不会操作数据。全局变量 <code>msg</code> 存储了一些当前合约的信息，例如 <code>msg.sender</code> 就是调用合约的地址。</p></div><h2 id="Web-代码"><a href="#Web-代码" class="headerlink" title="Web 代码"></a>Web 代码</h2><div class="story post-story"><p>Web 端我们使用以太坊 JavaScript API和后端交互，叫做 web3.js，使用此库类似于使用 jQuery 的 ajax。实际上，包括部署合约在内的操作都可以用 web3.js 完成，但本次我们不这样做。</p><p>在网页端，首先用简单 HTML 完成界面，给用户提示信息，显示一个可变文本并设置两个按钮：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>数字存放<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    在数据框中输入一个数字并点击上传数据，它将会被存储至区块，请注意这会消耗燃料。<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    点击获得数据将会显示您已经存储的数据，这不会消耗燃料。</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;info&quot;</span>&gt;</span>等待输入<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;data&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-2 control-label&quot;</span>&gt;</span>您的数据<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;data&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button_update&quot;</span>&gt;</span>上传数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button_download&quot;</span>&gt;</span>获得数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来在 <code>&lt;script&gt;</code> 部分设计网页的逻辑。别忘记把 web3.js 和 jQuery 加入到网页中。首先配置好我们的 web3 库：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    web3 = <span class="keyword">new</span> Web3(web3.currentProvider);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">&quot;http://localhost:8545&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这声明了，我们的 web3 是由 HTTP 在本地8545端口提供，也就是我们的 Ganache。接下来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.defaultAccount = web3.eth.accounts[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> contractABI = web3.eth.contract(<span class="comment">/* ABI Here */</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myContract = contractABI.at(<span class="string">&#x27;0x6f0D3623...&#x27;</span>)</span><br></pre></td></tr></table></figure><p>第一行代码说明了我们默认交互账户是 Ganache 里的第一个账户。我们现在还不将 MetaMask 链接功能提供在前端。MetaMask 要求前端网页不能是本地打开的，必须运行在一个服务器上 (Python 搭建的简易 HTTP 服务器就可以)，并且需要更复杂且完善的代码。第二行代码需要我们写入之前在 Remix 得到的 ABI，这是我们交互的基础。第三行就是合约本身，从语义上可以理解为：某个 ABI 位于某个确定的地址上。这个地址可以在 Remix 处看到，或在 Ganache 的 TX 信息里找到。</p><p>接下来我们来看一下在前端如何调用 Solidity 函数，并用 jQuery 改变前端显示。首先演示一下按钮如何获得数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#button_update&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">myContract.setNumber($(<span class="string">&quot;#data&quot;</span>).val());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;#button_download&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#info&quot;</span>).html(<span class="string">&#x27;您的地址：&#x27;</span> + myContract.getAddress.call() + <span class="string">&#x27;&lt;br&gt;&#x27;</span> + <span class="string">&#x27;您存储的数字：&#x27;</span> + myContract.getNumber.call() + <span class="string">&#x27;&lt;br&gt; 操作：读取数字&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对于 jQuery，简单的语法是利用 <code>$(&quot;#id&quot;)</code> 选中 HTML 对应 ID 的内容，在此是按钮类型。按钮类型具有 <code>click()</code> 方法，我们在内部写出一个函数，意思是“如果按钮被按下，那么执行这个函数，函数的内容是使用合约内的 setNumber() 函数，函数的参数是 HTML 中 ID 为 data 的元素的值”。对于下面获得值的操作，同理。 </p><p>再来看看怎么监听我们发出的事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eventSet = myContract.numberSetted()</span><br><span class="line">eventSet.watch(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">!error</span>)</span> &#123;</span><br><span class="line">        $(<span class="string">&quot;#info&quot;</span>).html(<span class="string">&#x27;您的地址：&#x27;</span> + result.args.addr + <span class="string">&#x27;&lt;br&gt;&#x27;</span> + <span class="string">&#x27;您存储的数字：&#x27;</span> + result.args.num</span><br><span class="line">        + <span class="string">&#x27;&lt;br&gt;&#x27;</span> + <span class="string">&#x27;操作：设置数字&#x27;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>基本原理同以上相同，我们将合约的 numberSetted 事件声明成一个变量，对这个变量进行 watch() 方法。里面的函数和刚才的差不多，它具有了两个参数。因为 web3 要求我们进行异常处理，即需要有 <code>if(!error) &#123;&#125; elese &#123;&#125;</code> 的形式。另一个参数 <code>result</code> 里面包含了我们在 Solidity 中写过的两个返回值。如果不太明白，可以在浏览器打开控制台观察一下 <code>log</code>，会完整展现 <code>result</code> 的结构。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://s2.loli.net/2022/03/29/9HjxGlDdiQqRuUv.png" class="lazyload" data-srcset="https://s2.loli.net/2022/03/29/9HjxGlDdiQqRuUv.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="网页的样子"></div><span class="image-caption">网页的样子</span></div></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="story post-story"><p>目前我们的前端已经可以在本地运行了。不过像这样直接链接私有链，利用索引选择调用合约的用户以及函数的处理方式都非常原始，只能作演示用。之后会尽量设计更完善的代码。</p></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
            <tag> Solidity </tag>
            
            <tag> 智能合约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题记录 - 键盘测试</title>
      <link href="Note/algorithm-0/"/>
      <url>Note/algorithm-0/</url>
      
        <content type="html"><![CDATA[<p>羊羊买了新键盘，并邀请大家来试用键盘，但前提是回答出以下问题。</p><blockquote><p>您将获得两个字符串s和t，两者都由小写的英文字母组成。您将逐个字符地键入字符串s，从第一个字符到最后一个字符。</p><p>特别之处在于，键入字符时，您可以按<code>Backspace</code>按钮，而不是按与之对应的按钮。<code>Backspace</code>会删除您刚刚键入的最后一个字符（如果您键入的字符串中没有字符，则不执行任何操作）。例如，如果s是”abcbd”，并且您按<code>Backspace</code>而不是键入第一个和第四个字符，您将获得字符串”bd”（第一次按<code>Backspace</code>不删除任何字符，第二次按删除字符”c”）。另一个例子，如果s是”abcaa”，并且您用<code>Backspace</code>键代替最后两个字母，则得到的文本为”a”。</p><p>您的任务是确定是否可以通过以上方式，从字符串s获取字符串t.</p></blockquote><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><div class="story post-story"><p>第一行是一个整数 q (1≤q≤10^5），代表测试用例的数量。<br>每个测试用例的第一行是字符串s (1≤s的长度≤10^5)，s中的每个字符是小写的英文字母。<br>每个测试用例的第二行是字符串t (1≤t的长度≤10^5)，t中的每个字符是小写的英文字母。</p><p>对于每个测试用例，如果可以按本题的方式从s得到t，请打印”YES“,否则，打印“NO”。</p><figure class="highlight text"><figcaption><span>Input</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">ababa</span><br><span class="line">ba</span><br><span class="line">ababa</span><br><span class="line">bb</span><br><span class="line">aaa</span><br><span class="line">aaaa</span><br><span class="line">aababa</span><br><span class="line">ababa</span><br></pre></td></tr></table></figure><figure class="highlight text"><figcaption><span>Output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure></div><h2 id="初始想法"><a href="#初始想法" class="headerlink" title="初始想法"></a>初始想法</h2><div class="story post-story"><p>看到题目首先观察了 s 和 t 的联系。首先的想法如下：</p><ul><li>对于 s，首先寻找其中所包含的第一个 t[0]。如果没有 t[0]，那么肯定无法输出。</li><li>如果有 t[0]，接着去找 t[1]，看看两个字母之间的字母数是不是偶数个（打出，删除，打出，删除…）。如果不是，那么肯定无法输出。</li><li>如果还是，那么继续重复以上的步骤，直到 t 越界。</li></ul><p>遇到的问题：</p><ul><li>aababa 和 ababa 无法处理。说明如果 s 存在 t[0]，但完全无效，则应该去除 s 中 t[0] 即其之前的部分，重新进行测试。但是此方法只适用于 t[0]，因为实际上在符合要求的 t[0] 于 s 中出现之前，用户可以什么都不输入只按退格键。并且，这样的方法对于大数据来说太慢了。</li><li>本身的算法就非常难设计，需要三个指针，两个位于 s 标定位置，一个位于 t 指向当前的内容。</li></ul></div><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><div class="story post-story"><p>反向思考，如果说开头的东西可以忽视会让人难以处理，那么把开头放在最后就好了。同时，我们知道符合要求的字符串 s 的尾部要么和 t 完全一致，要么最后相差偶数个。所以最终的设计是，从 s 和 t 的尾部开始遍历，如果相同就同时前进 1 个字母，再比较；如果不同，则 s 前进2 个字母，再比较。直到 s 或 t 某个字符串结束。最后再判断 t 有没有结束。如果 t 结束了，那么答案就是 YES，此时 s 最开始的部分就是那些我们可以只按退格键的字符。</p><p>Python 代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">special_typing</span>():</span></span><br><span class="line">    stringNum = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(stringNum != <span class="number">0</span>):</span><br><span class="line">        stringS = <span class="built_in">list</span>(<span class="built_in">input</span>())</span><br><span class="line">        stringT = <span class="built_in">list</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">        comparePointer = <span class="built_in">len</span>(stringS) - <span class="number">1</span></span><br><span class="line">        current = <span class="built_in">len</span>(stringT) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(current &gt;= <span class="number">0</span>) <span class="keyword">and</span> (comparePointer &gt;= <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">if</span>(stringT[current] == stringS[comparePointer]):</span><br><span class="line">                current -= <span class="number">1</span></span><br><span class="line">                comparePointer -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                comparePointer -= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(current &lt; <span class="number">0</span>):</span><br><span class="line">            print(<span class="string">&quot;YES&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;NO&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        stringNum -= <span class="number">1</span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式：基本思想与策略模式</title>
      <link href="Programming/design-pattern-0/"/>
      <url>Programming/design-pattern-0/</url>
      
        <content type="html"><![CDATA[<p>知道继承，接口，多态和虚类不能让你学会面向对象程序设计。理解<strong>设计模式</strong>，因为设计模式是面向对象开发工程师们多年以来程序设计的经验总结，是为了解决问题而产生的历经验证的工程通用解决方案。良好的设计模式会包含可复用，可扩充，可维护三个特性，而模式可以帮我们做到这点。</p><p>首先来举个简单的例子，来展示继承所不能解决的问题。如图，某游戏公司程序员为自己游戏的职业系统设计了一个 Player 超类，所有的职业都会继承这个超类。在继承时，也会继承超类内所有的方法。如果需要新的职业，那么我们就添加一个新的类。完美！</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://s2.loli.net/2022/03/28/RJelt4WkrKUqCE8.png" class="lazyload" data-srcset="https://s2.loli.net/2022/03/28/RJelt4WkrKUqCE8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="美丽的UML图"></div><span class="image-caption">美丽的UML图</span></div><p>现在公司抛出了新的需求：要求玩家应该会闪避。这很好办，只需要在超类里加入一个 dodge() 方法即可。但是在测试的时候发现了新的问题：牧师会闪避导致了他过于强大的生存能力，以至于不需要队友保护他。这和游戏的设计理念不太符合，公司要求程序员让牧师不再会闪避。这也很简单，把 Priest 的 dodge() 方法的具体实现覆盖成什么都不做就可以了。到目前为止，一切都很好…</p><p>直到程序员意识到，公司为了赚钱每个月都会推出一款新职业，他们有的专注攻击不能防御，有的利用防御来攻击，有的……噢还有，公司还会推出氪金装备，使得 Priest 可以有限次的进行闪避动作。天啊，这要怎么办？来看看我们从最初的设计原则可以推出什么。</p><h2 id="变与不变"><a href="#变与不变" class="headerlink" title="变与不变"></a>变与不变</h2><div class="story post-story"><p>应用设计的第一个原则：<strong>找出应用中需要变化之处，将其独立，不要和不需要变化的代码写在一起</strong>。这样，每次新的需求来到，我们就可以不修改固定的部分，只修改变化的部分。</p><p>对于我们的游戏设计来说，我们知道 dodge() 是会随着职业的不同而改变的（<em>当然 attack() 和 defense() 也会变，但是原理是一样的</em> ）。那么我们把闪避行为拿出来，并为它创建一个类。<strong>所有的职业都将 HAS-A 闪避行为。</strong></p></div><h2 id="为谁而写"><a href="#为谁而写" class="headerlink" title="为谁而写"></a>为谁而写</h2><div class="story post-story"><p>应用设计的第二个原则：<strong>针对接口编程，不要针对实现编程</strong>。 说真的，我觉得这句话刚一看到非常难理解。</p><p>什么是实现？职业类如果实现了 dodge() 接口，那么就意味着所有职业都要实现这个接口，因为他们都继承自原始的超类。我们不要把什么类能实现什么在最开始的时候写死。</p><p>怎么针对接口编程？我设计一个 DodgeBehaviour 接口，此接口有 dodge() 方法。现在，我们让具体的类实现这个接口。DodgeNormal 类会正常的躲避，而 DodgeNaught 类什么都不做。现在，闪避行为和 Player 类没有任何关系了。我们可以随意添加闪避行为或者修改行为，比如我们为法师设计一个 DodgeKUXUAN，让闪避的时候会增加粒子效果。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://s2.loli.net/2022/03/28/NQL4YrXentSp9gx.png" class="lazyload" data-srcset="https://s2.loli.net/2022/03/28/NQL4YrXentSp9gx.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="另一个美丽的UML图"></div><span class="image-caption">另一个美丽的UML图</span></div></div><h2 id="完成设计"><a href="#完成设计" class="headerlink" title="完成设计"></a>完成设计</h2><div class="story post-story"><p>现在事情可能会变得有点奇怪，我们如何让某个职业进行闪避？请看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">  healthType Health;</span><br><span class="line">  DodgeBehaviour dodgeBehaviour;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performDodge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dodgeBehaviour.dodge();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们的超类。看，我们通过让职业 HAS-A 行为的方式成功地托管了闪避行为！这也就引出了我们的第三个设计原则：<strong>多用组合，少用继承</strong>。HAS-A is better than IS-A!</p><p>那么相对应的，子类的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Priest</span> <span class="keyword">extends</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Priest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dodgeBehaviour = <span class="keyword">new</span> DodgeNaught();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数里面，我们写好 Priest 会使用哪种 实现了 DodgeBahaviour 的类。不仅如此，如果我们对 dodgeBehaviour 设定一个 setter 函数，我们就可以在程序运行时改变牧师躲避的行为，比如牧师装备了氪金道具，那么就将 dodgeBehaviour 设定成可以闪避并计数，结束后改回去。这比写一个 ”可以进行10次闪避” 的 Priest 职业好太多了！</p><p>同理，攻击和防御方法都可以用相同的方式实现。以上的设计模式我们称为<strong>策略模式</strong>。策略模式<strong>定义且封装了独立于使用算法客户的算法族，使他们相互之间能够替换</strong>。这也不意味着继承方法真的没用了，比如所有的职业都需要走路，那么 walk() 方法就可以继承。关键点是确立好需求，并选择你需要的设计模式。</p><p>（<em>所以，这位程序员该好好跟他的产品经理吵一架 :P</em> ）</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="story post-story"><p>来看看我们目前学到的东西：</p><ul><li><strong>设计原则一：找出应用中需要变化之处，将其独立，不要和不需要变化的代码写在一起。</strong></li><li><strong>设计原则二：针对接口编程，不要针对实现编程。</strong> </li><li><strong>设计原则三：多用组合，少用继承。</strong></li><li><strong>策略模式：定义且封装了独立于使用算法客户的算法族，使他们相互之间能够替换。</strong></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重新记录我的博客</title>
      <link href="Thoughts/init_post/"/>
      <url>Thoughts/init_post/</url>
      
        <content type="html"><![CDATA[<p>两年前，我抱着玩玩的心态在 Github 上部署了一个小博客。然而搜肠刮肚发现自己既没技术，又没文笔，无甚可写，遂作罢。<br>近日和舍友闲谈，偶然间舍友提到了博客。突然想起了自己曾经弄的小站。再联想到自己最近需要学习，记忆力又狠狠衰退，于是打算把博客重拾起来。<br>为了避免自己又忘记什么重要的事，我把操作博客的方法都写下来。</p><h3 id="写作与更新"><a href="#写作与更新" class="headerlink" title="写作与更新"></a>写作与更新</h3><p>在部署时我就选择了 Hexo 托管页面。Hexo 是一个 Node.js 包，它能够自动生成网页，用户所需要做的只是写作。并且，它支持各种插件与主题。<br>使用如下代码在 <code>/source/_posts/</code> 内新建一个文件夹与 markdown 文件，名字为<code>name.md</code>。<code>name</code>也将组成这篇博客的 url 路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new name</span><br></pre></td></tr></table></figure><p>设置好以后，可以在本地<code>5000</code>端口部署测试页面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>待测试没问题后，push 到 Github 吧：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><p>等待几分钟就可以看到结果。</p><h3 id="配置和优化"><a href="#配置和优化" class="headerlink" title="配置和优化"></a>配置和优化</h3><p>关于配置，可以在 <a href="https://volantis.js.org/v5/getting-started/">Volantis 文档</a>内找到所有需要的内容，包括底栏侧栏导航栏配置等等。<br>对于 Post 的封面，我使用 <a href="https://www.canvas.cn/">Canvas 可画</a>来制作，按照微信公众号的标题随便做一个即可。<br>对于在文章内插图，我使用 <a href="https://sm.ms/">SM.MS</a> 图床。</p><h3 id="承诺"><a href="#承诺" class="headerlink" title="承诺"></a>承诺</h3><p>即使发一些毫无意义的 shitpost，我也尽量不会让博客停下来。拖延和懒惰的一部分来自于追求完美，会希望把事情做的足够好的想法，会导致人过分注重细枝末节而最后放弃。</p>]]></content>
      
      
      <categories>
          
          <category> Thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 想法 </tag>
            
            <tag> 记录 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
