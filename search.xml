<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在macOS上进行Verilog HDL设计</title>
      <link href="%E6%95%99%E7%A8%8B/verilog-design-on-macos/"/>
      <url>%E6%95%99%E7%A8%8B/verilog-design-on-macos/</url>
      
        <content type="html"><![CDATA[<p>每当我回想起电路分析实验与模拟电路实验开课的那段时光，总不能忘记的是让电脑轰鸣发热的 VMware Fusion。即使是最简单的模拟电路仿真，也需要像 Multisim 这样功能无比强大的仿真软件。这样一个拥有庞大数据体量的软件只支持 Windows 似乎也是情理之中的。  </p><p>但对于Verilog HDL这样的硬件描述语言，<strong>如果只是简单的电路</strong>，我们就不再需要动辄十几兆字节的 Vivado 或者 Quartus，配置好编译软件和波形查看软件，我们就可以愉快的进行练习了。  </p><p><strong><em>(推荐在使用之前在 App Store 安装 Xcode 以免缺失依赖)</em></strong></p><hr><h2 id="包管理器-Homebrew"><a href="#包管理器-Homebrew" class="headerlink" title="包管理器 Homebrew"></a>包管理器 Homebrew</h2><p>首先之首先，我们需要 macOS 上必备的包管理器 Homebrew。</p><p>我曾经在<a href="https://sheepo.top/%E6%95%99%E7%A8%8B/build-your-own-blog-pt1/">如何搭建自己的博客(Part1)</a>里提过一句 Homebrew，而这里我想我可以展开说说。<br>如果你曾用过 Linux，你会明白 Homebrew 只是热心开发者为了弥补 macOS 作为类Unix系统而没有包管理器的遗憾而诞生的产物，它的名字“家酿”可能也在暗示它的民间出身而非官方应用。<br>而如果你只是普通用户，你可以将 Homebrew 认为是命令行版本的 App Store。通过 Homebrew 你可以安装许多软件，只需要输入一行命令并坐和放宽。</p><p>举个例子，Python 是 macOS 自带的应用，但默认是 2.7 版本（至少我拿到的 Mojave 是这样的）。如果想要安装 Python3，只需要在命令行输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">→ brew install Python</span><br></pre></td></tr></table></figure><p>再比如说，我想要下载火狐浏览器。除了按照官方的方式下载并且将App拖入到应用程序内这种方法外，你还可以直接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">→ brew cask install firefox</span><br></pre></td></tr></table></figure><p><em>(当然前提是 cask 内要有这个包)</em></p><p>要安装 Homebrew 也很简单，首先打开 <a href="https://brew.sh/">Homebrew官方网站</a>，按照教程进行即可。但一般国内网络环境较慢，推荐按照<a href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/">清华镜像站</a>的教程去做。</p><p>这就结束了对 Homebrew 的说明。</p><h2 id="编译软件-Icarus-Verilog"><a href="#编译软件-Icarus-Verilog" class="headerlink" title="编译软件 Icarus Verilog"></a>编译软件 Icarus Verilog</h2><p>哇，这可是个什么东西？<br>赶紧打开官网查看一下。</p><blockquote><p><em>伊卡洛斯Verilog</em>是一款 Verilog 模拟综合工具。它作为编译软件工作，将以 Verilog (IEEE-1364) 代码编写的源码编译为某种目标格式。<br>对于批量模拟，它可以生成一种叫做 “vvp 程序集” 的中间级形式。这个程序集可以用 “vvp” 指令执行。<br>对于综合，该编译器可以依照需要的风格生成网表。</p><p>(翻译自 Icarus Verilog 官网)</p></blockquote><p>你可以看出，iverilog 可以将许多 .v 源文件编译成一个某类型的可执行文件，再使用 vvp 命令执行它。<br>它可以输出波形，甚至可以生成门级电路网表（关于生成 Netlist，我仍在研究），并且它是一个可以运行在 macOS 上的开源软件。</p><p>安装它的方式很简单，只需要应用刚刚的 Homebrew 知识：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">→ brew install icarus-verilog</span><br></pre></td></tr></table></figure><p>这就结束了对 Icarus Verilog的说明。</p><h2 id="代码编辑器-VSCode"><a href="#代码编辑器-VSCode" class="headerlink" title="代码编辑器 VSCode"></a>代码编辑器 VSCode</h2><p>VSCode，强大的文本编辑器。<br>如果你曾经在 Windows 用过记事本应用程序，那么你就不必担心 VSCode，因为它本质上是一个超究极进化版的记事本。<br>下载也非常简单，直接打开<a href="https://code.visualstudio.com/">官网</a>下载即可。</p><p>下载完成后，点击左边的拓展页面搜索 Verilog，按图安装插件。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://cdn.jsdelivr.net/gh/n1vk/img@v1.5/inpassage/verilog/1.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/n1vk/img@v1.5/inpassage/verilog/1.png" srcset="data:image/png;base64,666" alt="和红框内名字相同"></div><span class="image-caption">和红框内名字相同</span></div><p>这个插件将对你的代码实现语法高亮，纠错等等。</p><p>安装好后，按下<kbd>⌘</kbd> + <kbd> , </kbd>打开 VSCode 的配置页面，搜索 Verilog，将 Verilog 的 Linter 更改为 iverilog。这样在编写代码的时候可以看出自己的语法错误，对于初学者来说比较方便。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://cdn.jsdelivr.net/gh/n1vk/img@v1.5/inpassage/verilog/2.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/n1vk/img@v1.5/inpassage/verilog/2.png" srcset="data:image/png;base64,666" alt="如图红框所示选项"></div><span class="image-caption">如图红框所示选项</span></div><p><strong>但注意这个 Linter 的工作有些异常，在多文件编译的时候它将会提示你无法找到另外一个文件内的 module，但编译仍可以正常进行。此时，请无视报错</strong></p><p><em>VSCode 不是强制性的。如果你更喜欢自己的文本编译器，更换是没有问题的。</em><br>这就结束了对VSCode的说明。</p><h2 id="仿真波形软件-Scansion"><a href="#仿真波形软件-Scansion" class="headerlink" title="仿真波形软件 Scansion"></a>仿真波形软件 Scansion</h2><p>Scansion 的软件说明非常有意思：</p><blockquote><p>Scansion 为广大疲惫于每次分析波形时都要打开 Linux 虚拟机或者用 X11 做出来的应用的那些 Mac 用户带来一丝解脱。</p></blockquote><p>让我们把掌声送给开发出这款 Free For All 波形显示软件的 Jeff Wilcox。</p><p>请前去它的<a href="http://www.logicpoet.com/scansion/">官网</a>下载，拖入应用程序栏内，留作备用。<br>它的作用是帮助我们查看 vvp 命令后生成的 .vcd 文件。</p><p>这就结束了对 Scansion 的说明。</p><h2 id="编写与编译-Verilog-文件"><a href="#编写与编译-Verilog-文件" class="headerlink" title="编写与编译 Verilog 文件"></a>编写与编译 Verilog 文件</h2><p>终于到了编写 Verilog 代码的时候了！我们以 <em>《数字逻辑基础与 Verilog 设计》</em> 这本书上的代码为例子，看看我们刚刚得到的那些东西是如何工作的。</p><p>打开 VSCode 并新建一个 Verilog 文件夹，在里面创建 Full_Adder 文件夹并进入。在 Full_Adder 文件夹内，我们创建我们要编写的源码文件 Full_Adder.v，并在里面写入：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fulladd(Cin, x, y, s, Cout);</span><br><span class="line">    <span class="keyword">input</span> Cin, x, y;</span><br><span class="line">    <span class="keyword">output</span> s, Cout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">xor</span>(s, x, y, Cin);</span><br><span class="line">    <span class="keyword">and</span>(z1, x, y);</span><br><span class="line">    <span class="keyword">and</span>(z2, x, Cin);</span><br><span class="line">    <span class="keyword">and</span>(z3, y, Cin);</span><br><span class="line">    <span class="keyword">or</span>(Cout, z1, z2, z3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>并按下<kbd>⌘</kbd> + <kbd>S</kbd>保存文件。</p><p>按下<kbd>⌃</kbd> + <kbd> ` </kbd>打开终端，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">→ <span class="built_in">cd</span> Full_Adder/</span><br><span class="line">→ iverilog iverilog -o Full_Adder.out Full_Adder.v</span><br></pre></td></tr></table></figure><p>你会发现文件夹里多出了一个 Full_Adder.out 文件（ -o 参数声明了输出文件的名字）。还记得我们之前提到的中间文件吗？就是它！<br>我们激动的运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">→ vvp Full_Adder.out</span><br></pre></td></tr></table></figure><p>……这行命令就像鲤鱼王的水溅跃，使用过后什么也没有发生。<br>问题出在哪里呢？我们观察我们所写的文件，它只是对一个 module 进行了描述。而要观察它将对输入做出什么样的响应，我们需要再编写一个 Testbench 文件，声明对他的输入并输出响应的波形。</p><h2 id="编写-Testbench-文件"><a href="#编写-Testbench-文件" class="headerlink" title="编写 Testbench 文件"></a>编写 Testbench 文件</h2><p>根据网上的教程，我们在 Full_Adder.v 的同目录创建 Full_Adder_tb.v，并写入：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> Full_Adder_tb;</span><br><span class="line">    <span class="comment">// Testbench module 不需要参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将待测试模块的输入声明为reg类型，输出为wire类型</span></span><br><span class="line">    <span class="keyword">reg</span> Cin, x, y;</span><br><span class="line">    <span class="keyword">wire</span> s, Cout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化待测试模块</span></span><br><span class="line">    <span class="comment">// 如果你将 Linter 设置为 iverilog，这行将会报错。忽视它！</span></span><br><span class="line">    fulladd test(<span class="variable">.Cin</span>(Cin), <span class="variable">.x</span>(x), <span class="variable">.y</span>(y), <span class="variable">.s</span>(s), <span class="variable">.Cout</span>(Cout));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #10 代表延迟10秒</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        Cin = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">10</span> x = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">10</span> y = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">10</span> x = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">10</span> y = <span class="number">0</span>; Cin = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">10</span> x = <span class="number">1</span>; Cin = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">10</span> y = <span class="number">1</span>; Cin = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">10</span> x = <span class="number">0</span>; Cin = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span>            </span><br><span class="line">    <span class="built_in">$dumpfile</span>(<span class="string">&quot;Full_Adder_tb.vcd&quot;</span>);         <span class="comment">//生成的vcd文件名</span></span><br><span class="line">    <span class="built_in">$dumpvars</span>(<span class="number">0</span>, Full_Adder_tb);            <span class="comment">//tb模块名</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>同样的保存之后，我们在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">→ iverilog -o Full_Adder.out Full_Adder.v Full_Adder_tb.v </span><br><span class="line">→ vvp Full_Adder.out</span><br></pre></td></tr></table></figure><p>你会惊奇地发现，终端返回了这样一句话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VCD info: dumpfile Full_Adder_tb.vcd opened for output.</span><br></pre></td></tr></table></figure><p>马上就要成功了！在终端输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -a Scansion Full_Adder_tb.vcd</span><br></pre></td></tr></table></figure><p>你会发现 Scansion 被打开了。按图片步骤操作：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://cdn.jsdelivr.net/gh/n1vk/img@v1.5/inpassage/verilog/3.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/n1vk/img@v1.5/inpassage/verilog/3.png" srcset="data:image/png;base64,666" alt="一点这，二点那"></div><span class="image-caption">一点这，二点那</span></div><p>就可以得到仿真波形了！随意选择一列验证，你会发现这就是全加器的输出波形。</p><p>由此，其他的 Verilog 仿真也就可以按照这种方式进行啦。这篇关于 macOS 上 Verilog 设计的文章也就到这里了。</p><hr><p><em>在写这篇文章的时候，我注意到了Icarus Verilog具有生成网表的功能。但这似乎是基于所谓RTL级描述的内容。</em><br><em>等我对数字系统的理解更加深入之后，我也许会更新这篇文章。欢迎所有读者勘误！</em></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Verilog </tag>
            
            <tag> macOS </tag>
            
            <tag> 数字电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>亲手搭建自己的博客网站，从无到无穷 (Part 1)</title>
      <link href="%E6%95%99%E7%A8%8B/build-your-own-blog-pt1/"/>
      <url>%E6%95%99%E7%A8%8B/build-your-own-blog-pt1/</url>
      
        <content type="html"><![CDATA[<p>感谢你阅读这行文字！  </p><p>因为这正代表着我的网页搭建成功，工作正常，<del>甚至还有些好看</del>。而这距离一个仅有着 404 的空白页面只不到三天时间。如果你也有兴趣创建一个属于你自己的网站，那么这篇文章会以纯粹萌新的视角带你一起探索搭建它的方法。  </p><p><strong><em>本文适用于 macOS 系统</em></strong></p><hr><h2 id="了解-Github-Pages"><a href="#了解-Github-Pages" class="headerlink" title="了解 Github Pages"></a>了解 Github Pages</h2><p>Github Pages 是 Github 造福广大人民群众而推出的一款静态页面托管服务，优点如下：</p><ul><li>它完全免费，不需要花钱租借服务器，只需要在 Github 注册账号；</li><li>它功能强大，有了大佬完成的主题，你完全无需了解任何网页前端知识就可以将自己的博客变的无比漂亮；</li><li>它省心省力，对萌新友好，有了 Hexo 这样的配置服务，甚至不用了解 Git 的用法，你所需要做的只是写博客而已；</li><li>(…)</li></ul><p>总而言之，Github Pages益处多多，如果你和我一样只是想保存无处安放的想法，GP 就是你的不二之选。<br>但在开始之前，让我先解释一下前面出现的词语们。</p><p><em>(以下一小栏的内容看不懂也没关系)</em></p><h3 id="什么是-Git？"><a href="#什么是-Git？" class="headerlink" title="什么是 Git？"></a>什么是 Git？</h3><p>我们先来看看 Git 的官网对于 Git 的定义：</p><blockquote><p>Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.</p><p>Git is easy to learn and has a tiny footprint with lightning fast performance. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like cheap local branching, convenient staging areas, and multiple workflows.</p></blockquote><p>….完全没看懂呢！<br>简而言之，Git 是一个<em>分布式版本控制系统</em>。当你对文件作出一些更改的时候，Git 可以将不同版本的文件进行保留，并且记录下每次都改变了什么。同时，Git 可以把文件创立很多<em>分支</em>让许多人一起编辑文件，并通过<em>互联网服务器</em>对文件的改动进行管理，最后得到成品文件。</p><p>在维护自己的博客时，我们仅仅会用到非常简单的、甚至是基本没有 Git 指令。所以你不必在此过多纠结。但如果你感兴趣的话，可以在<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的Git教程</a>里了解更多。我也会在下面列出一些常见的代码。</p><p>macOS 自带 Git。打开”终端.app”，输入 git 并按下回车，就可以看到 git 显示的帮助信息。</p><h3 id="什么是-Github？"><a href="#什么是-Github？" class="headerlink" title="什么是 Github？"></a>什么是 Github？</h3><p>在上面我们曾经提到，我们会通过<em>服务器</em>对文件的改动进行管理。那么 Github 就是一个这样的服务器，我们可以将内容保存在 Github 上，并在本地通过 Git 命令对文件进行管理。如果我们<strong>抛弃所有的软件开发，版本迭代，多人协同工作或者是问题讨论</strong>的功能不谈，只对文件进行<strong>在一个分支内</strong>的不停修改，你甚至可以将 Github 看作是用 Git 管理的一个网盘。理论上，你可以上传所有文件到 Github 供大家查阅或下载。</p><p>而实际上，很多人会通过这种方式分享文件，例如我校一位<a href="https://github.com/idealclover">大佬学长翠翠</a>创建的<a href="https://github.com/idealclover/NJU-Review-Materials">复习资料库</a>（不过他已经毕业，这份资料库也不太再维护了），就是一个很好的例子。</p><p>我们拿翠翠的复习资料库做一个简单例子，每一个 Github 代码库称为 Repository。顶端 Code 栏目里保存了项目的代码，也就是文件。Issues 栏目里是对于该项目的问题或讨论，所有人都可以在此留言并讨论。其他的栏目和按钮我们暂时先不考虑。</p><p>有样学样，想象一下你有一堆文件，你希望将它们托管在<strong>Github 服务器</strong>上。为什么要考虑这样一个需求呢？因为静态网页实际上也是由很多很多 HTML 文件组成，如果我们可以将 HTML 文件全部托管在 Github 上，那么 Github 只需要推出一个小功能，将 HTML 文件内容显示出来，每个人就可以创建他们自己的网页了。我对 Github Pages的理解就是如此。那么，我们需要怎样实现呢？</p><hr><h4 id="i-创建你的-Github-账户和-Repository"><a href="#i-创建你的-Github-账户和-Repository" class="headerlink" title="i. 创建你的 Github 账户和 Repository"></a>i. 创建你的 Github 账户和 Repository</h4><p>在一切开始之前，先去 Github 注册账户吧。请谨慎选择你的用户名，它将不可修改并且显示在各种地方，下文我将用”your_id”指代。<br>注册后找到 “Create a new repo”，在 Repository Name 里填写你的 Repo 名，下文我将用”your_repo”指代。<br>勾选创建 README.md 的选项，这样仓库中将默认含有一个 README.md。这个文件的内容会显示在你的 Repo 页面中。</p><h4 id="0-初始化-Git-管理文件夹"><a href="#0-初始化-Git-管理文件夹" class="headerlink" title="0. 初始化 Git 管理文件夹"></a>0. 初始化 Git 管理文件夹</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">→ mkdir ~/Folder</span><br><span class="line">→ <span class="built_in">cd</span> ~/Folder</span><br><span class="line">→ git init</span><br></pre></td></tr></table></figure><p>这个操作将会将 Folder 文件夹记录为用 Git 管理。如果你是 macOS/Linux 用户且开启了隐藏文件夹显示，你将会看到目录内出现了 .git 文件夹，这标志着这个文件夹由 Git 进行版本控制。<br><strong>但一般的，我们不会用到这些命令。</strong>因为从 Github 下载库的时候 .git 文件夹将会自动创建，下载内容将会被自动表示为由 Git 管理，用户不再需要手动进行初始化。<br>当然，你也可以选择手动创建库，再如下将它与 Github 库链接起来，但<strong>本栏目的内容我都不推荐</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">→ git remote add origin git@github.com:your_id/your_repo.git</span><br></pre></td></tr></table></figure><h4 id="1-从-Github-下载-Repo"><a href="#1-从-Github-下载-Repo" class="headerlink" title="1. 从 Github 下载 Repo"></a>1. 从 Github 下载 Repo</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">→ git <span class="built_in">clone</span> git@github.com:your_id/your_repo.git</span><br></pre></td></tr></table></figure><p>这将会把 Github 上创建好的 Repo 直接下载到本地，自带 .git 文件夹，很省心吧！<strong>我推荐这种做法</strong>。</p><h4 id="2-将文件保存到待提交区"><a href="#2-将文件保存到待提交区" class="headerlink" title="2. 将文件保存到待提交区"></a>2. 将文件保存到待提交区</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">→ <span class="built_in">cd</span> your_repo</span><br><span class="line">→ (创建文件，修改...)</span><br><span class="line">→ git add file</span><br></pre></td></tr></table></figure><p>首先进入 your_repo 文件夹，做出一番修改后（你可以随意做些什么，比如创建一个 .txt 文件并写上 Hello World），add 命令将会把 file 文件保存在待提交区。<br>如果你想囊括全部文件，可以像这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">→ git add --all</span><br></pre></td></tr></table></figure><h4 id="3-提交文件"><a href="#3-提交文件" class="headerlink" title="3. 提交文件"></a>3. 提交文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">→ git commit -m <span class="string">&quot;message&quot;</span></span><br></pre></td></tr></table></figure><p>这个操作将会把你之前囊括的文件一并提交，创建新的版本。<br>其中 “-m” 是一个参数，表示对本次提交的文件添加描述，后面的 “message” 即为描述的内容，你可以随意更改。</p><h4 id="4-上传到-Github"><a href="#4-上传到-Github" class="headerlink" title="4. 上传到 Github"></a>4. 上传到 Github</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">→ git push </span><br></pre></td></tr></table></figure><p>我们刚刚的一切操作都是在本地完成。是时候交给 Github 了！<br>输入这行命令后，之前 commit 的文件内容全部会被 push 到 Github 上。待执行完毕后，你可以去你的 Github 页面刷新查看。</p><p>这样，我们就完成了对 Github 如何保存管理文件的体验。</p><hr><p>下面，我们也可以顺便了解一下 Github 不同于网盘的强大功能。</p><p>在 Repo 页面的 Pull Request 栏目保存了其他人对 Repo 的主人提出增加文件申请的记录。<br>如果你想要对这个复习资料库进行修改添加，首先你需要点击 Fork 按钮，也就是相当于将原 Repo 拷贝至你的账户。接下来你需要将复制的 Repo 从 Github 的服务器 Clone 到本地，注意此时 Repo 的名字不变，但用户 ID 已经变成你的了。做出一番修改后，你可以 commmit 并 push 回服务器。再回到原仓库界面，点击发起新的 Pull Request，在原 Repo 主人 review 之后，就可以选择是否要将你的改动 merge 到原仓库内，这样就实现了多人协同开发。</p><h3 id="怎样使用-Github-Pages？"><a href="#怎样使用-Github-Pages？" class="headerlink" title="怎样使用 Github Pages？"></a>怎样使用 Github Pages？</h3><p>了解了 Github 之后，我们怎么使用 Github Pages 呢？贴心的 Github 官方已经给出了<a href="https://pages.github.com/">教程</a>。</p><p>根据我的理解，Github 通过 Repo 名字判断你的库是不是要使用 GP 服务。<br>使用 GP 服务的 Repo，需要创建名为 your_id.github.io 的仓库。<br>创建好之后，按照教程所示 clone 到本地，在 Repo 文件夹打开终端，并添加一个 HTML 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">→ <span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span> &gt; index.html</span><br></pre></td></tr></table></figure><p>接下来add，commit 且 push 一条龙，紧接着你就可以用 <a href="https://your_id.github.io/">https://your_id.github.io</a> 来访问你的网站啦。</p><p>可是我的网页光秃秃的，只有白色的底和 Hello World，如何才能让它变得漂亮呢？<br>网页设计是一门很大的学问，涉及到 JavaScript, css 等计算机语言，开发网页并让他们变好看的人称为<strong>前端工程师</strong>。<br>我完全不了解任何 css 或者 js 知识，但许多人已经做出了<strong>现成的管理工具和主题模版</strong>，使得人人都可以让自己的网页变的好看。下面我将介绍的是一个博客框架软件 Hexo。</p><h2 id="了解-Hexo"><a href="#了解-Hexo" class="headerlink" title="了解 Hexo"></a>了解 Hexo</h2><p>Hexo 是一个博客框架管理软件，你可以把它看成一个 HTML/css/Js 文件生成器。它会将你攥写的<strong>Markdown 文件</strong>自动转换为 HTML 文件，搭配一定的格式生成有层次的网页。你可以通过修改配置文件来改变它生成的风格。并且，有许多人都为 Hexo 贡献了主题，你可以按照自己的喜好选择你的博客风格。</p><p><em>(我将会默认读者熟悉 Markdown，如果你不熟悉，可以先看最后的一节)</em></p><h3 id="怎么下载-Hexo-？"><a href="#怎么下载-Hexo-？" class="headerlink" title="怎么下载 Hexo ？"></a>怎么下载 Hexo ？</h3><p>Hexo 在 NodeJS 包管理器内安装。首先需要安装 node，在安装 node 之前则需要安装 macOS 的包管理器 Homebrew。<br>关于 Homebrew 的安装，我推荐<a href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/">清华镜像站</a>给出的安装方法。<br>安装好后，再安装 node。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">→ brew install node</span><br></pre></td></tr></table></figure><p>再通过 npm （即 Node Package Manager）安装 Hexo。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">→ npm install hexo-cli -g</span><br><span class="line">→ hexo init folder_name</span><br><span class="line">→ <span class="built_in">cd</span> folder_name</span><br><span class="line">→ npm install</span><br><span class="line">→ hexo s</span><br></pre></td></tr></table></figure><p>这一套组合拳下来，你将会在目录内得到一个 folder_name 文件夹，并且 Hexo 已经将博客部署在 <a href="http://localhost:4000/">http://localhost:4000</a> 了。<br>如果你想要停止部署，请在终端界面按下<kbd>⌃</kbd> + <kbd>C</kbd>。</p><h3 id="如何使用-Hexo-管理我的-Github-Repository-？"><a href="#如何使用-Hexo-管理我的-Github-Repository-？" class="headerlink" title="如何使用 Hexo 管理我的 Github Repository ？"></a>如何使用 Hexo 管理我的 Github Repository ？</h3><p>刚刚的操作，Hexo 只是在本地生成了网站。我们如何用 Hexo 将网站 push 到 Github 呢？<br>我们当然也可以选择之前的 Git，但 Hexo 为我们提供了更方便的服务。</p><p>打开刚刚创建的 folder_name 文件夹，在 _config.yml （是 Hexo 的配置文件，我们以后会经常使用它）中添加下面的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repository: https:&#x2F;&#x2F;github.com&#x2F;your_id&#x2F;your_id.github.io.git</span><br><span class="line">    branch: main</span><br></pre></td></tr></table></figure><p>之后在终端运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">→ hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><p>在命令结束之后，访问 <a href="https://your_id.github.io/">https://your_id.github.io</a> （可能存在延迟，多刷新），你就可以发现网页已经被配置到服务端了。<br>同时，你会发现 Repo 里的代码全部变了，你之前写的东西都消失了。这是因为 Hexo 的自动部署实际上就是自动化 Git 上传到 Github。</p><p>将网站链接发给你的朋友们（如果有），看看他们能否访问。这样，我们已经完成了最最基础的配置，也就是成功的创建了能看的网页并且托管到了 Github。<br><strong>在下一个 Part，我会讲述如何创建编辑文章，自定义个人网站让它变的好看。</strong></p><h2 id="了解-Markdown"><a href="#了解-Markdown" class="headerlink" title="了解 Markdown"></a>了解 Markdown</h2><p>Markdown 是一种轻量级的标记语言，或者你根本就可以说它不是一门语言。”.md” 后缀的文件，都是使用 Markdown 编辑的。</p><p>它是如此的简单易学，功能强大，以至于很多网站都会使用它，包括这篇文章和你之前见到的 README.md。同时，在看到 “支持 Markdown 语法” 的输入栏里，你可以自由自在的使用这门标记语言。</p><p>关于 Markdown，我在这里不会写太多，只需要去<a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟教程</a>看个十几分钟，并且在博客上实践一下，你很快就能写出美丽的文档啦。</p><hr><p><em>本篇完</em></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站 </tag>
            
            <tag> Hexo </tag>
            
            <tag> GithubPages </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
