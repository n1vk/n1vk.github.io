<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式：基本思想与策略模式</title>
      <link href="%E6%8A%80%E6%9C%AF/design-pattern-0/"/>
      <url>%E6%8A%80%E6%9C%AF/design-pattern-0/</url>
      
        <content type="html"><![CDATA[<p>知道继承，接口，多态和虚类不能让你学会面向对象程序设计。理解<strong>设计模式</strong>，因为设计模式是面向对象开发工程师们多年以来程序设计的经验总结，是为了解决问题而产生的历经验证的工程通用解决方案。良好的设计模式会包含可复用，可扩充，可维护三个特性，而模式可以帮我们做到这点。</p><p>首先来举个简单的例子，来展示继承所不能解决的问题。如图，某游戏公司程序员为自己游戏的职业系统设计了一个 Player 超类，所有的职业都会继承这个超类。在继承时，也会继承超类内所有的方法。如果需要新的职业，那么我们就添加一个新的类。完美！</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://s2.loli.net/2022/03/28/RJelt4WkrKUqCE8.png" class="lazyload" data-srcset="https://s2.loli.net/2022/03/28/RJelt4WkrKUqCE8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=" 美丽的UML图"></div><span class="image-caption"> 美丽的UML图</span></div><p>现在公司抛出了新的需求：要求玩家应该会闪避。这很好办，只需要在超类里加入一个 dodge() 方法即可。但是在测试的时候发现了新的问题：牧师会闪避导致了他过于强大的生存能力，以至于不需要队友保护他。这和游戏的设计理念不太符合，公司要求程序员让牧师不再会闪避。这也很简单，把 Priest 的 dodge() 方法的具体实现覆盖成什么都不做就可以了。到目前为止，一切都很好…</p><p>直到程序员意识到，公司为了赚钱每个月都会推出一款新职业，他们有的专注攻击不能防御，有的利用防御来攻击，有的……噢还有，公司还会推出氪金装备，使得 Priest 可以有限次的进行闪避动作。天啊，这要怎么办？来看看我们从最初的设计原则可以推出什么。</p><h2 id="变与不变"><a href="#变与不变" class="headerlink" title="变与不变"></a>变与不变</h2><div class="story post-story"><p>应用设计的第一个原则：<strong>找出应用中需要变化之处，将其独立，不要和不需要变化的代码写在一起</strong>。这样，每次新的需求来到，我们就可以不修改固定的部分，只修改变化的部分。</p><p>对于我们的游戏设计来说，我们知道 dodge() 是会随着职业的不同而改变的（<em>当然 attack() 和 defense() 也会变，但是原理是一样的</em> ）。那么我们把闪避行为拿出来，并为它创建一个类。<strong>所有的职业都将 HAS-A 闪避行为。</strong></p></div><h2 id="为谁而写"><a href="#为谁而写" class="headerlink" title="为谁而写"></a>为谁而写</h2><div class="story post-story"><p>应用设计的第二个原则：<strong>针对接口编程，不要针对实现编程</strong>。 说真的，我觉得这句话刚一看到非常难理解。</p><p>什么是实现？职业类如果实现了 dodge() 接口，那么就意味着所有职业都要实现这个接口，因为他们都继承自原始的超类。我们不要把什么类能实现什么在最开始的时候写死。</p><p>怎么针对接口编程？我设计一个 DodgeBehaviour 接口，此接口有 dodge() 方法。现在，我们让具体的类实现这个接口。DodgeNormal 类会正常的躲避，而 DodgeNaught 类什么都不做。现在，闪避行为和 Player 类没有任何关系了。我们可以随意添加闪避行为或者修改行为，比如我们为法师设计一个 DodgeKUXUAN，让闪避的时候会增加粒子效果。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://s2.loli.net/2022/03/28/NQL4YrXentSp9gx.png" class="lazyload" data-srcset="https://s2.loli.net/2022/03/28/NQL4YrXentSp9gx.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=" 另一个美丽的UML图"></div><span class="image-caption"> 另一个美丽的UML图</span></div></div><h2 id="完成设计"><a href="#完成设计" class="headerlink" title="完成设计"></a>完成设计</h2><div class="story post-story"><p>现在事情可能会变得有点奇怪，我们如何让某个职业进行闪避？请看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">  healthType Health;</span><br><span class="line">  DodgeBehaviour dodgeBehaviour;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performDodge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dodgeBehaviour.dodge();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们的超类。看，我们通过让职业 HAS-A 行为的方式成功地托管了闪避行为！这也就引出了我们的第三个设计原则：<strong>多用组合，少用继承</strong>。HAS-A is better than IS-A!</p><p>那么相对应的，子类的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Priest</span> <span class="keyword">extends</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Priest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dodgeBehaviour = <span class="keyword">new</span> DodgeNaught();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数里面，我们写好 Priest 会使用哪种 实现了 DodgeBahaviour 的类。不仅如此，如果我们对 dodgeBehaviour 设定一个 setter 函数，我们就可以在程序运行时改变牧师躲避的行为，比如牧师装备了氪金道具，那么就将 dodgeBehaviour 设定成可以闪避并计数，结束后改回去。这比写一个 ”可以进行10次闪避” 的 Priest 职业好太多了！</p><p>同理，攻击和防御方法都可以用相同的方式实现。以上的设计模式我们称为<strong>策略模式</strong>。策略模式<strong>定义且封装了独立于使用算法客户的算法族，使他们相互之间能够替换</strong>。这也不意味着继承方法真的没用了，比如所有的职业都需要走路，那么 walk() 方法就可以继承。关键点是确立好需求，并选择你需要的设计模式。</p><p>（<em>所以，这位程序员该好好跟他的产品经理吵一架 :P</em> ）</p></div>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重新记录我的博客</title>
      <link href="%E9%9A%8F%E6%83%B3/placeholder/"/>
      <url>%E9%9A%8F%E6%83%B3/placeholder/</url>
      
        <content type="html"><![CDATA[<p>两年前，我抱着玩玩的心态在 Github 上部署了一个小博客。然而搜肠刮肚发现自己既没技术，又没文笔，无甚可写，遂作罢。<br>近日和舍友闲谈，偶然间舍友提到了博客。突然想起了自己曾经弄的小站。再联想到自己最近需要学习，记忆力又狠狠衰退，于是打算把博客重拾起来。<br>为了避免自己又忘记什么重要的事，我把操作博客的方法都写下来。</p><h3 id="写作与更新"><a href="#写作与更新" class="headerlink" title="写作与更新"></a>写作与更新</h3><p>在部署时我就选择了 Hexo 托管页面。Hexo 是一个 Node.js 包，它能够自动生成网页，用户所需要做的只是写作。并且，它支持各种插件与主题。<br>使用如下代码在 <code>/source/_posts/</code> 内新建一个文件夹与 markdown 文件，名字为<code>name.md</code>。<code>name</code>也将组成这篇博客的 url 路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new name</span><br></pre></td></tr></table></figure><p>设置好以后，可以在本地<code>5000</code>端口部署测试页面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>待测试没问题后，push 到 Github 吧：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><p>等待几分钟就可以看到结果。</p><h3 id="配置和优化"><a href="#配置和优化" class="headerlink" title="配置和优化"></a>配置和优化</h3><p>关于配置，可以在 <a href="https://volantis.js.org/v5/getting-started/">Volantis 文档</a>内找到所有需要的内容，包括底栏侧栏导航栏配置等等。<br>对于 Post 的封面，我使用 <a href="https://www.canvas.cn/">Canvas 可画</a>来制作，按照微信公众号的标题随便做一个即可。<br>对于在文章内插图，我使用 <a href="https://sm.ms/">SM.MS</a> 图床。</p><h3 id="承诺"><a href="#承诺" class="headerlink" title="承诺"></a>承诺</h3><p>即使发一些毫无意义的 shitpost，我也尽量不会让博客停下来。拖延和懒惰的一部分来自于追求完美，我可能会希望把事情做的足够好，以至于过分注重细枝末节最后放弃。我不要再这样了，我需要有勇气弄脏双手。</p>]]></content>
      
      
      <categories>
          
          <category> 随想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 想法 </tag>
            
            <tag> 记录 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
